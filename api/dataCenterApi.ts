/**
 * CLOUD API
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * The version of the OpenAPI document: 5.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Datacenter } from '../model/datacenter';
import { DatacenterProperties } from '../model/datacenterProperties';
import { Datacenters } from '../model/datacenters';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor, RequestStatusMetadata } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile, RequestApi } from './apis';

let defaultBasePath = 'https://api.ionos.com/cloudapi/v5';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DataCenterApiApiKeys {
        'Token Authentication'
}

export class DataCenterApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    static BAD_GATEWAY = 502;
    static SERVICE_UNAVAILABLE = 503;
    static GATEWAY_TIMEOUT = 504;
    static TOO_MANY_REQUESTS = 429;

    static maxRetries = 3;
    static waitTime = 10;
    static maxWaitTime = 2000;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Basic Authentication': new HttpBasicAuth(),
        'Token Authentication': new ApiKeyAuth('header', 'Authorization'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: DataCenterApiApiKeys, value: string) {
        (this.authentications as any)[DataCenterApiApiKeys[key]].apiKey = value;
    }

    set username(username: string) {
        this.authentications['Basic Authentication'].username = username;
    }

    set password(password: string) {
        this.authentications['Basic Authentication'].password = password;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Will remove all objects within the datacenter and remove the datacenter object itself, too. This is a highly destructive method which should be used with caution
     * @summary Delete a Data Center
     * @param datacenterId The unique ID of the datacenter
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersDelete (datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersDelete.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "object");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case DataCenterApi.BAD_GATEWAY:
                            case DataCenterApi.SERVICE_UNAVAILABLE:
                            case DataCenterApi.GATEWAY_TIMEOUT:
                                backoffTime = DataCenterApi.waitTime;
                                break;
                            case DataCenterApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = DataCenterApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>(apiCallFunction);
        });
    }
    /**
     * You can retrieve a data center by using the resource\'s ID. This value can be found in the response body when a datacenter is created or when you GET a list of datacenters.
     * @summary Retrieve a Data Center
     * @param datacenterId The unique ID of the datacenter
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersFindById (datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Datacenter;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersFindById.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datacenter");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case DataCenterApi.BAD_GATEWAY:
                            case DataCenterApi.SERVICE_UNAVAILABLE:
                            case DataCenterApi.GATEWAY_TIMEOUT:
                                backoffTime = DataCenterApi.waitTime;
                                break;
                            case DataCenterApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = DataCenterApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Datacenter;  }>(apiCallFunction);
        });
    }
    /**
     * You can retrieve a complete list of data centers provisioned under your account
     * @summary List Data Centers under your account
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @param offset the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @param limit the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     */
    public async datacentersGet (pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Datacenters;  }> {
        const localVarPath = this.basePath + '/datacenters';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datacenters");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case DataCenterApi.BAD_GATEWAY:
                            case DataCenterApi.SERVICE_UNAVAILABLE:
                            case DataCenterApi.GATEWAY_TIMEOUT:
                                backoffTime = DataCenterApi.waitTime;
                                break;
                            case DataCenterApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = DataCenterApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Datacenters;  }>(apiCallFunction);
        });
    }
    /**
     * You can use update datacenter to re-name the datacenter or update its description
     * @summary Partially modify a Data Center
     * @param datacenterId The unique ID of the datacenter
     * @param datacenter Modified properties of Data Center
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersPatch (datacenterId: string, datacenter: DatacenterProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Datacenter;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersPatch.');
        }

        // verify required parameter 'datacenter' is not null or undefined
        if (datacenter === null || datacenter === undefined) {
            throw new Error('Required parameter datacenter was null or undefined when calling datacentersPatch.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(datacenter, "DatacenterProperties")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datacenter");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case DataCenterApi.BAD_GATEWAY:
                            case DataCenterApi.SERVICE_UNAVAILABLE:
                            case DataCenterApi.GATEWAY_TIMEOUT:
                                backoffTime = DataCenterApi.waitTime;
                                break;
                            case DataCenterApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = DataCenterApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Datacenter;  }>(apiCallFunction);
        });
    }
    /**
     * Virtual data centers are the foundation of the platform. They act as logical containers for all other objects you will be creating, e.g. servers. You can provision as many data centers as you want. Datacenters have their own private network and are logically segmented from each other to create isolation. You can use this POST method to create a simple datacenter or to create a datacenter with multiple objects under it such as servers and storage volumes.
     * @summary Create a Data Center
     * @param datacenter Datacenter to be created
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersPost (datacenter: Datacenter, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Datacenter;  }> {
        const localVarPath = this.basePath + '/datacenters';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenter' is not null or undefined
        if (datacenter === null || datacenter === undefined) {
            throw new Error('Required parameter datacenter was null or undefined when calling datacentersPost.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(datacenter, "Datacenter")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datacenter");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case DataCenterApi.BAD_GATEWAY:
                            case DataCenterApi.SERVICE_UNAVAILABLE:
                            case DataCenterApi.GATEWAY_TIMEOUT:
                                backoffTime = DataCenterApi.waitTime;
                                break;
                            case DataCenterApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = DataCenterApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Datacenter;  }>(apiCallFunction);
        });
    }
    /**
     * You can use update datacenter to re-name the datacenter or update its description
     * @summary Modify a Data Center
     * @param datacenterId The unique ID of the datacenter
     * @param datacenter Modified Data Center
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersPut (datacenterId: string, datacenter: Datacenter, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Datacenter;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersPut.');
        }

        // verify required parameter 'datacenter' is not null or undefined
        if (datacenter === null || datacenter === undefined) {
            throw new Error('Required parameter datacenter was null or undefined when calling datacentersPut.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(datacenter, "Datacenter")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Datacenter");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case DataCenterApi.BAD_GATEWAY:
                            case DataCenterApi.SERVICE_UNAVAILABLE:
                            case DataCenterApi.GATEWAY_TIMEOUT:
                                backoffTime = DataCenterApi.waitTime;
                                break;
                            case DataCenterApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = DataCenterApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Datacenter;  }>(apiCallFunction);
        });
    }

    public sleep(seconds)
    {
        var e = new Date().getTime() + (seconds * 1000);
        while (new Date().getTime() <= e) {}
    }

    public async waitForCompletion(requestId, timeout=3600, initialWait=5, scaleup=10, maxRetries=10) {
        /**
         Poll resource request status until resource is provisioned.

         :param      requestId: Request id of the action.
         :type       requestId: ``str``

         :param      timeout: Maximum waiting time in seconds. None means infinite waiting time.
         :type       timeout: ``int``

         :param      initialWait: Initial polling interval in seconds.
         :type       initialWait: ``int``

         :param      scaleup: Double polling interval every scaleup steps, which will be doubled.
         :type       scaleup: ``int``

         */

        if (!requestId) {
            throw new Error("Request ID is missing.");
        }

        let waitPeriod = initialWait
        let nextIncrease = Date.now() / 1000 + waitPeriod * scaleup

        timeout = Date.now() / 1000 + timeout

        const requestCall = (new RequestApi(this.username, this.password)).requestsStatusGet(requestId);

        let breakLoop = false;
        while (true) {
            await requestCall.then(
                request => {
                    if (request.body.metadata?.status == RequestStatusMetadata.StatusEnum.Done) {
                        breakLoop = true
                    } else if (request.body.metadata?.status == RequestStatusMetadata.StatusEnum.Failed) {
                        throw new Error(`Request ${requestId} failed to complete: ${request['metadata']['message']}`)
                    }

                }
            )
            if (breakLoop) {
                break
            }

            let currentTime = Date.now() / 1000
            if (timeout && currentTime > timeout) {
                throw new Error(`Timed out waiting for request ${requestId}.`)
            }

            if (currentTime > nextIncrease) {
                waitPeriod *= 2
                nextIncrease = Date.now()/1000 + waitPeriod * scaleup
                scaleup *= 2
            }

            this.sleep(waitPeriod)
        }
    }
}
