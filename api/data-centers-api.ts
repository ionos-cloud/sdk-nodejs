/* tslint:disable */
/* eslint-disable */
/**
 * CLOUD API
 * IONOS Enterprise-grade Infrastructure as a Service (IaaS) solutions can be managed through the Cloud API, in addition or as an alternative to the \"Data Center Designer\" (DCD) browser-based tool.    Both methods employ consistent concepts and features, deliver similar power and flexibility, and can be used to perform a multitude of management tasks, including adding servers, volumes, configuring networks, and so on.
 *
 * The version of the OpenAPI document: 6.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration, DEFAULT_MAX_RETRIES, DEFAULT_MAX_WAIT_TIME } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, backOff, runRequest } from '../base';
// @ts-ignore
import { Datacenter } from '../model';
// @ts-ignore
import { DatacenterProperties } from '../model';
// @ts-ignore
import { Datacenters } from '../model';
/**
 * DataCentersApi - axios parameter creator
 * @export
 */
export const DataCentersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete the specified data center and all the elements it contains. This is method is destructive and should be used carefully.
         * @summary Delete data centers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersDelete: async (datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve data centers by resource ID. This value is in the response body when the data center is created, and in the list of the data centers, returned by GET.
         * @summary Retrieve data centers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersFindById: async (datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersFindById.');
            }
            const localVarPath = `/datacenters/{datacenterId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List the data centers for your account. Default limit is the first 100 items; use pagination query parameters for listing more items.
         * @summary List your data centers
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {number} [offset] The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
         * @param {number} [limit] The maximum number of elements to return (use together with offset for pagination).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersGet: async (pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/datacenters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the properties of the specified data center, rename it, or change the description.
         * @summary Partially modify data centers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {DatacenterProperties} datacenter The properties of the data center to be updated.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersPatch: async (datacenterId: string, datacenter: DatacenterProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersPatch.');
            }
            // verify required parameter 'datacenter' is not null or undefined
            if (datacenter === null || datacenter === undefined) {
                throw new RequiredError('datacenter','Required parameter datacenter was null or undefined when calling datacentersPatch.');
            }
            const localVarPath = `/datacenters/{datacenterId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof datacenter !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(datacenter !== undefined ? datacenter : {})
                : (datacenter || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new data centers, and data centers that already contain elements, such as servers and storage volumes.  Virtual data centers are the foundation of the platform; they act as logical containers for all other objects you create, such as servers and storage volumes. You can provision as many data centers as needed. Data centers have their own private networks and are logically segmented from each other to create isolation.
         * @summary Create data centers
         * @param {Datacenter} datacenter The data center to create.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersPost: async (datacenter: Datacenter, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenter' is not null or undefined
            if (datacenter === null || datacenter === undefined) {
                throw new RequiredError('datacenter','Required parameter datacenter was null or undefined when calling datacentersPost.');
            }
            const localVarPath = `/datacenters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof datacenter !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(datacenter !== undefined ? datacenter : {})
                : (datacenter || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify the properties of the specified data center, rename it, or change the description.
         * @summary Modify data centers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {Datacenter} datacenter The modified data center.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersPut: async (datacenterId: string, datacenter: Datacenter, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersPut.');
            }
            // verify required parameter 'datacenter' is not null or undefined
            if (datacenter === null || datacenter === undefined) {
                throw new RequiredError('datacenter','Required parameter datacenter was null or undefined when calling datacentersPut.');
            }
            const localVarPath = `/datacenters/{datacenterId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof datacenter !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(datacenter !== undefined ? datacenter : {})
                : (datacenter || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataCentersApi - functional programming interface
 * @export
 */
export const DataCentersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete the specified data center and all the elements it contains. This is method is destructive and should be used carefully.
         * @summary Delete data centers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersDelete(datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const axiosArgs = await DataCentersApiAxiosParamCreator(configuration).datacentersDelete(datacenterId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieve data centers by resource ID. This value is in the response body when the data center is created, and in the list of the data centers, returned by GET.
         * @summary Retrieve data centers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersFindById(datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Datacenter>> {
            const axiosArgs = await DataCentersApiAxiosParamCreator(configuration).datacentersFindById(datacenterId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * List the data centers for your account. Default limit is the first 100 items; use pagination query parameters for listing more items.
         * @summary List your data centers
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {number} [offset] The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
         * @param {number} [limit] The maximum number of elements to return (use together with offset for pagination).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersGet(pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Datacenters>> {
            const axiosArgs = await DataCentersApiAxiosParamCreator(configuration).datacentersGet(pretty, depth, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Update the properties of the specified data center, rename it, or change the description.
         * @summary Partially modify data centers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {DatacenterProperties} datacenter The properties of the data center to be updated.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersPatch(datacenterId: string, datacenter: DatacenterProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Datacenter>> {
            const axiosArgs = await DataCentersApiAxiosParamCreator(configuration).datacentersPatch(datacenterId, datacenter, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Create new data centers, and data centers that already contain elements, such as servers and storage volumes.  Virtual data centers are the foundation of the platform; they act as logical containers for all other objects you create, such as servers and storage volumes. You can provision as many data centers as needed. Data centers have their own private networks and are logically segmented from each other to create isolation.
         * @summary Create data centers
         * @param {Datacenter} datacenter The data center to create.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersPost(datacenter: Datacenter, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Datacenter>> {
            const axiosArgs = await DataCentersApiAxiosParamCreator(configuration).datacentersPost(datacenter, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Modify the properties of the specified data center, rename it, or change the description.
         * @summary Modify data centers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {Datacenter} datacenter The modified data center.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersPut(datacenterId: string, datacenter: Datacenter, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Datacenter>> {
            const axiosArgs = await DataCentersApiAxiosParamCreator(configuration).datacentersPut(datacenterId, datacenter, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
    }
};

/**
 * DataCentersApi - factory interface
 * @export
 */
export const DataCentersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete the specified data center and all the elements it contains. This is method is destructive and should be used carefully.
         * @summary Delete data centers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersDelete(datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<void> {
            return DataCentersApiFp(configuration).datacentersDelete(datacenterId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve data centers by resource ID. This value is in the response body when the data center is created, and in the list of the data centers, returned by GET.
         * @summary Retrieve data centers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersFindById(datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Datacenter> {
            return DataCentersApiFp(configuration).datacentersFindById(datacenterId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * List the data centers for your account. Default limit is the first 100 items; use pagination query parameters for listing more items.
         * @summary List your data centers
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {number} [offset] The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
         * @param {number} [limit] The maximum number of elements to return (use together with offset for pagination).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersGet(pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<Datacenters> {
            return DataCentersApiFp(configuration).datacentersGet(pretty, depth, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the properties of the specified data center, rename it, or change the description.
         * @summary Partially modify data centers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {DatacenterProperties} datacenter The properties of the data center to be updated.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersPatch(datacenterId: string, datacenter: DatacenterProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Datacenter> {
            return DataCentersApiFp(configuration).datacentersPatch(datacenterId, datacenter, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new data centers, and data centers that already contain elements, such as servers and storage volumes.  Virtual data centers are the foundation of the platform; they act as logical containers for all other objects you create, such as servers and storage volumes. You can provision as many data centers as needed. Data centers have their own private networks and are logically segmented from each other to create isolation.
         * @summary Create data centers
         * @param {Datacenter} datacenter The data center to create.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersPost(datacenter: Datacenter, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Datacenter> {
            return DataCentersApiFp(configuration).datacentersPost(datacenter, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify the properties of the specified data center, rename it, or change the description.
         * @summary Modify data centers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {Datacenter} datacenter The modified data center.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersPut(datacenterId: string, datacenter: Datacenter, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Datacenter> {
            return DataCentersApiFp(configuration).datacentersPut(datacenterId, datacenter, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for datacentersDelete operation in DataCentersApi.
 * @export
 * @interface DataCentersApiDatacentersDeleteRequest
 */
export interface DataCentersApiDatacentersDeleteRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof DataCentersApiDatacentersDelete
     */
    readonly datacenterId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof DataCentersApiDatacentersDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof DataCentersApiDatacentersDelete
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof DataCentersApiDatacentersDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersFindById operation in DataCentersApi.
 * @export
 * @interface DataCentersApiDatacentersFindByIdRequest
 */
export interface DataCentersApiDatacentersFindByIdRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof DataCentersApiDatacentersFindById
     */
    readonly datacenterId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof DataCentersApiDatacentersFindById
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof DataCentersApiDatacentersFindById
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof DataCentersApiDatacentersFindById
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersGet operation in DataCentersApi.
 * @export
 * @interface DataCentersApiDatacentersGetRequest
 */
export interface DataCentersApiDatacentersGetRequest {
    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof DataCentersApiDatacentersGet
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof DataCentersApiDatacentersGet
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof DataCentersApiDatacentersGet
     */
    readonly xContractNumber?: number

    /**
     * The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
     * @type {number}
     * @memberof DataCentersApiDatacentersGet
     */
    readonly offset?: number

    /**
     * The maximum number of elements to return (use together with offset for pagination).
     * @type {number}
     * @memberof DataCentersApiDatacentersGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersPatch operation in DataCentersApi.
 * @export
 * @interface DataCentersApiDatacentersPatchRequest
 */
export interface DataCentersApiDatacentersPatchRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof DataCentersApiDatacentersPatch
     */
    readonly datacenterId: string

    /**
     * The properties of the data center to be updated.
     * @type {DatacenterProperties}
     * @memberof DataCentersApiDatacentersPatch
     */
    readonly datacenter: DatacenterProperties

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof DataCentersApiDatacentersPatch
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof DataCentersApiDatacentersPatch
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof DataCentersApiDatacentersPatch
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersPost operation in DataCentersApi.
 * @export
 * @interface DataCentersApiDatacentersPostRequest
 */
export interface DataCentersApiDatacentersPostRequest {
    /**
     * The data center to create.
     * @type {Datacenter}
     * @memberof DataCentersApiDatacentersPost
     */
    readonly datacenter: Datacenter

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof DataCentersApiDatacentersPost
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof DataCentersApiDatacentersPost
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof DataCentersApiDatacentersPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersPut operation in DataCentersApi.
 * @export
 * @interface DataCentersApiDatacentersPutRequest
 */
export interface DataCentersApiDatacentersPutRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof DataCentersApiDatacentersPut
     */
    readonly datacenterId: string

    /**
     * The modified data center.
     * @type {Datacenter}
     * @memberof DataCentersApiDatacentersPut
     */
    readonly datacenter: Datacenter

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof DataCentersApiDatacentersPut
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof DataCentersApiDatacentersPut
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof DataCentersApiDatacentersPut
     */
    readonly xContractNumber?: number
}

/**
 * DataCentersApi - object-oriented interface
 * @export
 * @class DataCentersApi
 * @extends {BaseAPI}
 */
export class DataCentersApi extends BaseAPI {
    /**
     * Delete the specified data center and all the elements it contains. This is method is destructive and should be used carefully.
     * @summary Delete data centers
     * @param {DataCentersApiDatacentersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataCentersApi
     */
    public datacentersDelete(requestParameters: DataCentersApiDatacentersDeleteRequest, options?: any) {
        return DataCentersApiFp(this.configuration).datacentersDelete(requestParameters.datacenterId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve data centers by resource ID. This value is in the response body when the data center is created, and in the list of the data centers, returned by GET.
     * @summary Retrieve data centers
     * @param {DataCentersApiDatacentersFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataCentersApi
     */
    public datacentersFindById(requestParameters: DataCentersApiDatacentersFindByIdRequest, options?: any) {
        return DataCentersApiFp(this.configuration).datacentersFindById(requestParameters.datacenterId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the data centers for your account. Default limit is the first 100 items; use pagination query parameters for listing more items.
     * @summary List your data centers
     * @param {DataCentersApiDatacentersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataCentersApi
     */
    public datacentersGet(requestParameters: DataCentersApiDatacentersGetRequest = {}, options?: any) {
        return DataCentersApiFp(this.configuration).datacentersGet(requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the properties of the specified data center, rename it, or change the description.
     * @summary Partially modify data centers
     * @param {DataCentersApiDatacentersPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataCentersApi
     */
    public datacentersPatch(requestParameters: DataCentersApiDatacentersPatchRequest, options?: any) {
        return DataCentersApiFp(this.configuration).datacentersPatch(requestParameters.datacenterId, requestParameters.datacenter, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new data centers, and data centers that already contain elements, such as servers and storage volumes.  Virtual data centers are the foundation of the platform; they act as logical containers for all other objects you create, such as servers and storage volumes. You can provision as many data centers as needed. Data centers have their own private networks and are logically segmented from each other to create isolation.
     * @summary Create data centers
     * @param {DataCentersApiDatacentersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataCentersApi
     */
    public datacentersPost(requestParameters: DataCentersApiDatacentersPostRequest, options?: any) {
        return DataCentersApiFp(this.configuration).datacentersPost(requestParameters.datacenter, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify the properties of the specified data center, rename it, or change the description.
     * @summary Modify data centers
     * @param {DataCentersApiDatacentersPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataCentersApi
     */
    public datacentersPut(requestParameters: DataCentersApiDatacentersPutRequest, options?: any) {
        return DataCentersApiFp(this.configuration).datacentersPut(requestParameters.datacenterId, requestParameters.datacenter, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }
}
