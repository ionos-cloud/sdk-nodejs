/**
 * CLOUD API
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * The version of the OpenAPI document: 5.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { FirewallRule } from '../model/firewallRule';
import { FirewallRules } from '../model/firewallRules';
import { FirewallruleProperties } from '../model/firewallruleProperties';
import { Nic } from '../model/nic';
import { NicProperties } from '../model/nicProperties';
import { Nics } from '../model/nics';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor, RequestStatusMetadata } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile, RequestApi } from './apis';

let defaultBasePath = 'https://api.ionos.com/cloudapi/v5';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum NicApiApiKeys {
        'Token Authentication'
}

export class NicApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    static BAD_GATEWAY = 502;
    static SERVICE_UNAVAILABLE = 503;
    static GATEWAY_TIMEOUT = 504;
    static TOO_MANY_REQUESTS = 429;

    static maxRetries = 3;
    static waitTime = 10;
    static maxWaitTime = 2000;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Basic Authentication': new HttpBasicAuth(),
        'Token Authentication': new ApiKeyAuth('header', 'Authorization'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: NicApiApiKeys, value: string) {
        (this.authentications as any)[NicApiApiKeys[key]].apiKey = value;
    }

    set username(username: string) {
        this.authentications['Basic Authentication'].username = username;
    }

    set password(password: string) {
        this.authentications['Basic Authentication'].password = password;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Deletes the specified NIC.
     * @summary Delete a Nic
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param nicId The unique ID of the NIC
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersNicsDelete (datacenterId: string, serverId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
            .replace('{' + 'nicId' + '}', encodeURIComponent(String(nicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersNicsDelete.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersNicsDelete.');
        }

        // verify required parameter 'nicId' is not null or undefined
        if (nicId === null || nicId === undefined) {
            throw new Error('Required parameter nicId was null or undefined when calling datacentersServersNicsDelete.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "object");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case NicApi.BAD_GATEWAY:
                            case NicApi.SERVICE_UNAVAILABLE:
                            case NicApi.GATEWAY_TIMEOUT:
                                backoffTime = NicApi.waitTime;
                                break;
                            case NicApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = NicApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>(apiCallFunction);
        });
    }
    /**
     * Retrieves the attributes of a given NIC
     * @summary Retrieve a Nic
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param nicId The unique ID of the NIC
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersNicsFindById (datacenterId: string, serverId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Nic;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
            .replace('{' + 'nicId' + '}', encodeURIComponent(String(nicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersNicsFindById.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersNicsFindById.');
        }

        // verify required parameter 'nicId' is not null or undefined
        if (nicId === null || nicId === undefined) {
            throw new Error('Required parameter nicId was null or undefined when calling datacentersServersNicsFindById.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Nic");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case NicApi.BAD_GATEWAY:
                            case NicApi.SERVICE_UNAVAILABLE:
                            case NicApi.GATEWAY_TIMEOUT:
                                backoffTime = NicApi.waitTime;
                                break;
                            case NicApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = NicApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Nic;  }>(apiCallFunction);
        });
    }
    /**
     * Removes the specific Firewall Rule
     * @summary Delete a Firewall Rule
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param nicId The unique ID of the NIC
     * @param firewallruleId The unique ID of the Firewall Rule
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersNicsFirewallrulesDelete (datacenterId: string, serverId: string, nicId: string, firewallruleId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}/firewallrules/{firewallruleId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
            .replace('{' + 'nicId' + '}', encodeURIComponent(String(nicId)))
            .replace('{' + 'firewallruleId' + '}', encodeURIComponent(String(firewallruleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersNicsFirewallrulesDelete.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersNicsFirewallrulesDelete.');
        }

        // verify required parameter 'nicId' is not null or undefined
        if (nicId === null || nicId === undefined) {
            throw new Error('Required parameter nicId was null or undefined when calling datacentersServersNicsFirewallrulesDelete.');
        }

        // verify required parameter 'firewallruleId' is not null or undefined
        if (firewallruleId === null || firewallruleId === undefined) {
            throw new Error('Required parameter firewallruleId was null or undefined when calling datacentersServersNicsFirewallrulesDelete.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "object");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case NicApi.BAD_GATEWAY:
                            case NicApi.SERVICE_UNAVAILABLE:
                            case NicApi.GATEWAY_TIMEOUT:
                                backoffTime = NicApi.waitTime;
                                break;
                            case NicApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = NicApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>(apiCallFunction);
        });
    }
    /**
     * Retrieves the attributes of a given Firewall Rule.
     * @summary Retrieve a Firewall Rule
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param nicId The unique ID of the NIC
     * @param firewallruleId The unique ID of the Firewall Rule
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersNicsFirewallrulesFindById (datacenterId: string, serverId: string, nicId: string, firewallruleId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FirewallRule;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}/firewallrules/{firewallruleId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
            .replace('{' + 'nicId' + '}', encodeURIComponent(String(nicId)))
            .replace('{' + 'firewallruleId' + '}', encodeURIComponent(String(firewallruleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersNicsFirewallrulesFindById.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersNicsFirewallrulesFindById.');
        }

        // verify required parameter 'nicId' is not null or undefined
        if (nicId === null || nicId === undefined) {
            throw new Error('Required parameter nicId was null or undefined when calling datacentersServersNicsFirewallrulesFindById.');
        }

        // verify required parameter 'firewallruleId' is not null or undefined
        if (firewallruleId === null || firewallruleId === undefined) {
            throw new Error('Required parameter firewallruleId was null or undefined when calling datacentersServersNicsFirewallrulesFindById.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FirewallRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case NicApi.BAD_GATEWAY:
                            case NicApi.SERVICE_UNAVAILABLE:
                            case NicApi.GATEWAY_TIMEOUT:
                                backoffTime = NicApi.waitTime;
                                break;
                            case NicApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = NicApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FirewallRule;  }>(apiCallFunction);
        });
    }
    /**
     * Retrieves a list of firewall rules associated with a particular NIC
     * @summary List Firewall Rules 
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param nicId The unique ID of the NIC
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @param offset the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @param limit the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     */
    public async datacentersServersNicsFirewallrulesGet (datacenterId: string, serverId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FirewallRules;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}/firewallrules'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
            .replace('{' + 'nicId' + '}', encodeURIComponent(String(nicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersNicsFirewallrulesGet.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersNicsFirewallrulesGet.');
        }

        // verify required parameter 'nicId' is not null or undefined
        if (nicId === null || nicId === undefined) {
            throw new Error('Required parameter nicId was null or undefined when calling datacentersServersNicsFirewallrulesGet.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FirewallRules");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case NicApi.BAD_GATEWAY:
                            case NicApi.SERVICE_UNAVAILABLE:
                            case NicApi.GATEWAY_TIMEOUT:
                                backoffTime = NicApi.waitTime;
                                break;
                            case NicApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = NicApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FirewallRules;  }>(apiCallFunction);
        });
    }
    /**
     * You can use update attributes of a resource
     * @summary Partially modify a Firewall Rule
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param nicId The unique ID of the NIC
     * @param firewallruleId The unique ID of the Firewall Rule
     * @param firewallrule Modified Firewall Rule
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersNicsFirewallrulesPatch (datacenterId: string, serverId: string, nicId: string, firewallruleId: string, firewallrule: FirewallruleProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FirewallRule;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}/firewallrules/{firewallruleId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
            .replace('{' + 'nicId' + '}', encodeURIComponent(String(nicId)))
            .replace('{' + 'firewallruleId' + '}', encodeURIComponent(String(firewallruleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersNicsFirewallrulesPatch.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersNicsFirewallrulesPatch.');
        }

        // verify required parameter 'nicId' is not null or undefined
        if (nicId === null || nicId === undefined) {
            throw new Error('Required parameter nicId was null or undefined when calling datacentersServersNicsFirewallrulesPatch.');
        }

        // verify required parameter 'firewallruleId' is not null or undefined
        if (firewallruleId === null || firewallruleId === undefined) {
            throw new Error('Required parameter firewallruleId was null or undefined when calling datacentersServersNicsFirewallrulesPatch.');
        }

        // verify required parameter 'firewallrule' is not null or undefined
        if (firewallrule === null || firewallrule === undefined) {
            throw new Error('Required parameter firewallrule was null or undefined when calling datacentersServersNicsFirewallrulesPatch.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(firewallrule, "FirewallruleProperties")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FirewallRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case NicApi.BAD_GATEWAY:
                            case NicApi.SERVICE_UNAVAILABLE:
                            case NicApi.GATEWAY_TIMEOUT:
                                backoffTime = NicApi.waitTime;
                                break;
                            case NicApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = NicApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FirewallRule;  }>(apiCallFunction);
        });
    }
    /**
     * This will add a Firewall Rule to the NIC
     * @summary Create a Firewall Rule
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the server
     * @param nicId The unique ID of the NIC
     * @param firewallrule Firewall Rule to be created
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersNicsFirewallrulesPost (datacenterId: string, serverId: string, nicId: string, firewallrule: FirewallRule, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FirewallRule;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}/firewallrules'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
            .replace('{' + 'nicId' + '}', encodeURIComponent(String(nicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersNicsFirewallrulesPost.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersNicsFirewallrulesPost.');
        }

        // verify required parameter 'nicId' is not null or undefined
        if (nicId === null || nicId === undefined) {
            throw new Error('Required parameter nicId was null or undefined when calling datacentersServersNicsFirewallrulesPost.');
        }

        // verify required parameter 'firewallrule' is not null or undefined
        if (firewallrule === null || firewallrule === undefined) {
            throw new Error('Required parameter firewallrule was null or undefined when calling datacentersServersNicsFirewallrulesPost.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(firewallrule, "FirewallRule")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FirewallRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case NicApi.BAD_GATEWAY:
                            case NicApi.SERVICE_UNAVAILABLE:
                            case NicApi.GATEWAY_TIMEOUT:
                                backoffTime = NicApi.waitTime;
                                break;
                            case NicApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = NicApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FirewallRule;  }>(apiCallFunction);
        });
    }
    /**
     * You can use update attributes of a resource
     * @summary Modify a Firewall Rule
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param nicId The unique ID of the NIC
     * @param firewallruleId The unique ID of the Firewall Rule
     * @param firewallrule Modified Firewall Rule
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersNicsFirewallrulesPut (datacenterId: string, serverId: string, nicId: string, firewallruleId: string, firewallrule: FirewallRule, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FirewallRule;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}/firewallrules/{firewallruleId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
            .replace('{' + 'nicId' + '}', encodeURIComponent(String(nicId)))
            .replace('{' + 'firewallruleId' + '}', encodeURIComponent(String(firewallruleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersNicsFirewallrulesPut.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersNicsFirewallrulesPut.');
        }

        // verify required parameter 'nicId' is not null or undefined
        if (nicId === null || nicId === undefined) {
            throw new Error('Required parameter nicId was null or undefined when calling datacentersServersNicsFirewallrulesPut.');
        }

        // verify required parameter 'firewallruleId' is not null or undefined
        if (firewallruleId === null || firewallruleId === undefined) {
            throw new Error('Required parameter firewallruleId was null or undefined when calling datacentersServersNicsFirewallrulesPut.');
        }

        // verify required parameter 'firewallrule' is not null or undefined
        if (firewallrule === null || firewallrule === undefined) {
            throw new Error('Required parameter firewallrule was null or undefined when calling datacentersServersNicsFirewallrulesPut.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(firewallrule, "FirewallRule")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FirewallRule");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case NicApi.BAD_GATEWAY:
                            case NicApi.SERVICE_UNAVAILABLE:
                            case NicApi.GATEWAY_TIMEOUT:
                                backoffTime = NicApi.waitTime;
                                break;
                            case NicApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = NicApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FirewallRule;  }>(apiCallFunction);
        });
    }
    /**
     * Retrieves a list of NICs.
     * @summary List Nics 
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @param offset the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @param limit the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     */
    public async datacentersServersNicsGet (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Nics;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/nics'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersNicsGet.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersNicsGet.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Nics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case NicApi.BAD_GATEWAY:
                            case NicApi.SERVICE_UNAVAILABLE:
                            case NicApi.GATEWAY_TIMEOUT:
                                backoffTime = NicApi.waitTime;
                                break;
                            case NicApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = NicApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Nics;  }>(apiCallFunction);
        });
    }
    /**
     * You can use update attributes of a Nic
     * @summary Partially modify a Nic
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param nicId The unique ID of the NIC
     * @param nic Modified properties of Nic
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersNicsPatch (datacenterId: string, serverId: string, nicId: string, nic: NicProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Nic;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
            .replace('{' + 'nicId' + '}', encodeURIComponent(String(nicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersNicsPatch.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersNicsPatch.');
        }

        // verify required parameter 'nicId' is not null or undefined
        if (nicId === null || nicId === undefined) {
            throw new Error('Required parameter nicId was null or undefined when calling datacentersServersNicsPatch.');
        }

        // verify required parameter 'nic' is not null or undefined
        if (nic === null || nic === undefined) {
            throw new Error('Required parameter nic was null or undefined when calling datacentersServersNicsPatch.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(nic, "NicProperties")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Nic");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case NicApi.BAD_GATEWAY:
                            case NicApi.SERVICE_UNAVAILABLE:
                            case NicApi.GATEWAY_TIMEOUT:
                                backoffTime = NicApi.waitTime;
                                break;
                            case NicApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = NicApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Nic;  }>(apiCallFunction);
        });
    }
    /**
     * Adds a NIC to the target server. Combine count of Nics and volumes attached to the server should not exceed size 24.
     * @summary Create a Nic
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param nic Nic to be created
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersNicsPost (datacenterId: string, serverId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Nic;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/nics'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersNicsPost.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersNicsPost.');
        }

        // verify required parameter 'nic' is not null or undefined
        if (nic === null || nic === undefined) {
            throw new Error('Required parameter nic was null or undefined when calling datacentersServersNicsPost.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(nic, "Nic")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Nic");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case NicApi.BAD_GATEWAY:
                            case NicApi.SERVICE_UNAVAILABLE:
                            case NicApi.GATEWAY_TIMEOUT:
                                backoffTime = NicApi.waitTime;
                                break;
                            case NicApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = NicApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Nic;  }>(apiCallFunction);
        });
    }
    /**
     * You can use update attributes of a Nic
     * @summary Modify a Nic
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param nicId The unique ID of the NIC
     * @param nic Modified Nic
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersNicsPut (datacenterId: string, serverId: string, nicId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Nic;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
            .replace('{' + 'nicId' + '}', encodeURIComponent(String(nicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersNicsPut.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersNicsPut.');
        }

        // verify required parameter 'nicId' is not null or undefined
        if (nicId === null || nicId === undefined) {
            throw new Error('Required parameter nicId was null or undefined when calling datacentersServersNicsPut.');
        }

        // verify required parameter 'nic' is not null or undefined
        if (nic === null || nic === undefined) {
            throw new Error('Required parameter nic was null or undefined when calling datacentersServersNicsPut.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(nic, "Nic")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Nic");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case NicApi.BAD_GATEWAY:
                            case NicApi.SERVICE_UNAVAILABLE:
                            case NicApi.GATEWAY_TIMEOUT:
                                backoffTime = NicApi.waitTime;
                                break;
                            case NicApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = NicApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Nic;  }>(apiCallFunction);
        });
    }

    public sleep(seconds)
    {
        var e = new Date().getTime() + (seconds * 1000);
        while (new Date().getTime() <= e) {}
    }

    public async waitForCompletion(requestId, timeout=3600, initialWait=5, scaleup=10, maxRetries=10) {
        /**
         Poll resource request status until resource is provisioned.

         :param      requestId: Request id of the action.
         :type       requestId: ``str``

         :param      timeout: Maximum waiting time in seconds. None means infinite waiting time.
         :type       timeout: ``int``

         :param      initialWait: Initial polling interval in seconds.
         :type       initialWait: ``int``

         :param      scaleup: Double polling interval every scaleup steps, which will be doubled.
         :type       scaleup: ``int``

         */

        if (!requestId) {
            throw new Error("Request ID is missing.");
        }

        let waitPeriod = initialWait
        let nextIncrease = Date.now() / 1000 + waitPeriod * scaleup

        timeout = Date.now() / 1000 + timeout

        const requestCall = (new RequestApi(this.username, this.password)).requestsStatusGet(requestId);

        let breakLoop = false;
        while (true) {
            await requestCall.then(
                request => {
                    if (request.body.metadata?.status == RequestStatusMetadata.StatusEnum.Done) {
                        breakLoop = true
                    } else if (request.body.metadata?.status == RequestStatusMetadata.StatusEnum.Failed) {
                        throw new Error(`Request ${requestId} failed to complete: ${request['metadata']['message']}`)
                    }

                }
            )
            if (breakLoop) {
                break
            }

            let currentTime = Date.now() / 1000
            if (timeout && currentTime > timeout) {
                throw new Error(`Timed out waiting for request ${requestId}.`)
            }

            if (currentTime > nextIncrease) {
                waitPeriod *= 2
                nextIncrease = Date.now()/1000 + waitPeriod * scaleup
                scaleup *= 2
            }

            this.sleep(waitPeriod)
        }
    }
}
