/**
 * CLOUD API
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * The version of the OpenAPI document: 5.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { AttachedVolumes } from '../model/attachedVolumes';
import { Cdroms } from '../model/cdroms';
import { Image } from '../model/image';
import { Server } from '../model/server';
import { ServerProperties } from '../model/serverProperties';
import { Servers } from '../model/servers';
import { Volume } from '../model/volume';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor, RequestStatusMetadata } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile, RequestApi } from './apis';

let defaultBasePath = 'https://api.ionos.com/cloudapi/v5';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ServerApiApiKeys {
        'Token Authentication'
}

export class ServerApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    static BAD_GATEWAY = 502;
    static SERVICE_UNAVAILABLE = 503;
    static GATEWAY_TIMEOUT = 504;
    static TOO_MANY_REQUESTS = 429;

    static maxRetries = 3;
    static waitTime = 10;
    static maxWaitTime = 2000;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Basic Authentication': new HttpBasicAuth(),
        'Token Authentication': new ApiKeyAuth('header', 'Authorization'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ServerApiApiKeys, value: string) {
        (this.authentications as any)[ServerApiApiKeys[key]].apiKey = value;
    }

    set username(username: string) {
        this.authentications['Basic Authentication'].username = username;
    }

    set password(password: string) {
        this.authentications['Basic Authentication'].password = password;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * This will detach a CD-ROM from the server
     * @summary Detach a CD-ROM
     * @param datacenterId The unique ID of the Datacenter
     * @param serverId The unique ID of the Server
     * @param cdromId The unique ID of the CD-ROM
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersCdromsDelete (datacenterId: string, serverId: string, cdromId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/cdroms/{cdromId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
            .replace('{' + 'cdromId' + '}', encodeURIComponent(String(cdromId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersCdromsDelete.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersCdromsDelete.');
        }

        // verify required parameter 'cdromId' is not null or undefined
        if (cdromId === null || cdromId === undefined) {
            throw new Error('Required parameter cdromId was null or undefined when calling datacentersServersCdromsDelete.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "object");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>(apiCallFunction);
        });
    }
    /**
     * You can retrieve a specific CD-ROM attached to the server
     * @summary Retrieve an attached CD-ROM
     * @param datacenterId The unique ID of the Datacenter
     * @param serverId The unique ID of the Server
     * @param cdromId The unique ID of the CD-ROM
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersCdromsFindById (datacenterId: string, serverId: string, cdromId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Image;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/cdroms/{cdromId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
            .replace('{' + 'cdromId' + '}', encodeURIComponent(String(cdromId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersCdromsFindById.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersCdromsFindById.');
        }

        // verify required parameter 'cdromId' is not null or undefined
        if (cdromId === null || cdromId === undefined) {
            throw new Error('Required parameter cdromId was null or undefined when calling datacentersServersCdromsFindById.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Image");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Image;  }>(apiCallFunction);
        });
    }
    /**
     * You can retrieve a list of CD-ROMs attached to the server.
     * @summary List attached CD-ROMs 
     * @param datacenterId The unique ID of the Datacenter
     * @param serverId The unique ID of the Server
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @param offset the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @param limit the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     */
    public async datacentersServersCdromsGet (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Cdroms;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/cdroms'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersCdromsGet.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersCdromsGet.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Cdroms");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Cdroms;  }>(apiCallFunction);
        });
    }
    /**
     * You can attach a CD-ROM to an existing server. You can attach up to 2 CD-ROMs to one server. 
     * @summary Attach a CD-ROM
     * @param datacenterId The unique ID of the Datacenter
     * @param serverId The unique ID of the Server
     * @param cdrom CD-ROM to be attached
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersCdromsPost (datacenterId: string, serverId: string, cdrom: Image, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Image;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/cdroms'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersCdromsPost.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersCdromsPost.');
        }

        // verify required parameter 'cdrom' is not null or undefined
        if (cdrom === null || cdrom === undefined) {
            throw new Error('Required parameter cdrom was null or undefined when calling datacentersServersCdromsPost.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(cdrom, "Image")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Image");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Image;  }>(apiCallFunction);
        });
    }
    /**
     * This will remove a server from your datacenter; however, it will not remove the storage volumes attached to the server. You will need to make a separate API call to perform that action
     * @summary Delete a Server
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersDelete (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersDelete.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersDelete.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "object");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>(apiCallFunction);
        });
    }
    /**
     * Returns information about a server such as its configuration, provisioning status, etc.
     * @summary Retrieve a Server
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersFindById (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Server;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersFindById.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersFindById.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Server");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Server;  }>(apiCallFunction);
        });
    }
    /**
     * You can retrieve a list of servers within a datacenter
     * @summary List Servers 
     * @param datacenterId The unique ID of the datacenter
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param upgradeNeeded It can be used to filter which servers can be upgraded which can not be upgraded.
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @param offset the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @param limit the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     */
    public async datacentersServersGet (datacenterId: string, pretty?: boolean, depth?: number, upgradeNeeded?: boolean, xContractNumber?: number, offset?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Servers;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersGet.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        if (upgradeNeeded !== undefined) {
            localVarQueryParameters['upgradeNeeded'] = ObjectSerializer.serialize(upgradeNeeded, "boolean");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Servers");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Servers;  }>(apiCallFunction);
        });
    }
    /**
     * You can use update attributes of a server
     * @summary Partially modify a Server
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the server
     * @param server Modified properties of Server
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersPatch (datacenterId: string, serverId: string, server: ServerProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Server;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersPatch.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersPatch.');
        }

        // verify required parameter 'server' is not null or undefined
        if (server === null || server === undefined) {
            throw new Error('Required parameter server was null or undefined when calling datacentersServersPatch.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(server, "ServerProperties")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Server");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Server;  }>(apiCallFunction);
        });
    }
    /**
     * Creates a server within an existing datacenter. You can configure the boot volume and connect the server to an existing LAN.
     * @summary Create a Server
     * @param datacenterId The unique ID of the datacenter
     * @param server Server to be created
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersPost (datacenterId: string, server: Server, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Server;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersPost.');
        }

        // verify required parameter 'server' is not null or undefined
        if (server === null || server === undefined) {
            throw new Error('Required parameter server was null or undefined when calling datacentersServersPost.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(server, "Server")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Server");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Server;  }>(apiCallFunction);
        });
    }
    /**
     * Allows to modify the attributes of a Server. From v5 onwards \'allowReboot\' attribute will no longer be available. For certain server property change it was earlier forced to be provided. Now this behaviour is implicit and backend will do this automatically e.g. in earlier versions, when CPU family changes, the \'allowReboot\' property was required to be set to true which will no longer be the case and the server will be rebooted automatically
     * @summary Modify a Server
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the server
     * @param server Modified Server
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersPut (datacenterId: string, serverId: string, server: Server, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Server;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersPut.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersPut.');
        }

        // verify required parameter 'server' is not null or undefined
        if (server === null || server === undefined) {
            throw new Error('Required parameter server was null or undefined when calling datacentersServersPut.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(server, "Server")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Server");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Server;  }>(apiCallFunction);
        });
    }
    /**
     * This will force a hard reboot of the server. Do not use this method if you want to gracefully reboot the machine. This is the equivalent of powering off the machine and turning it back on.
     * @summary Reboot a Server
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersRebootPost (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/reboot'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersRebootPost.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersRebootPost.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "object");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>(apiCallFunction);
        });
    }
    /**
     * This will start a server. If the server\'s public IP was deallocated then a new IP will be assigned
     * @summary Start a Server
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersStartPost (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/start'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersStartPost.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersStartPost.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "object");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>(apiCallFunction);
        });
    }
    /**
     * This will stop a server. The machine will be forcefully powered off, billing will cease, and the public IP, if one is allocated, will be deallocated. The operation is not supported for Cube servers.
     * @summary Stop a Server
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersStopPost (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/stop'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersStopPost.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersStopPost.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "object");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>(apiCallFunction);
        });
    }
    /**
     * This will upgrade the version of the server, if needed. To verify if there is an upgrade available for a server, call \'/datacenters/{datacenterId}/servers?upgradeNeeded=true\'
     * @summary Upgrade a Server
     * @param datacenterId The unique ID of the datacenter
     * @param serverId The unique ID of the Server
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersUpgradePost (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/upgrade'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersUpgradePost.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersUpgradePost.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "object");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>(apiCallFunction);
        });
    }
    /**
     * This will detach the volume from the server. This will not delete the volume from your datacenter. You will need to make a separate request to perform a deletion
     * @summary Detach a volume
     * @param datacenterId The unique ID of the Datacenter
     * @param serverId The unique ID of the Server
     * @param volumeId The unique ID of the Volume
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersVolumesDelete (datacenterId: string, serverId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/volumes/{volumeId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
            .replace('{' + 'volumeId' + '}', encodeURIComponent(String(volumeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersVolumesDelete.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersVolumesDelete.');
        }

        // verify required parameter 'volumeId' is not null or undefined
        if (volumeId === null || volumeId === undefined) {
            throw new Error('Required parameter volumeId was null or undefined when calling datacentersServersVolumesDelete.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "object");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>(apiCallFunction);
        });
    }
    /**
     * This will retrieve the properties of an attached volume.
     * @summary Retrieve an attached volume
     * @param datacenterId The unique ID of the Datacenter
     * @param serverId The unique ID of the Server
     * @param volumeId The unique ID of the Volume
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersVolumesFindById (datacenterId: string, serverId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Volume;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/volumes/{volumeId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
            .replace('{' + 'volumeId' + '}', encodeURIComponent(String(volumeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersVolumesFindById.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersVolumesFindById.');
        }

        // verify required parameter 'volumeId' is not null or undefined
        if (volumeId === null || volumeId === undefined) {
            throw new Error('Required parameter volumeId was null or undefined when calling datacentersServersVolumesFindById.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Volume");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Volume;  }>(apiCallFunction);
        });
    }
    /**
     * You can retrieve a list of volumes attached to the server
     * @summary List Attached Volumes
     * @param datacenterId The unique ID of the Datacenter
     * @param serverId The unique ID of the Server
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @param offset the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @param limit the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     */
    public async datacentersServersVolumesGet (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AttachedVolumes;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/volumes'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersVolumesGet.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersVolumesGet.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AttachedVolumes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AttachedVolumes;  }>(apiCallFunction);
        });
    }
    /**
     * This will attach a pre-existing storage volume to the server. It is also possible to create and attach a volume in one step just by providing a new volume description as payload. Combine count of Nics and volumes attached to the server should not exceed size 24.
     * @summary Attach a volume
     * @param datacenterId The unique ID of the Datacenter
     * @param serverId The unique ID of the Server
     * @param volume Volume to be attached (created and attached)
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersServersVolumesPost (datacenterId: string, serverId: string, volume: Volume, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Volume;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/volumes'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersVolumesPost.');
        }

        // verify required parameter 'serverId' is not null or undefined
        if (serverId === null || serverId === undefined) {
            throw new Error('Required parameter serverId was null or undefined when calling datacentersServersVolumesPost.');
        }

        // verify required parameter 'volume' is not null or undefined
        if (volume === null || volume === undefined) {
            throw new Error('Required parameter volume was null or undefined when calling datacentersServersVolumesPost.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(volume, "Volume")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Volume");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = response.headers['retry-after']
                        }

                        switch (response.statusCode) {
                            case ServerApi.BAD_GATEWAY:
                            case ServerApi.SERVICE_UNAVAILABLE:
                            case ServerApi.GATEWAY_TIMEOUT:
                                backoffTime = ServerApi.waitTime;
                                break;
                            case ServerApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                } else {
                                    backoffTime = ServerApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Volume;  }>(apiCallFunction);
        });
    }

    public sleep(seconds)
    {
        var e = new Date().getTime() + (seconds * 1000);
        while (new Date().getTime() <= e) {}
    }

    public async waitForCompletion(requestId, timeout=3600, initialWait=5, scaleup=10, maxRetries=10) {
        /**
         Poll resource request status until resource is provisioned.

         :param      requestId: Request id of the action.
         :type       requestId: ``str``

         :param      timeout: Maximum waiting time in seconds. None means infinite waiting time.
         :type       timeout: ``int``

         :param      initialWait: Initial polling interval in seconds.
         :type       initialWait: ``int``

         :param      scaleup: Double polling interval every scaleup steps, which will be doubled.
         :type       scaleup: ``int``

         */

        if (!requestId) {
            throw new Error("Request ID is missing.");
        }

        let waitPeriod = initialWait
        let nextIncrease = Date.now() / 1000 + waitPeriod * scaleup

        timeout = Date.now() / 1000 + timeout

        const requestCall = (new RequestApi(this.username, this.password)).requestsStatusGet(requestId);

        let breakLoop = false;
        while (true) {
            await requestCall.then(
                request => {
                    if (request.body.metadata?.status == RequestStatusMetadata.StatusEnum.Done) {
                        breakLoop = true
                    } else if (request.body.metadata?.status == RequestStatusMetadata.StatusEnum.Failed) {
                        throw new Error(`Request ${requestId} failed to complete: ${request['metadata']['message']}`)
                    }

                }
            )
            if (breakLoop) {
                break
            }

            let currentTime = Date.now() / 1000
            if (timeout && currentTime > timeout) {
                throw new Error(`Timed out waiting for request ${requestId}.`)
            }

            if (currentTime > nextIncrease) {
                waitPeriod *= 2
                nextIncrease = Date.now()/1000 + waitPeriod * scaleup
                scaleup *= 2
            }

            this.sleep(waitPeriod)
        }
    }
}
