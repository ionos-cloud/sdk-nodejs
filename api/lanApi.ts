/**
 * CLOUD API
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * The version of the OpenAPI document: 5.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { Lan } from '../model/lan';
import { LanNics } from '../model/lanNics';
import { LanPost } from '../model/lanPost';
import { LanProperties } from '../model/lanProperties';
import { Lans } from '../model/lans';
import { Nic } from '../model/nic';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor, RequestStatusMetadata } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile, RequestApi } from './apis';

let defaultBasePath = 'https://api.ionos.com/cloudapi/v5';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum LanApiApiKeys {
        'Token Authentication'
}

export class LanApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    static BAD_GATEWAY = 502;
    static SERVICE_UNAVAILABLE = 503;
    static GATEWAY_TIMEOUT = 504;
    static TOO_MANY_REQUESTS = 429;

    static maxRetries = 3;
    static waitTime = 10;
    static maxWaitTime = 2000;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Basic Authentication': new HttpBasicAuth(),
        'Token Authentication': new ApiKeyAuth('header', 'Authorization'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: LanApiApiKeys, value: string) {
        (this.authentications as any)[LanApiApiKeys[key]].apiKey = value;
    }

    set username(username: string) {
        this.authentications['Basic Authentication'].username = username;
    }

    set password(password: string) {
        this.authentications['Basic Authentication'].password = password;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Removes the specific Lan
     * @summary Delete a Lan.
     * @param datacenterId The unique ID of the datacenter
     * @param lanId The unique ID of the LAN
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersLansDelete (datacenterId: string, lanId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/lans/{lanId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'lanId' + '}', encodeURIComponent(String(lanId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersLansDelete.');
        }

        // verify required parameter 'lanId' is not null or undefined
        if (lanId === null || lanId === undefined) {
            throw new Error('Required parameter lanId was null or undefined when calling datacentersLansDelete.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "object");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = parseInt(response.headers['retry-after']);
                        }

                        switch (response.statusCode) {
                            case LanApi.BAD_GATEWAY:
                            case LanApi.SERVICE_UNAVAILABLE:
                            case LanApi.GATEWAY_TIMEOUT:
                                backoffTime = LanApi.waitTime;
                                break;
                            case LanApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = parseInt(response.headers['retry-after']);
                                } else {
                                    backoffTime = LanApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>(apiCallFunction);
        });
    }
    /**
     * Retrieves the attributes of a given LAN
     * @summary Retrieve a Lan
     * @param datacenterId The unique ID of the datacenter
     * @param lanId The unique ID of the LAN
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersLansFindById (datacenterId: string, lanId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Lan;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/lans/{lanId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'lanId' + '}', encodeURIComponent(String(lanId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersLansFindById.');
        }

        // verify required parameter 'lanId' is not null or undefined
        if (lanId === null || lanId === undefined) {
            throw new Error('Required parameter lanId was null or undefined when calling datacentersLansFindById.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Lan");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = parseInt(response.headers['retry-after']);
                        }

                        switch (response.statusCode) {
                            case LanApi.BAD_GATEWAY:
                            case LanApi.SERVICE_UNAVAILABLE:
                            case LanApi.GATEWAY_TIMEOUT:
                                backoffTime = LanApi.waitTime;
                                break;
                            case LanApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = parseInt(response.headers['retry-after']);
                                } else {
                                    backoffTime = LanApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Lan;  }>(apiCallFunction);
        });
    }
    /**
     * Retrieve a list of LANs within the datacenter
     * @summary List Lans
     * @param datacenterId The unique ID of the datacenter
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @param offset the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @param limit the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     */
    public async datacentersLansGet (datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Lans;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/lans'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersLansGet.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Lans");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = parseInt(response.headers['retry-after']);
                        }

                        switch (response.statusCode) {
                            case LanApi.BAD_GATEWAY:
                            case LanApi.SERVICE_UNAVAILABLE:
                            case LanApi.GATEWAY_TIMEOUT:
                                backoffTime = LanApi.waitTime;
                                break;
                            case LanApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = parseInt(response.headers['retry-after']);
                                } else {
                                    backoffTime = LanApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Lans;  }>(apiCallFunction);
        });
    }
    /**
     * This will retrieve the properties of an attached nic.
     * @summary Retrieve a nic attached to lan
     * @param datacenterId The unique ID of the datacenter
     * @param lanId The unique ID of the LAN
     * @param nicId The unique ID of the NIC
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersLansNicsFindById (datacenterId: string, lanId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Nic;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/lans/{lanId}/nics/{nicId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'lanId' + '}', encodeURIComponent(String(lanId)))
            .replace('{' + 'nicId' + '}', encodeURIComponent(String(nicId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersLansNicsFindById.');
        }

        // verify required parameter 'lanId' is not null or undefined
        if (lanId === null || lanId === undefined) {
            throw new Error('Required parameter lanId was null or undefined when calling datacentersLansNicsFindById.');
        }

        // verify required parameter 'nicId' is not null or undefined
        if (nicId === null || nicId === undefined) {
            throw new Error('Required parameter nicId was null or undefined when calling datacentersLansNicsFindById.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Nic");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = parseInt(response.headers['retry-after']);
                        }

                        switch (response.statusCode) {
                            case LanApi.BAD_GATEWAY:
                            case LanApi.SERVICE_UNAVAILABLE:
                            case LanApi.GATEWAY_TIMEOUT:
                                backoffTime = LanApi.waitTime;
                                break;
                            case LanApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = parseInt(response.headers['retry-after']);
                                } else {
                                    backoffTime = LanApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Nic;  }>(apiCallFunction);
        });
    }
    /**
     * You can retrieve a list of nics attached to a lan
     * @summary List Lan Members 
     * @param datacenterId The unique ID of the datacenter
     * @param lanId The unique ID of the LAN
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @param offset the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @param limit the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     */
    public async datacentersLansNicsGet (datacenterId: string, lanId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: LanNics;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/lans/{lanId}/nics'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'lanId' + '}', encodeURIComponent(String(lanId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersLansNicsGet.');
        }

        // verify required parameter 'lanId' is not null or undefined
        if (lanId === null || lanId === undefined) {
            throw new Error('Required parameter lanId was null or undefined when calling datacentersLansNicsGet.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LanNics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = parseInt(response.headers['retry-after']);
                        }

                        switch (response.statusCode) {
                            case LanApi.BAD_GATEWAY:
                            case LanApi.SERVICE_UNAVAILABLE:
                            case LanApi.GATEWAY_TIMEOUT:
                                backoffTime = LanApi.waitTime;
                                break;
                            case LanApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = parseInt(response.headers['retry-after']);
                                } else {
                                    backoffTime = LanApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: LanNics;  }>(apiCallFunction);
        });
    }
    /**
     * This will attach a pre-existing nic to a lan. 
     * @summary Attach a nic
     * @param datacenterId The unique ID of the datacenter
     * @param lanId The unique ID of the LAN
     * @param nic Nic to be attached
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersLansNicsPost (datacenterId: string, lanId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Nic;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/lans/{lanId}/nics'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'lanId' + '}', encodeURIComponent(String(lanId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersLansNicsPost.');
        }

        // verify required parameter 'lanId' is not null or undefined
        if (lanId === null || lanId === undefined) {
            throw new Error('Required parameter lanId was null or undefined when calling datacentersLansNicsPost.');
        }

        // verify required parameter 'nic' is not null or undefined
        if (nic === null || nic === undefined) {
            throw new Error('Required parameter nic was null or undefined when calling datacentersLansNicsPost.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(nic, "Nic")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Nic");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = parseInt(response.headers['retry-after']);
                        }

                        switch (response.statusCode) {
                            case LanApi.BAD_GATEWAY:
                            case LanApi.SERVICE_UNAVAILABLE:
                            case LanApi.GATEWAY_TIMEOUT:
                                backoffTime = LanApi.waitTime;
                                break;
                            case LanApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = parseInt(response.headers['retry-after']);
                                } else {
                                    backoffTime = LanApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Nic;  }>(apiCallFunction);
        });
    }
    /**
     * You can use update attributes of a resource
     * @summary Partially modify a Lan
     * @param datacenterId The unique ID of the datacenter
     * @param lanId The unique ID of the LAN
     * @param lan Modified Lan
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersLansPatch (datacenterId: string, lanId: string, lan: LanProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Lan;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/lans/{lanId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'lanId' + '}', encodeURIComponent(String(lanId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersLansPatch.');
        }

        // verify required parameter 'lanId' is not null or undefined
        if (lanId === null || lanId === undefined) {
            throw new Error('Required parameter lanId was null or undefined when calling datacentersLansPatch.');
        }

        // verify required parameter 'lan' is not null or undefined
        if (lan === null || lan === undefined) {
            throw new Error('Required parameter lan was null or undefined when calling datacentersLansPatch.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(lan, "LanProperties")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Lan");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = parseInt(response.headers['retry-after']);
                        }

                        switch (response.statusCode) {
                            case LanApi.BAD_GATEWAY:
                            case LanApi.SERVICE_UNAVAILABLE:
                            case LanApi.GATEWAY_TIMEOUT:
                                backoffTime = LanApi.waitTime;
                                break;
                            case LanApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = parseInt(response.headers['retry-after']);
                                } else {
                                    backoffTime = LanApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Lan;  }>(apiCallFunction);
        });
    }
    /**
     * Creates a LAN within the datacenter
     * @summary Create a Lan
     * @param datacenterId The unique ID of the datacenter
     * @param lan Lan to be created
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersLansPost (datacenterId: string, lan: LanPost, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: LanPost;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/lans'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersLansPost.');
        }

        // verify required parameter 'lan' is not null or undefined
        if (lan === null || lan === undefined) {
            throw new Error('Required parameter lan was null or undefined when calling datacentersLansPost.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(lan, "LanPost")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LanPost");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = parseInt(response.headers['retry-after']);
                        }

                        switch (response.statusCode) {
                            case LanApi.BAD_GATEWAY:
                            case LanApi.SERVICE_UNAVAILABLE:
                            case LanApi.GATEWAY_TIMEOUT:
                                backoffTime = LanApi.waitTime;
                                break;
                            case LanApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = parseInt(response.headers['retry-after']);
                                } else {
                                    backoffTime = LanApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: LanPost;  }>(apiCallFunction);
        });
    }
    /**
     * You can use update attributes of a resource
     * @summary Modify a Lan
     * @param datacenterId The unique ID of the datacenter
     * @param lanId The unique ID of the LAN
     * @param lan Modified Lan
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async datacentersLansPut (datacenterId: string, lanId: string, lan: Lan, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Lan;  }> {
        const localVarPath = this.basePath + '/datacenters/{datacenterId}/lans/{lanId}'
            .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
            .replace('{' + 'lanId' + '}', encodeURIComponent(String(lanId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'datacenterId' is not null or undefined
        if (datacenterId === null || datacenterId === undefined) {
            throw new Error('Required parameter datacenterId was null or undefined when calling datacentersLansPut.');
        }

        // verify required parameter 'lanId' is not null or undefined
        if (lanId === null || lanId === undefined) {
            throw new Error('Required parameter lanId was null or undefined when calling datacentersLansPut.');
        }

        // verify required parameter 'lan' is not null or undefined
        if (lan === null || lan === undefined) {
            throw new Error('Required parameter lan was null or undefined when calling datacentersLansPut.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(lan, "Lan")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Lan");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = parseInt(response.headers['retry-after']);
                        }

                        switch (response.statusCode) {
                            case LanApi.BAD_GATEWAY:
                            case LanApi.SERVICE_UNAVAILABLE:
                            case LanApi.GATEWAY_TIMEOUT:
                                backoffTime = LanApi.waitTime;
                                break;
                            case LanApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = parseInt(response.headers['retry-after']);
                                } else {
                                    backoffTime = LanApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Lan;  }>(apiCallFunction);
        });
    }

    public sleep(seconds)
    {
        var e = new Date().getTime() + (seconds * 1000);
        while (new Date().getTime() <= e) {}
    }

    public async waitForCompletion(requestId, timeout=3600, initialWait=5, scaleup=10, maxRetries=10) {
        /**
         Poll resource request status until resource is provisioned.

         :param      requestId: Request id of the action.
         :type       requestId: ``str``

         :param      timeout: Maximum waiting time in seconds. None means infinite waiting time.
         :type       timeout: ``int``

         :param      initialWait: Initial polling interval in seconds.
         :type       initialWait: ``int``

         :param      scaleup: Double polling interval every scaleup steps, which will be doubled.
         :type       scaleup: ``int``

         */

        if (!requestId) {
            throw new Error("Request ID is missing.");
        }

        let waitPeriod = initialWait
        let nextIncrease = Date.now() / 1000 + waitPeriod * scaleup

        timeout = Date.now() / 1000 + timeout

        const requestCall = (new RequestApi(this.username, this.password)).requestsStatusGet(requestId);

        let breakLoop = false;
        while (true) {
            await requestCall.then(
                request => {
                    if (request.body.metadata?.status == RequestStatusMetadata.StatusEnum.Done) {
                        breakLoop = true
                    } else if (request.body.metadata?.status == RequestStatusMetadata.StatusEnum.Failed) {
                        throw new Error(`Request ${requestId} failed to complete: ${request['metadata']['message']}`)
                    }

                }
            )
            if (breakLoop) {
                break
            }

            let currentTime = Date.now() / 1000
            if (timeout && currentTime > timeout) {
                throw new Error(`Timed out waiting for request ${requestId}.`)
            }

            if (currentTime > nextIncrease) {
                waitPeriod *= 2
                nextIncrease = Date.now()/1000 + waitPeriod * scaleup
                scaleup *= 2
            }

            this.sleep(waitPeriod)
        }
    }
}
