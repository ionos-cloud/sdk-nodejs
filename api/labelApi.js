"use strict";
/**
 * CLOUD API
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * The version of the OpenAPI document: 5.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LabelApi = exports.LabelApiApiKeys = void 0;
var request_1 = __importDefault(require("request"));
var models_1 = require("../model/models");
var models_2 = require("../model/models");
var apis_1 = require("./apis");
var defaultBasePath = 'https://api.ionos.com/cloudapi/v5';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var LabelApiApiKeys;
(function (LabelApiApiKeys) {
    LabelApiApiKeys[LabelApiApiKeys["Token Authentication"] = 0] = "Token Authentication";
})(LabelApiApiKeys = exports.LabelApiApiKeys || (exports.LabelApiApiKeys = {}));
var LabelApi = /** @class */ (function () {
    function LabelApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new models_1.VoidAuth(),
            'Basic Authentication': new models_2.HttpBasicAuth(),
            'Token Authentication': new models_2.ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(LabelApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LabelApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LabelApi.prototype, "defaultHeaders", {
        get: function () {
            return this._defaultHeaders;
        },
        set: function (defaultHeaders) {
            this._defaultHeaders = defaultHeaders;
        },
        enumerable: false,
        configurable: true
    });
    LabelApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    LabelApi.prototype.setApiKey = function (key, value) {
        this.authentications[LabelApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(LabelApi.prototype, "username", {
        set: function (username) {
            this.authentications['Basic Authentication'].username = username;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LabelApi.prototype, "password", {
        set: function (password) {
            this.authentications['Basic Authentication'].password = password;
        },
        enumerable: false,
        configurable: true
    });
    LabelApi.prototype.addInterceptor = function (interceptor) {
        this.interceptors.push(interceptor);
    };
    /**
     * This will remove a label from the data center.
     * @summary Delete a Label from Data Center
     * @param datacenterId The unique ID of the Data Center
     * @param key The key of the Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.datacentersLabelsDelete = function (datacenterId, key, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_1, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/labels/{key}'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersLabelsDelete.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling datacentersLabelsDelete.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'DELETE',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_1 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_1(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "object");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will retrieve the properties of a associated label to a data center.
     * @summary Retrieve a Label of Data Center
     * @param datacenterId The unique ID of the Data Center
     * @param key The key of the Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.datacentersLabelsFindByKey = function (datacenterId, key, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_2, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/labels/{key}'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersLabelsFindByKey.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling datacentersLabelsFindByKey.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_2 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_2(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve a list of all labels associated with a data center
     * @summary List all Data Center Labels
     * @param datacenterId The unique ID of the Data Center
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @param offset the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @param limit the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     */
    LabelApi.prototype.datacentersLabelsGet = function (datacenterId, pretty, depth, xContractNumber, offset, limit, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_3, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/labels'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersLabelsGet.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                if (offset !== undefined) {
                    localVarQueryParameters['offset'] = models_1.ObjectSerializer.serialize(offset, "number");
                }
                if (limit !== undefined) {
                    localVarQueryParameters['limit'] = models_1.ObjectSerializer.serialize(limit, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_3 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_3(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResources");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will add a label to the data center.
     * @summary Add a Label to Data Center
     * @param datacenterId The unique ID of the Data Center
     * @param label Label to be added
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.datacentersLabelsPost = function (datacenterId, label, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_4, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/labels'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersLabelsPost.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new Error('Required parameter label was null or undefined when calling datacentersLabelsPost.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(label, "LabelResource")
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_4 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_4(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will modify the value of the label on a data center.
     * @summary Modify a Label of Data Center
     * @param datacenterId The unique ID of the Data Center
     * @param key The key of the Label
     * @param label Modified Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.datacentersLabelsPut = function (datacenterId, key, label, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_5, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/labels/{key}'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersLabelsPut.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling datacentersLabelsPut.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new Error('Required parameter label was null or undefined when calling datacentersLabelsPut.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'PUT',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(label, "LabelResource")
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_5 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_5(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will remove a label from the server.
     * @summary Delete a Label from Server
     * @param datacenterId The unique ID of the Datacenter
     * @param serverId The unique ID of the Server
     * @param key The key of the Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.datacentersServersLabelsDelete = function (datacenterId, serverId, key, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_6, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/labels/{key}'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
                    .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersLabelsDelete.');
                }
                // verify required parameter 'serverId' is not null or undefined
                if (serverId === null || serverId === undefined) {
                    throw new Error('Required parameter serverId was null or undefined when calling datacentersServersLabelsDelete.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling datacentersServersLabelsDelete.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'DELETE',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_6 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_6(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "object");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will retrieve the properties of a associated label to a server.
     * @summary Retrieve a Label of Server
     * @param datacenterId The unique ID of the Datacenter
     * @param serverId The unique ID of the Server
     * @param key The key of the Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.datacentersServersLabelsFindByKey = function (datacenterId, serverId, key, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_7, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/labels/{key}'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
                    .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersLabelsFindByKey.');
                }
                // verify required parameter 'serverId' is not null or undefined
                if (serverId === null || serverId === undefined) {
                    throw new Error('Required parameter serverId was null or undefined when calling datacentersServersLabelsFindByKey.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling datacentersServersLabelsFindByKey.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_7 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_7(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve a list of all labels associated with a server
     * @summary List all Server Labels
     * @param datacenterId The unique ID of the Datacenter
     * @param serverId The unique ID of the Server
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @param offset the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @param limit the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     */
    LabelApi.prototype.datacentersServersLabelsGet = function (datacenterId, serverId, pretty, depth, xContractNumber, offset, limit, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_8, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/labels'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
                    .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersLabelsGet.');
                }
                // verify required parameter 'serverId' is not null or undefined
                if (serverId === null || serverId === undefined) {
                    throw new Error('Required parameter serverId was null or undefined when calling datacentersServersLabelsGet.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                if (offset !== undefined) {
                    localVarQueryParameters['offset'] = models_1.ObjectSerializer.serialize(offset, "number");
                }
                if (limit !== undefined) {
                    localVarQueryParameters['limit'] = models_1.ObjectSerializer.serialize(limit, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_8 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_8(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResources");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will add a label to the server.
     * @summary Add a Label to Server
     * @param datacenterId The unique ID of the Datacenter
     * @param serverId The unique ID of the Server
     * @param label Label to be added
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.datacentersServersLabelsPost = function (datacenterId, serverId, label, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_9, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/labels'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
                    .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersLabelsPost.');
                }
                // verify required parameter 'serverId' is not null or undefined
                if (serverId === null || serverId === undefined) {
                    throw new Error('Required parameter serverId was null or undefined when calling datacentersServersLabelsPost.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new Error('Required parameter label was null or undefined when calling datacentersServersLabelsPost.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(label, "LabelResource")
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_9 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_9(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will modify the value of the label on a server.
     * @summary Modify a Label of Server
     * @param datacenterId The unique ID of the Datacenter
     * @param serverId The unique ID of the Server
     * @param key The key of the Label
     * @param label Modified Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.datacentersServersLabelsPut = function (datacenterId, serverId, key, label, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_10, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/servers/{serverId}/labels/{key}'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
                    .replace('{' + 'serverId' + '}', encodeURIComponent(String(serverId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersServersLabelsPut.');
                }
                // verify required parameter 'serverId' is not null or undefined
                if (serverId === null || serverId === undefined) {
                    throw new Error('Required parameter serverId was null or undefined when calling datacentersServersLabelsPut.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling datacentersServersLabelsPut.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new Error('Required parameter label was null or undefined when calling datacentersServersLabelsPut.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'PUT',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(label, "LabelResource")
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_10 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_10(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will remove a label from the volume.
     * @summary Delete a Label from Volume
     * @param datacenterId The unique ID of the Datacenter
     * @param volumeId The unique ID of the Volume
     * @param key The key of the Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.datacentersVolumesLabelsDelete = function (datacenterId, volumeId, key, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_11, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/volumes/{volumeId}/labels/{key}'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
                    .replace('{' + 'volumeId' + '}', encodeURIComponent(String(volumeId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersVolumesLabelsDelete.');
                }
                // verify required parameter 'volumeId' is not null or undefined
                if (volumeId === null || volumeId === undefined) {
                    throw new Error('Required parameter volumeId was null or undefined when calling datacentersVolumesLabelsDelete.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling datacentersVolumesLabelsDelete.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'DELETE',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_11 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_11(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "object");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will retrieve the properties of a associated label to a volume.
     * @summary Retrieve a Label of Volume
     * @param datacenterId The unique ID of the Datacenter
     * @param volumeId The unique ID of the Volume
     * @param key The key of the Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.datacentersVolumesLabelsFindByKey = function (datacenterId, volumeId, key, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_12, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/volumes/{volumeId}/labels/{key}'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
                    .replace('{' + 'volumeId' + '}', encodeURIComponent(String(volumeId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersVolumesLabelsFindByKey.');
                }
                // verify required parameter 'volumeId' is not null or undefined
                if (volumeId === null || volumeId === undefined) {
                    throw new Error('Required parameter volumeId was null or undefined when calling datacentersVolumesLabelsFindByKey.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling datacentersVolumesLabelsFindByKey.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_12 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_12(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve a list of all labels associated with a volume
     * @summary List all Volume Labels
     * @param datacenterId The unique ID of the Datacenter
     * @param volumeId The unique ID of the Volume
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @param offset the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @param limit the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     */
    LabelApi.prototype.datacentersVolumesLabelsGet = function (datacenterId, volumeId, pretty, depth, xContractNumber, offset, limit, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_13, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/volumes/{volumeId}/labels'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
                    .replace('{' + 'volumeId' + '}', encodeURIComponent(String(volumeId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersVolumesLabelsGet.');
                }
                // verify required parameter 'volumeId' is not null or undefined
                if (volumeId === null || volumeId === undefined) {
                    throw new Error('Required parameter volumeId was null or undefined when calling datacentersVolumesLabelsGet.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                if (offset !== undefined) {
                    localVarQueryParameters['offset'] = models_1.ObjectSerializer.serialize(offset, "number");
                }
                if (limit !== undefined) {
                    localVarQueryParameters['limit'] = models_1.ObjectSerializer.serialize(limit, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_13 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_13(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResources");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will add a label to the volume.
     * @summary Add a Label to Volume
     * @param datacenterId The unique ID of the Datacenter
     * @param volumeId The unique ID of the Volume
     * @param label Label to be added
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.datacentersVolumesLabelsPost = function (datacenterId, volumeId, label, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_14, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/volumes/{volumeId}/labels'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
                    .replace('{' + 'volumeId' + '}', encodeURIComponent(String(volumeId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersVolumesLabelsPost.');
                }
                // verify required parameter 'volumeId' is not null or undefined
                if (volumeId === null || volumeId === undefined) {
                    throw new Error('Required parameter volumeId was null or undefined when calling datacentersVolumesLabelsPost.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new Error('Required parameter label was null or undefined when calling datacentersVolumesLabelsPost.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(label, "LabelResource")
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_14 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_14(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will modify the value of the label on a volume.
     * @summary Modify a Label of Volume
     * @param datacenterId The unique ID of the Datacenter
     * @param volumeId The unique ID of the Volume
     * @param key The key of the Label
     * @param label Modified Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.datacentersVolumesLabelsPut = function (datacenterId, volumeId, key, label, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_15, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/datacenters/{datacenterId}/volumes/{volumeId}/labels/{key}'
                    .replace('{' + 'datacenterId' + '}', encodeURIComponent(String(datacenterId)))
                    .replace('{' + 'volumeId' + '}', encodeURIComponent(String(volumeId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'datacenterId' is not null or undefined
                if (datacenterId === null || datacenterId === undefined) {
                    throw new Error('Required parameter datacenterId was null or undefined when calling datacentersVolumesLabelsPut.');
                }
                // verify required parameter 'volumeId' is not null or undefined
                if (volumeId === null || volumeId === undefined) {
                    throw new Error('Required parameter volumeId was null or undefined when calling datacentersVolumesLabelsPut.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling datacentersVolumesLabelsPut.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new Error('Required parameter label was null or undefined when calling datacentersVolumesLabelsPut.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'PUT',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(label, "LabelResource")
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_15 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_15(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will remove a label from the Ip Block.
     * @summary Delete a Label from IP Block
     * @param ipblockId The unique ID of the Ip Block
     * @param key The key of the Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.ipblocksLabelsDelete = function (ipblockId, key, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_16, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/ipblocks/{ipblockId}/labels/{key}'
                    .replace('{' + 'ipblockId' + '}', encodeURIComponent(String(ipblockId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'ipblockId' is not null or undefined
                if (ipblockId === null || ipblockId === undefined) {
                    throw new Error('Required parameter ipblockId was null or undefined when calling ipblocksLabelsDelete.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling ipblocksLabelsDelete.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'DELETE',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_16 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_16(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "object");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will retrieve the properties of a associated label to a Ip Block.
     * @summary Retrieve a Label of IP Block
     * @param ipblockId The unique ID of the Ip Block
     * @param key The key of the Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.ipblocksLabelsFindByKey = function (ipblockId, key, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_17, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/ipblocks/{ipblockId}/labels/{key}'
                    .replace('{' + 'ipblockId' + '}', encodeURIComponent(String(ipblockId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'ipblockId' is not null or undefined
                if (ipblockId === null || ipblockId === undefined) {
                    throw new Error('Required parameter ipblockId was null or undefined when calling ipblocksLabelsFindByKey.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling ipblocksLabelsFindByKey.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_17 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_17(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve a list of all labels associated with a IP Block
     * @summary List all Ip Block Labels
     * @param ipblockId The unique ID of the Ip Block
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.ipblocksLabelsGet = function (ipblockId, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_18, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/ipblocks/{ipblockId}/labels'
                    .replace('{' + 'ipblockId' + '}', encodeURIComponent(String(ipblockId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'ipblockId' is not null or undefined
                if (ipblockId === null || ipblockId === undefined) {
                    throw new Error('Required parameter ipblockId was null or undefined when calling ipblocksLabelsGet.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_18 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_18(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResources");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will add a label to the Ip Block.
     * @summary Add a Label to IP Block
     * @param ipblockId The unique ID of the Ip Block
     * @param label Label to be added
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.ipblocksLabelsPost = function (ipblockId, label, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_19, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/ipblocks/{ipblockId}/labels'
                    .replace('{' + 'ipblockId' + '}', encodeURIComponent(String(ipblockId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'ipblockId' is not null or undefined
                if (ipblockId === null || ipblockId === undefined) {
                    throw new Error('Required parameter ipblockId was null or undefined when calling ipblocksLabelsPost.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new Error('Required parameter label was null or undefined when calling ipblocksLabelsPost.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(label, "LabelResource")
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_19 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_19(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will modify the value of the label on a Ip Block.
     * @summary Modify a Label of IP Block
     * @param ipblockId The unique ID of the Ip Block
     * @param key The key of the Label
     * @param label Modified Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.ipblocksLabelsPut = function (ipblockId, key, label, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_20, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/ipblocks/{ipblockId}/labels/{key}'
                    .replace('{' + 'ipblockId' + '}', encodeURIComponent(String(ipblockId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'ipblockId' is not null or undefined
                if (ipblockId === null || ipblockId === undefined) {
                    throw new Error('Required parameter ipblockId was null or undefined when calling ipblocksLabelsPut.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling ipblocksLabelsPut.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new Error('Required parameter label was null or undefined when calling ipblocksLabelsPut.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'PUT',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(label, "LabelResource")
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_20 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_20(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve the details of a specific label using its URN. A URN is for uniqueness of a Label and composed using urn:label:<resource_type>:<resource_uuid>:<key>
     * @summary Returns the label by its URN.
     * @param labelurn The URN representing the unique ID of the label. A URN is for uniqueness of a Label and composed using urn:label:&lt;resource_type&gt;:&lt;resource_uuid&gt;:&lt;key&gt;
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.labelsFindByUrn = function (labelurn, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_21, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/labels/{labelurn}'
                    .replace('{' + 'labelurn' + '}', encodeURIComponent(String(labelurn)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'labelurn' is not null or undefined
                if (labelurn === null || labelurn === undefined) {
                    throw new Error('Required parameter labelurn was null or undefined when calling labelsFindByUrn.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_21 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_21(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "Label");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve a complete list of labels that you have access to.
     * @summary List Labels
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.labelsGet = function (pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_22, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/labels';
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_22 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_22(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "Labels");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will remove a label from the snapshot.
     * @summary Delete a Label from Snapshot
     * @param snapshotId The unique ID of the Snapshot
     * @param key The key of the Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.snapshotsLabelsDelete = function (snapshotId, key, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_23, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/snapshots/{snapshotId}/labels/{key}'
                    .replace('{' + 'snapshotId' + '}', encodeURIComponent(String(snapshotId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'snapshotId' is not null or undefined
                if (snapshotId === null || snapshotId === undefined) {
                    throw new Error('Required parameter snapshotId was null or undefined when calling snapshotsLabelsDelete.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling snapshotsLabelsDelete.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'DELETE',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_23 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_23(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "object");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will retrieve the properties of a associated label to a snapshot.
     * @summary Retrieve a Label of Snapshot
     * @param snapshotId The unique ID of the Snapshot
     * @param key The key of the Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.snapshotsLabelsFindByKey = function (snapshotId, key, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_24, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/snapshots/{snapshotId}/labels/{key}'
                    .replace('{' + 'snapshotId' + '}', encodeURIComponent(String(snapshotId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'snapshotId' is not null or undefined
                if (snapshotId === null || snapshotId === undefined) {
                    throw new Error('Required parameter snapshotId was null or undefined when calling snapshotsLabelsFindByKey.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling snapshotsLabelsFindByKey.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_24 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_24(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve a list of all labels associated with a snapshot
     * @summary List all Snapshot Labels
     * @param snapshotId The unique ID of the Snapshot
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.snapshotsLabelsGet = function (snapshotId, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_25, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/snapshots/{snapshotId}/labels'
                    .replace('{' + 'snapshotId' + '}', encodeURIComponent(String(snapshotId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'snapshotId' is not null or undefined
                if (snapshotId === null || snapshotId === undefined) {
                    throw new Error('Required parameter snapshotId was null or undefined when calling snapshotsLabelsGet.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_25 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_25(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResources");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will add a label to the snapshot.
     * @summary Add a Label to Snapshot
     * @param snapshotId The unique ID of the Snapshot
     * @param label Label to be added
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.snapshotsLabelsPost = function (snapshotId, label, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_26, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/snapshots/{snapshotId}/labels'
                    .replace('{' + 'snapshotId' + '}', encodeURIComponent(String(snapshotId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'snapshotId' is not null or undefined
                if (snapshotId === null || snapshotId === undefined) {
                    throw new Error('Required parameter snapshotId was null or undefined when calling snapshotsLabelsPost.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new Error('Required parameter label was null or undefined when calling snapshotsLabelsPost.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(label, "LabelResource")
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_26 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_26(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will modify the value of the label on a snapshot.
     * @summary Modify a Label of Snapshot
     * @param snapshotId The unique ID of the Snapshot
     * @param key The key of the Label
     * @param label Modified Label
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    LabelApi.prototype.snapshotsLabelsPut = function (snapshotId, key, label, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_27, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/snapshots/{snapshotId}/labels/{key}'
                    .replace('{' + 'snapshotId' + '}', encodeURIComponent(String(snapshotId)))
                    .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'snapshotId' is not null or undefined
                if (snapshotId === null || snapshotId === undefined) {
                    throw new Error('Required parameter snapshotId was null or undefined when calling snapshotsLabelsPut.');
                }
                // verify required parameter 'key' is not null or undefined
                if (key === null || key === undefined) {
                    throw new Error('Required parameter key was null or undefined when calling snapshotsLabelsPut.');
                }
                // verify required parameter 'label' is not null or undefined
                if (label === null || label === undefined) {
                    throw new Error('Required parameter label was null or undefined when calling snapshotsLabelsPut.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'PUT',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(label, "LabelResource")
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_27 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_27(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "LabelResource");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case LabelApi.BAD_GATEWAY:
                                    case LabelApi.SERVICE_UNAVAILABLE:
                                    case LabelApi.GATEWAY_TIMEOUT:
                                        backoffTime = LabelApi.waitTime;
                                        break;
                                    case LabelApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = LabelApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    LabelApi.prototype.sleep = function (seconds) {
        var e = new Date().getTime() + (seconds * 1000);
        while (new Date().getTime() <= e) { }
    };
    LabelApi.prototype.waitForCompletion = function (requestId, timeout, initialWait, scaleup, maxRetries) {
        if (timeout === void 0) { timeout = 3600; }
        if (initialWait === void 0) { initialWait = 5; }
        if (scaleup === void 0) { scaleup = 10; }
        if (maxRetries === void 0) { maxRetries = 10; }
        return __awaiter(this, void 0, void 0, function () {
            var waitPeriod, nextIncrease, requestCall, breakLoop, currentTime;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        /**
                         Poll resource request status until resource is provisioned.
                
                         :param      requestId: Request id of the action.
                         :type       requestId: ``str``
                
                         :param      timeout: Maximum waiting time in seconds. None means infinite waiting time.
                         :type       timeout: ``int``
                
                         :param      initialWait: Initial polling interval in seconds.
                         :type       initialWait: ``int``
                
                         :param      scaleup: Double polling interval every scaleup steps, which will be doubled.
                         :type       scaleup: ``int``
                
                         */
                        if (!requestId) {
                            throw new Error("Request ID is missing.");
                        }
                        waitPeriod = initialWait;
                        nextIncrease = Date.now() / 1000 + waitPeriod * scaleup;
                        timeout = Date.now() / 1000 + timeout;
                        requestCall = (new apis_1.RequestApi(this.username, this.password)).requestsStatusGet(requestId);
                        breakLoop = false;
                        _a.label = 1;
                    case 1:
                        if (!true) return [3 /*break*/, 3];
                        return [4 /*yield*/, requestCall.then(function (request) {
                                var _a, _b;
                                if (((_a = request.body.metadata) === null || _a === void 0 ? void 0 : _a.status) == models_1.RequestStatusMetadata.StatusEnum.Done) {
                                    breakLoop = true;
                                }
                                else if (((_b = request.body.metadata) === null || _b === void 0 ? void 0 : _b.status) == models_1.RequestStatusMetadata.StatusEnum.Failed) {
                                    throw new Error("Request " + requestId + " failed to complete: " + request['metadata']['message']);
                                }
                            })];
                    case 2:
                        _a.sent();
                        if (breakLoop) {
                            return [3 /*break*/, 3];
                        }
                        currentTime = Date.now() / 1000;
                        if (timeout && currentTime > timeout) {
                            throw new Error("Timed out waiting for request " + requestId + ".");
                        }
                        if (currentTime > nextIncrease) {
                            waitPeriod *= 2;
                            nextIncrease = Date.now() / 1000 + waitPeriod * scaleup;
                            scaleup *= 2;
                        }
                        this.sleep(waitPeriod);
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    LabelApi.BAD_GATEWAY = 502;
    LabelApi.SERVICE_UNAVAILABLE = 503;
    LabelApi.GATEWAY_TIMEOUT = 504;
    LabelApi.TOO_MANY_REQUESTS = 429;
    LabelApi.maxRetries = 3;
    LabelApi.waitTime = 10;
    LabelApi.maxWaitTime = 2000;
    return LabelApi;
}());
exports.LabelApi = LabelApi;
