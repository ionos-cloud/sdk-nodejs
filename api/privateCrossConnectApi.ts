/**
 * CLOUD API
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * The version of the OpenAPI document: 5.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { PrivateCrossConnect } from '../model/privateCrossConnect';
import { PrivateCrossConnectProperties } from '../model/privateCrossConnectProperties';
import { PrivateCrossConnects } from '../model/privateCrossConnects';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor, RequestStatusMetadata } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile, RequestApi } from './apis';

let defaultBasePath = 'https://api.ionos.com/cloudapi/v5';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum PrivateCrossConnectApiApiKeys {
        'Token Authentication'
}

export class PrivateCrossConnectApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    static BAD_GATEWAY = 502;
    static SERVICE_UNAVAILABLE = 503;
    static GATEWAY_TIMEOUT = 504;
    static TOO_MANY_REQUESTS = 429;

    static maxRetries = 3;
    static waitTime = 10;
    static maxWaitTime = 2000;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Basic Authentication': new HttpBasicAuth(),
        'Token Authentication': new ApiKeyAuth('header', 'Authorization'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: PrivateCrossConnectApiApiKeys, value: string) {
        (this.authentications as any)[PrivateCrossConnectApiApiKeys[key]].apiKey = value;
    }

    set username(username: string) {
        this.authentications['Basic Authentication'].username = username;
    }

    set password(password: string) {
        this.authentications['Basic Authentication'].password = password;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Delete a private cross-connect if no datacenters are joined to the given PCC
     * @summary Delete a Private Cross-Connect
     * @param pccId The unique ID of the private cross-connect
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async pccsDelete (pccId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/pccs/{pccId}'
            .replace('{' + 'pccId' + '}', encodeURIComponent(String(pccId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'pccId' is not null or undefined
        if (pccId === null || pccId === undefined) {
            throw new Error('Required parameter pccId was null or undefined when calling pccsDelete.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "object");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = parseInt(response.headers['retry-after']);
                        }

                        switch (response.statusCode) {
                            case PrivateCrossConnectApi.BAD_GATEWAY:
                            case PrivateCrossConnectApi.SERVICE_UNAVAILABLE:
                            case PrivateCrossConnectApi.GATEWAY_TIMEOUT:
                                backoffTime = PrivateCrossConnectApi.waitTime;
                                break;
                            case PrivateCrossConnectApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = parseInt(response.headers['retry-after']);
                                } else {
                                    backoffTime = PrivateCrossConnectApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>(apiCallFunction);
        });
    }
    /**
     * You can retrieve a private cross-connect by using the resource\'s ID. This value can be found in the response body when a private cross-connect is created or when you GET a list of private cross-connects.
     * @summary Retrieve a Private Cross-Connect
     * @param pccId The unique ID of the private cross-connect
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async pccsFindById (pccId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PrivateCrossConnect;  }> {
        const localVarPath = this.basePath + '/pccs/{pccId}'
            .replace('{' + 'pccId' + '}', encodeURIComponent(String(pccId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'pccId' is not null or undefined
        if (pccId === null || pccId === undefined) {
            throw new Error('Required parameter pccId was null or undefined when calling pccsFindById.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PrivateCrossConnect");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = parseInt(response.headers['retry-after']);
                        }

                        switch (response.statusCode) {
                            case PrivateCrossConnectApi.BAD_GATEWAY:
                            case PrivateCrossConnectApi.SERVICE_UNAVAILABLE:
                            case PrivateCrossConnectApi.GATEWAY_TIMEOUT:
                                backoffTime = PrivateCrossConnectApi.waitTime;
                                break;
                            case PrivateCrossConnectApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = parseInt(response.headers['retry-after']);
                                } else {
                                    backoffTime = PrivateCrossConnectApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PrivateCrossConnect;  }>(apiCallFunction);
        });
    }
    /**
     * You can retrieve a complete list of private cross-connects provisioned under your account
     * @summary List Private Cross-Connects 
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async pccsGet (pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PrivateCrossConnects;  }> {
        const localVarPath = this.basePath + '/pccs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PrivateCrossConnects");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = parseInt(response.headers['retry-after']);
                        }

                        switch (response.statusCode) {
                            case PrivateCrossConnectApi.BAD_GATEWAY:
                            case PrivateCrossConnectApi.SERVICE_UNAVAILABLE:
                            case PrivateCrossConnectApi.GATEWAY_TIMEOUT:
                                backoffTime = PrivateCrossConnectApi.waitTime;
                                break;
                            case PrivateCrossConnectApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = parseInt(response.headers['retry-after']);
                                } else {
                                    backoffTime = PrivateCrossConnectApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PrivateCrossConnects;  }>(apiCallFunction);
        });
    }
    /**
     * You can use update private cross-connect to re-name or update its description
     * @summary Partially modify a private cross-connect
     * @param pccId The unique ID of the private cross-connect
     * @param pcc Modified properties of private cross-connect
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async pccsPatch (pccId: string, pcc: PrivateCrossConnectProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PrivateCrossConnect;  }> {
        const localVarPath = this.basePath + '/pccs/{pccId}'
            .replace('{' + 'pccId' + '}', encodeURIComponent(String(pccId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'pccId' is not null or undefined
        if (pccId === null || pccId === undefined) {
            throw new Error('Required parameter pccId was null or undefined when calling pccsPatch.');
        }

        // verify required parameter 'pcc' is not null or undefined
        if (pcc === null || pcc === undefined) {
            throw new Error('Required parameter pcc was null or undefined when calling pccsPatch.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(pcc, "PrivateCrossConnectProperties")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PrivateCrossConnect");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = parseInt(response.headers['retry-after']);
                        }

                        switch (response.statusCode) {
                            case PrivateCrossConnectApi.BAD_GATEWAY:
                            case PrivateCrossConnectApi.SERVICE_UNAVAILABLE:
                            case PrivateCrossConnectApi.GATEWAY_TIMEOUT:
                                backoffTime = PrivateCrossConnectApi.waitTime;
                                break;
                            case PrivateCrossConnectApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = parseInt(response.headers['retry-after']);
                                } else {
                                    backoffTime = PrivateCrossConnectApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PrivateCrossConnect;  }>(apiCallFunction);
        });
    }
    /**
     * You can use this POST method to create a private cross-connect
     * @summary Create a Private Cross-Connect
     * @param pcc Private Cross-Connect to be created
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    public async pccsPost (pcc: PrivateCrossConnect, pretty?: boolean, depth?: number, xContractNumber?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PrivateCrossConnect;  }> {
        const localVarPath = this.basePath + '/pccs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'pcc' is not null or undefined
        if (pcc === null || pcc === undefined) {
            throw new Error('Required parameter pcc was null or undefined when calling pccsPost.');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, "boolean");
        }

        if (depth !== undefined) {
            localVarQueryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }

        localVarHeaderParams['X-Contract-Number'] = ObjectSerializer.serialize(xContractNumber, "number");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(pcc, "PrivateCrossConnect")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications['Token Authentication'].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        const apiCallFunction = (resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PrivateCrossConnect");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        let backoffTime = 0;
                        if (response.headers['retry-after'] != null) {
                            backoffTime = parseInt(response.headers['retry-after']);
                        }

                        switch (response.statusCode) {
                            case PrivateCrossConnectApi.BAD_GATEWAY:
                            case PrivateCrossConnectApi.SERVICE_UNAVAILABLE:
                            case PrivateCrossConnectApi.GATEWAY_TIMEOUT:
                                backoffTime = PrivateCrossConnectApi.waitTime;
                                break;
                            case PrivateCrossConnectApi.TOO_MANY_REQUESTS:
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = parseInt(response.headers['retry-after']);
                                } else {
                                    backoffTime = PrivateCrossConnectApi.waitTime;
                                }
                                break;
                            default:
                                reject(new HttpError(response, body, response.statusCode));
                        }

                        setTimeout(() => apiCallFunction(resolve, reject), backoffTime * 1000)
                    }
                }
            });
        };

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PrivateCrossConnect;  }>(apiCallFunction);
        });
    }

    public sleep(seconds)
    {
        var e = new Date().getTime() + (seconds * 1000);
        while (new Date().getTime() <= e) {}
    }

    public async waitForCompletion(requestId, timeout=3600, initialWait=5, scaleup=10, maxRetries=10) {
        /**
         Poll resource request status until resource is provisioned.

         :param      requestId: Request id of the action.
         :type       requestId: ``str``

         :param      timeout: Maximum waiting time in seconds. None means infinite waiting time.
         :type       timeout: ``int``

         :param      initialWait: Initial polling interval in seconds.
         :type       initialWait: ``int``

         :param      scaleup: Double polling interval every scaleup steps, which will be doubled.
         :type       scaleup: ``int``

         */

        if (!requestId) {
            throw new Error("Request ID is missing.");
        }

        let waitPeriod = initialWait
        let nextIncrease = Date.now() / 1000 + waitPeriod * scaleup

        timeout = Date.now() / 1000 + timeout

        const requestCall = (new RequestApi(this.username, this.password)).requestsStatusGet(requestId);

        let breakLoop = false;
        while (true) {
            await requestCall.then(
                request => {
                    if (request.body.metadata?.status == RequestStatusMetadata.StatusEnum.Done) {
                        breakLoop = true
                    } else if (request.body.metadata?.status == RequestStatusMetadata.StatusEnum.Failed) {
                        throw new Error(`Request ${requestId} failed to complete: ${request['metadata']['message']}`)
                    }

                }
            )
            if (breakLoop) {
                break
            }

            let currentTime = Date.now() / 1000
            if (timeout && currentTime > timeout) {
                throw new Error(`Timed out waiting for request ${requestId}.`)
            }

            if (currentTime > nextIncrease) {
                waitPeriod *= 2
                nextIncrease = Date.now()/1000 + waitPeriod * scaleup
                scaleup *= 2
            }

            this.sleep(waitPeriod)
        }
    }
}
