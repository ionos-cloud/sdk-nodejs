/* tslint:disable */
/* eslint-disable */
/**
 * CLOUD API
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * The version of the OpenAPI document: 5.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration, DEFAULT_MAX_RETRIES, DEFAULT_MAX_WAIT_TIME } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, backOff, runRequest } from '../base';
// @ts-ignore
import { AttachedVolumes } from '../model';
// @ts-ignore
import { Cdroms } from '../model';
// @ts-ignore
import { Image } from '../model';
// @ts-ignore
import { Server } from '../model';
// @ts-ignore
import { ServerProperties } from '../model';
// @ts-ignore
import { Servers } from '../model';
// @ts-ignore
import { Volume } from '../model';
/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will detach a CD-ROM from the server
         * @summary Detach a CD-ROM
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} cdromId The unique ID of the CD-ROM
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsDelete: async (datacenterId: string, serverId: string, cdromId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersCdromsDelete.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersCdromsDelete.');
            }
            // verify required parameter 'cdromId' is not null or undefined
            if (cdromId === null || cdromId === undefined) {
                throw new RequiredError('cdromId','Required parameter cdromId was null or undefined when calling datacentersServersCdromsDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/cdroms/{cdromId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"cdromId"}}`, encodeURIComponent(String(cdromId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a specific CD-ROM attached to the server
         * @summary Retrieve an attached CD-ROM
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} cdromId The unique ID of the CD-ROM
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsFindById: async (datacenterId: string, serverId: string, cdromId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersCdromsFindById.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersCdromsFindById.');
            }
            // verify required parameter 'cdromId' is not null or undefined
            if (cdromId === null || cdromId === undefined) {
                throw new RequiredError('cdromId','Required parameter cdromId was null or undefined when calling datacentersServersCdromsFindById.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/cdroms/{cdromId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"cdromId"}}`, encodeURIComponent(String(cdromId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a list of CD-ROMs attached to the server.
         * @summary List attached CD-ROMs 
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsGet: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersCdromsGet.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersCdromsGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/cdroms`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can attach a CD-ROM to an existing server. You can attach up to 2 CD-ROMs to one server. 
         * @summary Attach a CD-ROM
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {Image} cdrom CD-ROM to be attached
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsPost: async (datacenterId: string, serverId: string, cdrom: Image, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersCdromsPost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersCdromsPost.');
            }
            // verify required parameter 'cdrom' is not null or undefined
            if (cdrom === null || cdrom === undefined) {
                throw new RequiredError('cdrom','Required parameter cdrom was null or undefined when calling datacentersServersCdromsPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/cdroms`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof cdrom !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(cdrom !== undefined ? cdrom : {})
                : (cdrom || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will remove a server from your datacenter; however, it will not remove the storage volumes attached to the server. You will need to make a separate API call to perform that action
         * @summary Delete a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersDelete: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersDelete.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about a server such as its configuration, provisioning status, etc.
         * @summary Retrieve a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersFindById: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersFindById.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersFindById.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a list of servers within a datacenter
         * @summary List Servers 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {boolean} [upgradeNeeded] It can be used to filter which servers can be upgraded which can not be upgraded.
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersGet: async (datacenterId: string, pretty?: boolean, depth?: number, upgradeNeeded?: boolean, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((upgradeNeeded === undefined) && (configuration !== undefined)) {
                upgradeNeeded = configuration.getDefaultParamValue('upgradeNeeded');
            }
            if (upgradeNeeded !== undefined) {
                localVarQueryParameter['upgradeNeeded'] = upgradeNeeded;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use update attributes of a server
         * @summary Partially modify a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the server
         * @param {ServerProperties} server Modified properties of Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersPatch: async (datacenterId: string, serverId: string, server: ServerProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersPatch.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersPatch.');
            }
            // verify required parameter 'server' is not null or undefined
            if (server === null || server === undefined) {
                throw new RequiredError('server','Required parameter server was null or undefined when calling datacentersServersPatch.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof server !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(server !== undefined ? server : {})
                : (server || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a server within an existing datacenter. You can configure the boot volume and connect the server to an existing LAN.
         * @summary Create a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {Server} server Server to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersPost: async (datacenterId: string, server: Server, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersPost.');
            }
            // verify required parameter 'server' is not null or undefined
            if (server === null || server === undefined) {
                throw new RequiredError('server','Required parameter server was null or undefined when calling datacentersServersPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof server !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(server !== undefined ? server : {})
                : (server || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows to modify the attributes of a Server. From v5 onwards \'allowReboot\' attribute will no longer be available. For certain server property change it was earlier forced to be provided. Now this behaviour is implicit and backend will do this automatically e.g. in earlier versions, when CPU family changes, the \'allowReboot\' property was required to be set to true which will no longer be the case and the server will be rebooted automatically
         * @summary Modify a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the server
         * @param {Server} server Modified Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersPut: async (datacenterId: string, serverId: string, server: Server, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersPut.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersPut.');
            }
            // verify required parameter 'server' is not null or undefined
            if (server === null || server === undefined) {
                throw new RequiredError('server','Required parameter server was null or undefined when calling datacentersServersPut.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof server !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(server !== undefined ? server : {})
                : (server || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will force a hard reboot of the server. Do not use this method if you want to gracefully reboot the machine. This is the equivalent of powering off the machine and turning it back on.
         * @summary Reboot a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersRebootPost: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersRebootPost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersRebootPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/reboot`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will start a server. If the server\'s public IP was deallocated then a new IP will be assigned
         * @summary Start a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersStartPost: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersStartPost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersStartPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/start`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will stop a server. The machine will be forcefully powered off, billing will cease, and the public IP, if one is allocated, will be deallocated. The operation is not supported for Cube servers.
         * @summary Stop a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersStopPost: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersStopPost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersStopPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/stop`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will upgrade the version of the server, if needed. To verify if there is an upgrade available for a server, call \'/datacenters/{datacenterId}/servers?upgradeNeeded=true\'
         * @summary Upgrade a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersUpgradePost: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersUpgradePost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersUpgradePost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/upgrade`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will detach the volume from the server. This will not delete the volume from your datacenter. You will need to make a separate request to perform a deletion
         * @summary Detach a volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} volumeId The unique ID of the Volume
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesDelete: async (datacenterId: string, serverId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersVolumesDelete.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersVolumesDelete.');
            }
            // verify required parameter 'volumeId' is not null or undefined
            if (volumeId === null || volumeId === undefined) {
                throw new RequiredError('volumeId','Required parameter volumeId was null or undefined when calling datacentersServersVolumesDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/volumes/{volumeId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"volumeId"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will retrieve the properties of an attached volume.
         * @summary Retrieve an attached volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} volumeId The unique ID of the Volume
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesFindById: async (datacenterId: string, serverId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersVolumesFindById.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersVolumesFindById.');
            }
            // verify required parameter 'volumeId' is not null or undefined
            if (volumeId === null || volumeId === undefined) {
                throw new RequiredError('volumeId','Required parameter volumeId was null or undefined when calling datacentersServersVolumesFindById.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/volumes/{volumeId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"volumeId"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a list of volumes attached to the server
         * @summary List Attached Volumes
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesGet: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersVolumesGet.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersVolumesGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/volumes`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will attach a pre-existing storage volume to the server. It is also possible to create and attach a volume in one step just by providing a new volume description as payload. Combine count of Nics and volumes attached to the server should not exceed size 24.
         * @summary Attach a volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {Volume} volume Volume to be attached (created and attached)
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesPost: async (datacenterId: string, serverId: string, volume: Volume, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersVolumesPost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersVolumesPost.');
            }
            // verify required parameter 'volume' is not null or undefined
            if (volume === null || volume === undefined) {
                throw new RequiredError('volume','Required parameter volume was null or undefined when calling datacentersServersVolumesPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/volumes`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof volume !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(volume !== undefined ? volume : {})
                : (volume || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This will detach a CD-ROM from the server
         * @summary Detach a CD-ROM
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} cdromId The unique ID of the CD-ROM
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersCdromsDelete(datacenterId: string, serverId: string, cdromId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersCdromsDelete(datacenterId, serverId, cdromId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a specific CD-ROM attached to the server
         * @summary Retrieve an attached CD-ROM
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} cdromId The unique ID of the CD-ROM
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersCdromsFindById(datacenterId: string, serverId: string, cdromId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersCdromsFindById(datacenterId, serverId, cdromId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a list of CD-ROMs attached to the server.
         * @summary List attached CD-ROMs 
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersCdromsGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cdroms>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersCdromsGet(datacenterId, serverId, pretty, depth, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can attach a CD-ROM to an existing server. You can attach up to 2 CD-ROMs to one server. 
         * @summary Attach a CD-ROM
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {Image} cdrom CD-ROM to be attached
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersCdromsPost(datacenterId: string, serverId: string, cdrom: Image, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersCdromsPost(datacenterId, serverId, cdrom, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will remove a server from your datacenter; however, it will not remove the storage volumes attached to the server. You will need to make a separate API call to perform that action
         * @summary Delete a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersDelete(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersDelete(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Returns information about a server such as its configuration, provisioning status, etc.
         * @summary Retrieve a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersFindById(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Server>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersFindById(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a list of servers within a datacenter
         * @summary List Servers 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {boolean} [upgradeNeeded] It can be used to filter which servers can be upgraded which can not be upgraded.
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersGet(datacenterId: string, pretty?: boolean, depth?: number, upgradeNeeded?: boolean, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Servers>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersGet(datacenterId, pretty, depth, upgradeNeeded, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can use update attributes of a server
         * @summary Partially modify a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the server
         * @param {ServerProperties} server Modified properties of Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersPatch(datacenterId: string, serverId: string, server: ServerProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Server>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersPatch(datacenterId, serverId, server, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Creates a server within an existing datacenter. You can configure the boot volume and connect the server to an existing LAN.
         * @summary Create a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {Server} server Server to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersPost(datacenterId: string, server: Server, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Server>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersPost(datacenterId, server, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Allows to modify the attributes of a Server. From v5 onwards \'allowReboot\' attribute will no longer be available. For certain server property change it was earlier forced to be provided. Now this behaviour is implicit and backend will do this automatically e.g. in earlier versions, when CPU family changes, the \'allowReboot\' property was required to be set to true which will no longer be the case and the server will be rebooted automatically
         * @summary Modify a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the server
         * @param {Server} server Modified Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersPut(datacenterId: string, serverId: string, server: Server, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Server>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersPut(datacenterId, serverId, server, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will force a hard reboot of the server. Do not use this method if you want to gracefully reboot the machine. This is the equivalent of powering off the machine and turning it back on.
         * @summary Reboot a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersRebootPost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersRebootPost(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will start a server. If the server\'s public IP was deallocated then a new IP will be assigned
         * @summary Start a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersStartPost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersStartPost(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will stop a server. The machine will be forcefully powered off, billing will cease, and the public IP, if one is allocated, will be deallocated. The operation is not supported for Cube servers.
         * @summary Stop a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersStopPost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersStopPost(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will upgrade the version of the server, if needed. To verify if there is an upgrade available for a server, call \'/datacenters/{datacenterId}/servers?upgradeNeeded=true\'
         * @summary Upgrade a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersUpgradePost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersUpgradePost(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will detach the volume from the server. This will not delete the volume from your datacenter. You will need to make a separate request to perform a deletion
         * @summary Detach a volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} volumeId The unique ID of the Volume
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersVolumesDelete(datacenterId: string, serverId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersVolumesDelete(datacenterId, serverId, volumeId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will retrieve the properties of an attached volume.
         * @summary Retrieve an attached volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} volumeId The unique ID of the Volume
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersVolumesFindById(datacenterId: string, serverId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersVolumesFindById(datacenterId, serverId, volumeId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a list of volumes attached to the server
         * @summary List Attached Volumes
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersVolumesGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachedVolumes>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersVolumesGet(datacenterId, serverId, pretty, depth, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will attach a pre-existing storage volume to the server. It is also possible to create and attach a volume in one step just by providing a new volume description as payload. Combine count of Nics and volumes attached to the server should not exceed size 24.
         * @summary Attach a volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {Volume} volume Volume to be attached (created and attached)
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersVolumesPost(datacenterId: string, serverId: string, volume: Volume, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
            const axiosArgs = await ServerApiAxiosParamCreator(configuration).datacentersServersVolumesPost(datacenterId, serverId, volume, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
    }
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This will detach a CD-ROM from the server
         * @summary Detach a CD-ROM
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} cdromId The unique ID of the CD-ROM
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsDelete(datacenterId: string, serverId: string, cdromId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return ServerApiFp(configuration).datacentersServersCdromsDelete(datacenterId, serverId, cdromId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a specific CD-ROM attached to the server
         * @summary Retrieve an attached CD-ROM
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} cdromId The unique ID of the CD-ROM
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsFindById(datacenterId: string, serverId: string, cdromId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Image> {
            return ServerApiFp(configuration).datacentersServersCdromsFindById(datacenterId, serverId, cdromId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a list of CD-ROMs attached to the server.
         * @summary List attached CD-ROMs 
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<Cdroms> {
            return ServerApiFp(configuration).datacentersServersCdromsGet(datacenterId, serverId, pretty, depth, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * You can attach a CD-ROM to an existing server. You can attach up to 2 CD-ROMs to one server. 
         * @summary Attach a CD-ROM
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {Image} cdrom CD-ROM to be attached
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsPost(datacenterId: string, serverId: string, cdrom: Image, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Image> {
            return ServerApiFp(configuration).datacentersServersCdromsPost(datacenterId, serverId, cdrom, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will remove a server from your datacenter; however, it will not remove the storage volumes attached to the server. You will need to make a separate API call to perform that action
         * @summary Delete a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersDelete(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return ServerApiFp(configuration).datacentersServersDelete(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about a server such as its configuration, provisioning status, etc.
         * @summary Retrieve a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersFindById(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Server> {
            return ServerApiFp(configuration).datacentersServersFindById(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a list of servers within a datacenter
         * @summary List Servers 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {boolean} [upgradeNeeded] It can be used to filter which servers can be upgraded which can not be upgraded.
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersGet(datacenterId: string, pretty?: boolean, depth?: number, upgradeNeeded?: boolean, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<Servers> {
            return ServerApiFp(configuration).datacentersServersGet(datacenterId, pretty, depth, upgradeNeeded, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use update attributes of a server
         * @summary Partially modify a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the server
         * @param {ServerProperties} server Modified properties of Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersPatch(datacenterId: string, serverId: string, server: ServerProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Server> {
            return ServerApiFp(configuration).datacentersServersPatch(datacenterId, serverId, server, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a server within an existing datacenter. You can configure the boot volume and connect the server to an existing LAN.
         * @summary Create a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {Server} server Server to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersPost(datacenterId: string, server: Server, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Server> {
            return ServerApiFp(configuration).datacentersServersPost(datacenterId, server, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows to modify the attributes of a Server. From v5 onwards \'allowReboot\' attribute will no longer be available. For certain server property change it was earlier forced to be provided. Now this behaviour is implicit and backend will do this automatically e.g. in earlier versions, when CPU family changes, the \'allowReboot\' property was required to be set to true which will no longer be the case and the server will be rebooted automatically
         * @summary Modify a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the server
         * @param {Server} server Modified Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersPut(datacenterId: string, serverId: string, server: Server, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Server> {
            return ServerApiFp(configuration).datacentersServersPut(datacenterId, serverId, server, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will force a hard reboot of the server. Do not use this method if you want to gracefully reboot the machine. This is the equivalent of powering off the machine and turning it back on.
         * @summary Reboot a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersRebootPost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return ServerApiFp(configuration).datacentersServersRebootPost(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will start a server. If the server\'s public IP was deallocated then a new IP will be assigned
         * @summary Start a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersStartPost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return ServerApiFp(configuration).datacentersServersStartPost(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will stop a server. The machine will be forcefully powered off, billing will cease, and the public IP, if one is allocated, will be deallocated. The operation is not supported for Cube servers.
         * @summary Stop a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersStopPost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return ServerApiFp(configuration).datacentersServersStopPost(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will upgrade the version of the server, if needed. To verify if there is an upgrade available for a server, call \'/datacenters/{datacenterId}/servers?upgradeNeeded=true\'
         * @summary Upgrade a Server
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersUpgradePost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return ServerApiFp(configuration).datacentersServersUpgradePost(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will detach the volume from the server. This will not delete the volume from your datacenter. You will need to make a separate request to perform a deletion
         * @summary Detach a volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} volumeId The unique ID of the Volume
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesDelete(datacenterId: string, serverId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return ServerApiFp(configuration).datacentersServersVolumesDelete(datacenterId, serverId, volumeId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will retrieve the properties of an attached volume.
         * @summary Retrieve an attached volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} volumeId The unique ID of the Volume
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesFindById(datacenterId: string, serverId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Volume> {
            return ServerApiFp(configuration).datacentersServersVolumesFindById(datacenterId, serverId, volumeId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a list of volumes attached to the server
         * @summary List Attached Volumes
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<AttachedVolumes> {
            return ServerApiFp(configuration).datacentersServersVolumesGet(datacenterId, serverId, pretty, depth, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * This will attach a pre-existing storage volume to the server. It is also possible to create and attach a volume in one step just by providing a new volume description as payload. Combine count of Nics and volumes attached to the server should not exceed size 24.
         * @summary Attach a volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {Volume} volume Volume to be attached (created and attached)
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesPost(datacenterId: string, serverId: string, volume: Volume, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Volume> {
            return ServerApiFp(configuration).datacentersServersVolumesPost(datacenterId, serverId, volume, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for datacentersServersCdromsDelete operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersCdromsDeleteRequest
 */
export interface ServerApiDatacentersServersCdromsDeleteRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersCdromsDelete
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof ServerApiDatacentersServersCdromsDelete
     */
    readonly serverId: string

    /**
     * The unique ID of the CD-ROM
     * @type {string}
     * @memberof ServerApiDatacentersServersCdromsDelete
     */
    readonly cdromId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersCdromsDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersCdromsDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersCdromsDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersCdromsFindById operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersCdromsFindByIdRequest
 */
export interface ServerApiDatacentersServersCdromsFindByIdRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersCdromsFindById
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof ServerApiDatacentersServersCdromsFindById
     */
    readonly serverId: string

    /**
     * The unique ID of the CD-ROM
     * @type {string}
     * @memberof ServerApiDatacentersServersCdromsFindById
     */
    readonly cdromId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersCdromsFindById
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersCdromsFindById
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersCdromsFindById
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersCdromsGet operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersCdromsGetRequest
 */
export interface ServerApiDatacentersServersCdromsGetRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersCdromsGet
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof ServerApiDatacentersServersCdromsGet
     */
    readonly serverId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersCdromsGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersCdromsGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersCdromsGet
     */
    readonly xContractNumber?: number

    /**
     * the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof ServerApiDatacentersServersCdromsGet
     */
    readonly offset?: number

    /**
     * the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof ServerApiDatacentersServersCdromsGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersServersCdromsPost operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersCdromsPostRequest
 */
export interface ServerApiDatacentersServersCdromsPostRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersCdromsPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof ServerApiDatacentersServersCdromsPost
     */
    readonly serverId: string

    /**
     * CD-ROM to be attached
     * @type {Image}
     * @memberof ServerApiDatacentersServersCdromsPost
     */
    readonly cdrom: Image

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersCdromsPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersCdromsPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersCdromsPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersDelete operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersDeleteRequest
 */
export interface ServerApiDatacentersServersDeleteRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersDelete
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof ServerApiDatacentersServersDelete
     */
    readonly serverId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersFindById operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersFindByIdRequest
 */
export interface ServerApiDatacentersServersFindByIdRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersFindById
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof ServerApiDatacentersServersFindById
     */
    readonly serverId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersFindById
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersFindById
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersFindById
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersGet operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersGetRequest
 */
export interface ServerApiDatacentersServersGetRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersGet
     */
    readonly datacenterId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersGet
     */
    readonly depth?: number

    /**
     * It can be used to filter which servers can be upgraded which can not be upgraded.
     * @type {boolean}
     * @memberof ServerApiDatacentersServersGet
     */
    readonly upgradeNeeded?: boolean

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersGet
     */
    readonly xContractNumber?: number

    /**
     * the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof ServerApiDatacentersServersGet
     */
    readonly offset?: number

    /**
     * the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof ServerApiDatacentersServersGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersServersPatch operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersPatchRequest
 */
export interface ServerApiDatacentersServersPatchRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersPatch
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server
     * @type {string}
     * @memberof ServerApiDatacentersServersPatch
     */
    readonly serverId: string

    /**
     * Modified properties of Server
     * @type {ServerProperties}
     * @memberof ServerApiDatacentersServersPatch
     */
    readonly server: ServerProperties

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersPatch
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersPatch
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersPatch
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersPost operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersPostRequest
 */
export interface ServerApiDatacentersServersPostRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersPost
     */
    readonly datacenterId: string

    /**
     * Server to be created
     * @type {Server}
     * @memberof ServerApiDatacentersServersPost
     */
    readonly server: Server

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersPut operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersPutRequest
 */
export interface ServerApiDatacentersServersPutRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersPut
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server
     * @type {string}
     * @memberof ServerApiDatacentersServersPut
     */
    readonly serverId: string

    /**
     * Modified Server
     * @type {Server}
     * @memberof ServerApiDatacentersServersPut
     */
    readonly server: Server

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersPut
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersPut
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersPut
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersRebootPost operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersRebootPostRequest
 */
export interface ServerApiDatacentersServersRebootPostRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersRebootPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof ServerApiDatacentersServersRebootPost
     */
    readonly serverId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersRebootPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersRebootPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersRebootPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersStartPost operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersStartPostRequest
 */
export interface ServerApiDatacentersServersStartPostRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersStartPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof ServerApiDatacentersServersStartPost
     */
    readonly serverId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersStartPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersStartPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersStartPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersStopPost operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersStopPostRequest
 */
export interface ServerApiDatacentersServersStopPostRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersStopPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof ServerApiDatacentersServersStopPost
     */
    readonly serverId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersStopPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersStopPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersStopPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersUpgradePost operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersUpgradePostRequest
 */
export interface ServerApiDatacentersServersUpgradePostRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersUpgradePost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof ServerApiDatacentersServersUpgradePost
     */
    readonly serverId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersUpgradePost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersUpgradePost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersUpgradePost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersVolumesDelete operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersVolumesDeleteRequest
 */
export interface ServerApiDatacentersServersVolumesDeleteRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersVolumesDelete
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof ServerApiDatacentersServersVolumesDelete
     */
    readonly serverId: string

    /**
     * The unique ID of the Volume
     * @type {string}
     * @memberof ServerApiDatacentersServersVolumesDelete
     */
    readonly volumeId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersVolumesDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersVolumesDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersVolumesDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersVolumesFindById operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersVolumesFindByIdRequest
 */
export interface ServerApiDatacentersServersVolumesFindByIdRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersVolumesFindById
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof ServerApiDatacentersServersVolumesFindById
     */
    readonly serverId: string

    /**
     * The unique ID of the Volume
     * @type {string}
     * @memberof ServerApiDatacentersServersVolumesFindById
     */
    readonly volumeId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersVolumesFindById
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersVolumesFindById
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersVolumesFindById
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersVolumesGet operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersVolumesGetRequest
 */
export interface ServerApiDatacentersServersVolumesGetRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersVolumesGet
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof ServerApiDatacentersServersVolumesGet
     */
    readonly serverId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersVolumesGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersVolumesGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersVolumesGet
     */
    readonly xContractNumber?: number

    /**
     * the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof ServerApiDatacentersServersVolumesGet
     */
    readonly offset?: number

    /**
     * the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof ServerApiDatacentersServersVolumesGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersServersVolumesPost operation in ServerApi.
 * @export
 * @interface ServerApiDatacentersServersVolumesPostRequest
 */
export interface ServerApiDatacentersServersVolumesPostRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof ServerApiDatacentersServersVolumesPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof ServerApiDatacentersServersVolumesPost
     */
    readonly serverId: string

    /**
     * Volume to be attached (created and attached)
     * @type {Volume}
     * @memberof ServerApiDatacentersServersVolumesPost
     */
    readonly volume: Volume

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof ServerApiDatacentersServersVolumesPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServerApiDatacentersServersVolumesPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof ServerApiDatacentersServersVolumesPost
     */
    readonly xContractNumber?: number
}

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
    /**
     * This will detach a CD-ROM from the server
     * @summary Detach a CD-ROM
     * @param {ServerApiDatacentersServersCdromsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersCdromsDelete(requestParameters: ServerApiDatacentersServersCdromsDeleteRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersCdromsDelete(requestParameters.datacenterId, requestParameters.serverId, requestParameters.cdromId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a specific CD-ROM attached to the server
     * @summary Retrieve an attached CD-ROM
     * @param {ServerApiDatacentersServersCdromsFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersCdromsFindById(requestParameters: ServerApiDatacentersServersCdromsFindByIdRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersCdromsFindById(requestParameters.datacenterId, requestParameters.serverId, requestParameters.cdromId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a list of CD-ROMs attached to the server.
     * @summary List attached CD-ROMs 
     * @param {ServerApiDatacentersServersCdromsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersCdromsGet(requestParameters: ServerApiDatacentersServersCdromsGetRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersCdromsGet(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can attach a CD-ROM to an existing server. You can attach up to 2 CD-ROMs to one server. 
     * @summary Attach a CD-ROM
     * @param {ServerApiDatacentersServersCdromsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersCdromsPost(requestParameters: ServerApiDatacentersServersCdromsPostRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersCdromsPost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.cdrom, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will remove a server from your datacenter; however, it will not remove the storage volumes attached to the server. You will need to make a separate API call to perform that action
     * @summary Delete a Server
     * @param {ServerApiDatacentersServersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersDelete(requestParameters: ServerApiDatacentersServersDeleteRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersDelete(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about a server such as its configuration, provisioning status, etc.
     * @summary Retrieve a Server
     * @param {ServerApiDatacentersServersFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersFindById(requestParameters: ServerApiDatacentersServersFindByIdRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersFindById(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a list of servers within a datacenter
     * @summary List Servers 
     * @param {ServerApiDatacentersServersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersGet(requestParameters: ServerApiDatacentersServersGetRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersGet(requestParameters.datacenterId, requestParameters.pretty, requestParameters.depth, requestParameters.upgradeNeeded, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use update attributes of a server
     * @summary Partially modify a Server
     * @param {ServerApiDatacentersServersPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersPatch(requestParameters: ServerApiDatacentersServersPatchRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersPatch(requestParameters.datacenterId, requestParameters.serverId, requestParameters.server, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a server within an existing datacenter. You can configure the boot volume and connect the server to an existing LAN.
     * @summary Create a Server
     * @param {ServerApiDatacentersServersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersPost(requestParameters: ServerApiDatacentersServersPostRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersPost(requestParameters.datacenterId, requestParameters.server, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows to modify the attributes of a Server. From v5 onwards \'allowReboot\' attribute will no longer be available. For certain server property change it was earlier forced to be provided. Now this behaviour is implicit and backend will do this automatically e.g. in earlier versions, when CPU family changes, the \'allowReboot\' property was required to be set to true which will no longer be the case and the server will be rebooted automatically
     * @summary Modify a Server
     * @param {ServerApiDatacentersServersPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersPut(requestParameters: ServerApiDatacentersServersPutRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersPut(requestParameters.datacenterId, requestParameters.serverId, requestParameters.server, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will force a hard reboot of the server. Do not use this method if you want to gracefully reboot the machine. This is the equivalent of powering off the machine and turning it back on.
     * @summary Reboot a Server
     * @param {ServerApiDatacentersServersRebootPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersRebootPost(requestParameters: ServerApiDatacentersServersRebootPostRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersRebootPost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will start a server. If the server\'s public IP was deallocated then a new IP will be assigned
     * @summary Start a Server
     * @param {ServerApiDatacentersServersStartPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersStartPost(requestParameters: ServerApiDatacentersServersStartPostRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersStartPost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will stop a server. The machine will be forcefully powered off, billing will cease, and the public IP, if one is allocated, will be deallocated. The operation is not supported for Cube servers.
     * @summary Stop a Server
     * @param {ServerApiDatacentersServersStopPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersStopPost(requestParameters: ServerApiDatacentersServersStopPostRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersStopPost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will upgrade the version of the server, if needed. To verify if there is an upgrade available for a server, call \'/datacenters/{datacenterId}/servers?upgradeNeeded=true\'
     * @summary Upgrade a Server
     * @param {ServerApiDatacentersServersUpgradePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersUpgradePost(requestParameters: ServerApiDatacentersServersUpgradePostRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersUpgradePost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will detach the volume from the server. This will not delete the volume from your datacenter. You will need to make a separate request to perform a deletion
     * @summary Detach a volume
     * @param {ServerApiDatacentersServersVolumesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersVolumesDelete(requestParameters: ServerApiDatacentersServersVolumesDeleteRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersVolumesDelete(requestParameters.datacenterId, requestParameters.serverId, requestParameters.volumeId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will retrieve the properties of an attached volume.
     * @summary Retrieve an attached volume
     * @param {ServerApiDatacentersServersVolumesFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersVolumesFindById(requestParameters: ServerApiDatacentersServersVolumesFindByIdRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersVolumesFindById(requestParameters.datacenterId, requestParameters.serverId, requestParameters.volumeId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a list of volumes attached to the server
     * @summary List Attached Volumes
     * @param {ServerApiDatacentersServersVolumesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersVolumesGet(requestParameters: ServerApiDatacentersServersVolumesGetRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersVolumesGet(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will attach a pre-existing storage volume to the server. It is also possible to create and attach a volume in one step just by providing a new volume description as payload. Combine count of Nics and volumes attached to the server should not exceed size 24.
     * @summary Attach a volume
     * @param {ServerApiDatacentersServersVolumesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public datacentersServersVolumesPost(requestParameters: ServerApiDatacentersServersVolumesPostRequest, options?: any) {
        return ServerApiFp(this.configuration).datacentersServersVolumesPost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.volume, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }
}
