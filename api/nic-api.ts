/* tslint:disable */
/* eslint-disable */
/**
 * CLOUD API
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * The version of the OpenAPI document: 5.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration, DEFAULT_MAX_RETRIES, DEFAULT_MAX_WAIT_TIME } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, backOff, runRequest } from '../base';
// @ts-ignore
import { FirewallRule } from '../model';
// @ts-ignore
import { FirewallRules } from '../model';
// @ts-ignore
import { FirewallruleProperties } from '../model';
// @ts-ignore
import { Nic } from '../model';
// @ts-ignore
import { NicProperties } from '../model';
// @ts-ignore
import { Nics } from '../model';
/**
 * NicApi - axios parameter creator
 * @export
 */
export const NicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the specified NIC.
         * @summary Delete a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsDelete: async (datacenterId: string, serverId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersNicsDelete.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersNicsDelete.');
            }
            // verify required parameter 'nicId' is not null or undefined
            if (nicId === null || nicId === undefined) {
                throw new RequiredError('nicId','Required parameter nicId was null or undefined when calling datacentersServersNicsDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"nicId"}}`, encodeURIComponent(String(nicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the attributes of a given NIC
         * @summary Retrieve a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsFindById: async (datacenterId: string, serverId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersNicsFindById.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersNicsFindById.');
            }
            // verify required parameter 'nicId' is not null or undefined
            if (nicId === null || nicId === undefined) {
                throw new RequiredError('nicId','Required parameter nicId was null or undefined when calling datacentersServersNicsFindById.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"nicId"}}`, encodeURIComponent(String(nicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the specific Firewall Rule
         * @summary Delete a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {string} firewallruleId The unique ID of the Firewall Rule
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsFirewallrulesDelete: async (datacenterId: string, serverId: string, nicId: string, firewallruleId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersNicsFirewallrulesDelete.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersNicsFirewallrulesDelete.');
            }
            // verify required parameter 'nicId' is not null or undefined
            if (nicId === null || nicId === undefined) {
                throw new RequiredError('nicId','Required parameter nicId was null or undefined when calling datacentersServersNicsFirewallrulesDelete.');
            }
            // verify required parameter 'firewallruleId' is not null or undefined
            if (firewallruleId === null || firewallruleId === undefined) {
                throw new RequiredError('firewallruleId','Required parameter firewallruleId was null or undefined when calling datacentersServersNicsFirewallrulesDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}/firewallrules/{firewallruleId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"nicId"}}`, encodeURIComponent(String(nicId)))
                .replace(`{${"firewallruleId"}}`, encodeURIComponent(String(firewallruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the attributes of a given Firewall Rule.
         * @summary Retrieve a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {string} firewallruleId The unique ID of the Firewall Rule
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsFirewallrulesFindById: async (datacenterId: string, serverId: string, nicId: string, firewallruleId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersNicsFirewallrulesFindById.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersNicsFirewallrulesFindById.');
            }
            // verify required parameter 'nicId' is not null or undefined
            if (nicId === null || nicId === undefined) {
                throw new RequiredError('nicId','Required parameter nicId was null or undefined when calling datacentersServersNicsFirewallrulesFindById.');
            }
            // verify required parameter 'firewallruleId' is not null or undefined
            if (firewallruleId === null || firewallruleId === undefined) {
                throw new RequiredError('firewallruleId','Required parameter firewallruleId was null or undefined when calling datacentersServersNicsFirewallrulesFindById.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}/firewallrules/{firewallruleId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"nicId"}}`, encodeURIComponent(String(nicId)))
                .replace(`{${"firewallruleId"}}`, encodeURIComponent(String(firewallruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of firewall rules associated with a particular NIC
         * @summary List Firewall Rules 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsFirewallrulesGet: async (datacenterId: string, serverId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersNicsFirewallrulesGet.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersNicsFirewallrulesGet.');
            }
            // verify required parameter 'nicId' is not null or undefined
            if (nicId === null || nicId === undefined) {
                throw new RequiredError('nicId','Required parameter nicId was null or undefined when calling datacentersServersNicsFirewallrulesGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}/firewallrules`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"nicId"}}`, encodeURIComponent(String(nicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use update attributes of a resource
         * @summary Partially modify a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {string} firewallruleId The unique ID of the Firewall Rule
         * @param {FirewallruleProperties} firewallrule Modified Firewall Rule
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsFirewallrulesPatch: async (datacenterId: string, serverId: string, nicId: string, firewallruleId: string, firewallrule: FirewallruleProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersNicsFirewallrulesPatch.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersNicsFirewallrulesPatch.');
            }
            // verify required parameter 'nicId' is not null or undefined
            if (nicId === null || nicId === undefined) {
                throw new RequiredError('nicId','Required parameter nicId was null or undefined when calling datacentersServersNicsFirewallrulesPatch.');
            }
            // verify required parameter 'firewallruleId' is not null or undefined
            if (firewallruleId === null || firewallruleId === undefined) {
                throw new RequiredError('firewallruleId','Required parameter firewallruleId was null or undefined when calling datacentersServersNicsFirewallrulesPatch.');
            }
            // verify required parameter 'firewallrule' is not null or undefined
            if (firewallrule === null || firewallrule === undefined) {
                throw new RequiredError('firewallrule','Required parameter firewallrule was null or undefined when calling datacentersServersNicsFirewallrulesPatch.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}/firewallrules/{firewallruleId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"nicId"}}`, encodeURIComponent(String(nicId)))
                .replace(`{${"firewallruleId"}}`, encodeURIComponent(String(firewallruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof firewallrule !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(firewallrule !== undefined ? firewallrule : {})
                : (firewallrule || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will add a Firewall Rule to the NIC
         * @summary Create a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the server
         * @param {string} nicId The unique ID of the NIC
         * @param {FirewallRule} firewallrule Firewall Rule to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsFirewallrulesPost: async (datacenterId: string, serverId: string, nicId: string, firewallrule: FirewallRule, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersNicsFirewallrulesPost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersNicsFirewallrulesPost.');
            }
            // verify required parameter 'nicId' is not null or undefined
            if (nicId === null || nicId === undefined) {
                throw new RequiredError('nicId','Required parameter nicId was null or undefined when calling datacentersServersNicsFirewallrulesPost.');
            }
            // verify required parameter 'firewallrule' is not null or undefined
            if (firewallrule === null || firewallrule === undefined) {
                throw new RequiredError('firewallrule','Required parameter firewallrule was null or undefined when calling datacentersServersNicsFirewallrulesPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}/firewallrules`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"nicId"}}`, encodeURIComponent(String(nicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof firewallrule !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(firewallrule !== undefined ? firewallrule : {})
                : (firewallrule || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use update attributes of a resource
         * @summary Modify a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {string} firewallruleId The unique ID of the Firewall Rule
         * @param {FirewallRule} firewallrule Modified Firewall Rule
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsFirewallrulesPut: async (datacenterId: string, serverId: string, nicId: string, firewallruleId: string, firewallrule: FirewallRule, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersNicsFirewallrulesPut.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersNicsFirewallrulesPut.');
            }
            // verify required parameter 'nicId' is not null or undefined
            if (nicId === null || nicId === undefined) {
                throw new RequiredError('nicId','Required parameter nicId was null or undefined when calling datacentersServersNicsFirewallrulesPut.');
            }
            // verify required parameter 'firewallruleId' is not null or undefined
            if (firewallruleId === null || firewallruleId === undefined) {
                throw new RequiredError('firewallruleId','Required parameter firewallruleId was null or undefined when calling datacentersServersNicsFirewallrulesPut.');
            }
            // verify required parameter 'firewallrule' is not null or undefined
            if (firewallrule === null || firewallrule === undefined) {
                throw new RequiredError('firewallrule','Required parameter firewallrule was null or undefined when calling datacentersServersNicsFirewallrulesPut.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}/firewallrules/{firewallruleId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"nicId"}}`, encodeURIComponent(String(nicId)))
                .replace(`{${"firewallruleId"}}`, encodeURIComponent(String(firewallruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof firewallrule !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(firewallrule !== undefined ? firewallrule : {})
                : (firewallrule || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of NICs.
         * @summary List Nics 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsGet: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersNicsGet.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersNicsGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/nics`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use update attributes of a Nic
         * @summary Partially modify a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {NicProperties} nic Modified properties of Nic
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsPatch: async (datacenterId: string, serverId: string, nicId: string, nic: NicProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersNicsPatch.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersNicsPatch.');
            }
            // verify required parameter 'nicId' is not null or undefined
            if (nicId === null || nicId === undefined) {
                throw new RequiredError('nicId','Required parameter nicId was null or undefined when calling datacentersServersNicsPatch.');
            }
            // verify required parameter 'nic' is not null or undefined
            if (nic === null || nic === undefined) {
                throw new RequiredError('nic','Required parameter nic was null or undefined when calling datacentersServersNicsPatch.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"nicId"}}`, encodeURIComponent(String(nicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof nic !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(nic !== undefined ? nic : {})
                : (nic || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a NIC to the target server. Combine count of Nics and volumes attached to the server should not exceed size 24.
         * @summary Create a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {Nic} nic Nic to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsPost: async (datacenterId: string, serverId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersNicsPost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersNicsPost.');
            }
            // verify required parameter 'nic' is not null or undefined
            if (nic === null || nic === undefined) {
                throw new RequiredError('nic','Required parameter nic was null or undefined when calling datacentersServersNicsPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/nics`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof nic !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(nic !== undefined ? nic : {})
                : (nic || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use update attributes of a Nic
         * @summary Modify a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {Nic} nic Modified Nic
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsPut: async (datacenterId: string, serverId: string, nicId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersNicsPut.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersNicsPut.');
            }
            // verify required parameter 'nicId' is not null or undefined
            if (nicId === null || nicId === undefined) {
                throw new RequiredError('nicId','Required parameter nicId was null or undefined when calling datacentersServersNicsPut.');
            }
            // verify required parameter 'nic' is not null or undefined
            if (nic === null || nic === undefined) {
                throw new RequiredError('nic','Required parameter nic was null or undefined when calling datacentersServersNicsPut.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/nics/{nicId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"nicId"}}`, encodeURIComponent(String(nicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof nic !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(nic !== undefined ? nic : {})
                : (nic || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NicApi - functional programming interface
 * @export
 */
export const NicApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes the specified NIC.
         * @summary Delete a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersNicsDelete(datacenterId: string, serverId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await NicApiAxiosParamCreator(configuration).datacentersServersNicsDelete(datacenterId, serverId, nicId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieves the attributes of a given NIC
         * @summary Retrieve a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersNicsFindById(datacenterId: string, serverId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Nic>> {
            const axiosArgs = await NicApiAxiosParamCreator(configuration).datacentersServersNicsFindById(datacenterId, serverId, nicId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Removes the specific Firewall Rule
         * @summary Delete a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {string} firewallruleId The unique ID of the Firewall Rule
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersNicsFirewallrulesDelete(datacenterId: string, serverId: string, nicId: string, firewallruleId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await NicApiAxiosParamCreator(configuration).datacentersServersNicsFirewallrulesDelete(datacenterId, serverId, nicId, firewallruleId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieves the attributes of a given Firewall Rule.
         * @summary Retrieve a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {string} firewallruleId The unique ID of the Firewall Rule
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersNicsFirewallrulesFindById(datacenterId: string, serverId: string, nicId: string, firewallruleId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRule>> {
            const axiosArgs = await NicApiAxiosParamCreator(configuration).datacentersServersNicsFirewallrulesFindById(datacenterId, serverId, nicId, firewallruleId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieves a list of firewall rules associated with a particular NIC
         * @summary List Firewall Rules 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersNicsFirewallrulesGet(datacenterId: string, serverId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRules>> {
            const axiosArgs = await NicApiAxiosParamCreator(configuration).datacentersServersNicsFirewallrulesGet(datacenterId, serverId, nicId, pretty, depth, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can use update attributes of a resource
         * @summary Partially modify a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {string} firewallruleId The unique ID of the Firewall Rule
         * @param {FirewallruleProperties} firewallrule Modified Firewall Rule
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersNicsFirewallrulesPatch(datacenterId: string, serverId: string, nicId: string, firewallruleId: string, firewallrule: FirewallruleProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRule>> {
            const axiosArgs = await NicApiAxiosParamCreator(configuration).datacentersServersNicsFirewallrulesPatch(datacenterId, serverId, nicId, firewallruleId, firewallrule, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will add a Firewall Rule to the NIC
         * @summary Create a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the server
         * @param {string} nicId The unique ID of the NIC
         * @param {FirewallRule} firewallrule Firewall Rule to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersNicsFirewallrulesPost(datacenterId: string, serverId: string, nicId: string, firewallrule: FirewallRule, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRule>> {
            const axiosArgs = await NicApiAxiosParamCreator(configuration).datacentersServersNicsFirewallrulesPost(datacenterId, serverId, nicId, firewallrule, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can use update attributes of a resource
         * @summary Modify a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {string} firewallruleId The unique ID of the Firewall Rule
         * @param {FirewallRule} firewallrule Modified Firewall Rule
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersNicsFirewallrulesPut(datacenterId: string, serverId: string, nicId: string, firewallruleId: string, firewallrule: FirewallRule, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FirewallRule>> {
            const axiosArgs = await NicApiAxiosParamCreator(configuration).datacentersServersNicsFirewallrulesPut(datacenterId, serverId, nicId, firewallruleId, firewallrule, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieves a list of NICs.
         * @summary List Nics 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersNicsGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Nics>> {
            const axiosArgs = await NicApiAxiosParamCreator(configuration).datacentersServersNicsGet(datacenterId, serverId, pretty, depth, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can use update attributes of a Nic
         * @summary Partially modify a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {NicProperties} nic Modified properties of Nic
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersNicsPatch(datacenterId: string, serverId: string, nicId: string, nic: NicProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Nic>> {
            const axiosArgs = await NicApiAxiosParamCreator(configuration).datacentersServersNicsPatch(datacenterId, serverId, nicId, nic, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Adds a NIC to the target server. Combine count of Nics and volumes attached to the server should not exceed size 24.
         * @summary Create a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {Nic} nic Nic to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersNicsPost(datacenterId: string, serverId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Nic>> {
            const axiosArgs = await NicApiAxiosParamCreator(configuration).datacentersServersNicsPost(datacenterId, serverId, nic, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can use update attributes of a Nic
         * @summary Modify a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {Nic} nic Modified Nic
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersNicsPut(datacenterId: string, serverId: string, nicId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Nic>> {
            const axiosArgs = await NicApiAxiosParamCreator(configuration).datacentersServersNicsPut(datacenterId, serverId, nicId, nic, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
    }
};

/**
 * NicApi - factory interface
 * @export
 */
export const NicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes the specified NIC.
         * @summary Delete a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsDelete(datacenterId: string, serverId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return NicApiFp(configuration).datacentersServersNicsDelete(datacenterId, serverId, nicId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the attributes of a given NIC
         * @summary Retrieve a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsFindById(datacenterId: string, serverId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Nic> {
            return NicApiFp(configuration).datacentersServersNicsFindById(datacenterId, serverId, nicId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the specific Firewall Rule
         * @summary Delete a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {string} firewallruleId The unique ID of the Firewall Rule
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsFirewallrulesDelete(datacenterId: string, serverId: string, nicId: string, firewallruleId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return NicApiFp(configuration).datacentersServersNicsFirewallrulesDelete(datacenterId, serverId, nicId, firewallruleId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the attributes of a given Firewall Rule.
         * @summary Retrieve a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {string} firewallruleId The unique ID of the Firewall Rule
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsFirewallrulesFindById(datacenterId: string, serverId: string, nicId: string, firewallruleId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<FirewallRule> {
            return NicApiFp(configuration).datacentersServersNicsFirewallrulesFindById(datacenterId, serverId, nicId, firewallruleId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of firewall rules associated with a particular NIC
         * @summary List Firewall Rules 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsFirewallrulesGet(datacenterId: string, serverId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<FirewallRules> {
            return NicApiFp(configuration).datacentersServersNicsFirewallrulesGet(datacenterId, serverId, nicId, pretty, depth, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use update attributes of a resource
         * @summary Partially modify a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {string} firewallruleId The unique ID of the Firewall Rule
         * @param {FirewallruleProperties} firewallrule Modified Firewall Rule
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsFirewallrulesPatch(datacenterId: string, serverId: string, nicId: string, firewallruleId: string, firewallrule: FirewallruleProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<FirewallRule> {
            return NicApiFp(configuration).datacentersServersNicsFirewallrulesPatch(datacenterId, serverId, nicId, firewallruleId, firewallrule, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will add a Firewall Rule to the NIC
         * @summary Create a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the server
         * @param {string} nicId The unique ID of the NIC
         * @param {FirewallRule} firewallrule Firewall Rule to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsFirewallrulesPost(datacenterId: string, serverId: string, nicId: string, firewallrule: FirewallRule, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<FirewallRule> {
            return NicApiFp(configuration).datacentersServersNicsFirewallrulesPost(datacenterId, serverId, nicId, firewallrule, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use update attributes of a resource
         * @summary Modify a Firewall Rule
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {string} firewallruleId The unique ID of the Firewall Rule
         * @param {FirewallRule} firewallrule Modified Firewall Rule
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsFirewallrulesPut(datacenterId: string, serverId: string, nicId: string, firewallruleId: string, firewallrule: FirewallRule, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<FirewallRule> {
            return NicApiFp(configuration).datacentersServersNicsFirewallrulesPut(datacenterId, serverId, nicId, firewallruleId, firewallrule, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of NICs.
         * @summary List Nics 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<Nics> {
            return NicApiFp(configuration).datacentersServersNicsGet(datacenterId, serverId, pretty, depth, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use update attributes of a Nic
         * @summary Partially modify a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {NicProperties} nic Modified properties of Nic
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsPatch(datacenterId: string, serverId: string, nicId: string, nic: NicProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Nic> {
            return NicApiFp(configuration).datacentersServersNicsPatch(datacenterId, serverId, nicId, nic, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a NIC to the target server. Combine count of Nics and volumes attached to the server should not exceed size 24.
         * @summary Create a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {Nic} nic Nic to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsPost(datacenterId: string, serverId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Nic> {
            return NicApiFp(configuration).datacentersServersNicsPost(datacenterId, serverId, nic, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use update attributes of a Nic
         * @summary Modify a Nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} nicId The unique ID of the NIC
         * @param {Nic} nic Modified Nic
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersNicsPut(datacenterId: string, serverId: string, nicId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Nic> {
            return NicApiFp(configuration).datacentersServersNicsPut(datacenterId, serverId, nicId, nic, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for datacentersServersNicsDelete operation in NicApi.
 * @export
 * @interface NicApiDatacentersServersNicsDeleteRequest
 */
export interface NicApiDatacentersServersNicsDeleteRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof NicApiDatacentersServersNicsDelete
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof NicApiDatacentersServersNicsDelete
     */
    readonly serverId: string

    /**
     * The unique ID of the NIC
     * @type {string}
     * @memberof NicApiDatacentersServersNicsDelete
     */
    readonly nicId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof NicApiDatacentersServersNicsDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof NicApiDatacentersServersNicsDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof NicApiDatacentersServersNicsDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersNicsFindById operation in NicApi.
 * @export
 * @interface NicApiDatacentersServersNicsFindByIdRequest
 */
export interface NicApiDatacentersServersNicsFindByIdRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFindById
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFindById
     */
    readonly serverId: string

    /**
     * The unique ID of the NIC
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFindById
     */
    readonly nicId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof NicApiDatacentersServersNicsFindById
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFindById
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFindById
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersNicsFirewallrulesDelete operation in NicApi.
 * @export
 * @interface NicApiDatacentersServersNicsFirewallrulesDeleteRequest
 */
export interface NicApiDatacentersServersNicsFirewallrulesDeleteRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesDelete
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesDelete
     */
    readonly serverId: string

    /**
     * The unique ID of the NIC
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesDelete
     */
    readonly nicId: string

    /**
     * The unique ID of the Firewall Rule
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesDelete
     */
    readonly firewallruleId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof NicApiDatacentersServersNicsFirewallrulesDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFirewallrulesDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFirewallrulesDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersNicsFirewallrulesFindById operation in NicApi.
 * @export
 * @interface NicApiDatacentersServersNicsFirewallrulesFindByIdRequest
 */
export interface NicApiDatacentersServersNicsFirewallrulesFindByIdRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesFindById
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesFindById
     */
    readonly serverId: string

    /**
     * The unique ID of the NIC
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesFindById
     */
    readonly nicId: string

    /**
     * The unique ID of the Firewall Rule
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesFindById
     */
    readonly firewallruleId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof NicApiDatacentersServersNicsFirewallrulesFindById
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFirewallrulesFindById
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFirewallrulesFindById
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersNicsFirewallrulesGet operation in NicApi.
 * @export
 * @interface NicApiDatacentersServersNicsFirewallrulesGetRequest
 */
export interface NicApiDatacentersServersNicsFirewallrulesGetRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesGet
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesGet
     */
    readonly serverId: string

    /**
     * The unique ID of the NIC
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesGet
     */
    readonly nicId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof NicApiDatacentersServersNicsFirewallrulesGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFirewallrulesGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFirewallrulesGet
     */
    readonly xContractNumber?: number

    /**
     * the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFirewallrulesGet
     */
    readonly offset?: number

    /**
     * the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFirewallrulesGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersServersNicsFirewallrulesPatch operation in NicApi.
 * @export
 * @interface NicApiDatacentersServersNicsFirewallrulesPatchRequest
 */
export interface NicApiDatacentersServersNicsFirewallrulesPatchRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPatch
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPatch
     */
    readonly serverId: string

    /**
     * The unique ID of the NIC
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPatch
     */
    readonly nicId: string

    /**
     * The unique ID of the Firewall Rule
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPatch
     */
    readonly firewallruleId: string

    /**
     * Modified Firewall Rule
     * @type {FirewallruleProperties}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPatch
     */
    readonly firewallrule: FirewallruleProperties

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPatch
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPatch
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPatch
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersNicsFirewallrulesPost operation in NicApi.
 * @export
 * @interface NicApiDatacentersServersNicsFirewallrulesPostRequest
 */
export interface NicApiDatacentersServersNicsFirewallrulesPostRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPost
     */
    readonly serverId: string

    /**
     * The unique ID of the NIC
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPost
     */
    readonly nicId: string

    /**
     * Firewall Rule to be created
     * @type {FirewallRule}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPost
     */
    readonly firewallrule: FirewallRule

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersNicsFirewallrulesPut operation in NicApi.
 * @export
 * @interface NicApiDatacentersServersNicsFirewallrulesPutRequest
 */
export interface NicApiDatacentersServersNicsFirewallrulesPutRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPut
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPut
     */
    readonly serverId: string

    /**
     * The unique ID of the NIC
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPut
     */
    readonly nicId: string

    /**
     * The unique ID of the Firewall Rule
     * @type {string}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPut
     */
    readonly firewallruleId: string

    /**
     * Modified Firewall Rule
     * @type {FirewallRule}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPut
     */
    readonly firewallrule: FirewallRule

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPut
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPut
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof NicApiDatacentersServersNicsFirewallrulesPut
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersNicsGet operation in NicApi.
 * @export
 * @interface NicApiDatacentersServersNicsGetRequest
 */
export interface NicApiDatacentersServersNicsGetRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof NicApiDatacentersServersNicsGet
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof NicApiDatacentersServersNicsGet
     */
    readonly serverId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof NicApiDatacentersServersNicsGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof NicApiDatacentersServersNicsGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof NicApiDatacentersServersNicsGet
     */
    readonly xContractNumber?: number

    /**
     * the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof NicApiDatacentersServersNicsGet
     */
    readonly offset?: number

    /**
     * the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof NicApiDatacentersServersNicsGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersServersNicsPatch operation in NicApi.
 * @export
 * @interface NicApiDatacentersServersNicsPatchRequest
 */
export interface NicApiDatacentersServersNicsPatchRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof NicApiDatacentersServersNicsPatch
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof NicApiDatacentersServersNicsPatch
     */
    readonly serverId: string

    /**
     * The unique ID of the NIC
     * @type {string}
     * @memberof NicApiDatacentersServersNicsPatch
     */
    readonly nicId: string

    /**
     * Modified properties of Nic
     * @type {NicProperties}
     * @memberof NicApiDatacentersServersNicsPatch
     */
    readonly nic: NicProperties

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof NicApiDatacentersServersNicsPatch
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof NicApiDatacentersServersNicsPatch
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof NicApiDatacentersServersNicsPatch
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersNicsPost operation in NicApi.
 * @export
 * @interface NicApiDatacentersServersNicsPostRequest
 */
export interface NicApiDatacentersServersNicsPostRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof NicApiDatacentersServersNicsPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof NicApiDatacentersServersNicsPost
     */
    readonly serverId: string

    /**
     * Nic to be created
     * @type {Nic}
     * @memberof NicApiDatacentersServersNicsPost
     */
    readonly nic: Nic

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof NicApiDatacentersServersNicsPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof NicApiDatacentersServersNicsPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof NicApiDatacentersServersNicsPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersNicsPut operation in NicApi.
 * @export
 * @interface NicApiDatacentersServersNicsPutRequest
 */
export interface NicApiDatacentersServersNicsPutRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof NicApiDatacentersServersNicsPut
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof NicApiDatacentersServersNicsPut
     */
    readonly serverId: string

    /**
     * The unique ID of the NIC
     * @type {string}
     * @memberof NicApiDatacentersServersNicsPut
     */
    readonly nicId: string

    /**
     * Modified Nic
     * @type {Nic}
     * @memberof NicApiDatacentersServersNicsPut
     */
    readonly nic: Nic

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof NicApiDatacentersServersNicsPut
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof NicApiDatacentersServersNicsPut
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof NicApiDatacentersServersNicsPut
     */
    readonly xContractNumber?: number
}

/**
 * NicApi - object-oriented interface
 * @export
 * @class NicApi
 * @extends {BaseAPI}
 */
export class NicApi extends BaseAPI {
    /**
     * Deletes the specified NIC.
     * @summary Delete a Nic
     * @param {NicApiDatacentersServersNicsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NicApi
     */
    public datacentersServersNicsDelete(requestParameters: NicApiDatacentersServersNicsDeleteRequest, options?: any) {
        return NicApiFp(this.configuration).datacentersServersNicsDelete(requestParameters.datacenterId, requestParameters.serverId, requestParameters.nicId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the attributes of a given NIC
     * @summary Retrieve a Nic
     * @param {NicApiDatacentersServersNicsFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NicApi
     */
    public datacentersServersNicsFindById(requestParameters: NicApiDatacentersServersNicsFindByIdRequest, options?: any) {
        return NicApiFp(this.configuration).datacentersServersNicsFindById(requestParameters.datacenterId, requestParameters.serverId, requestParameters.nicId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the specific Firewall Rule
     * @summary Delete a Firewall Rule
     * @param {NicApiDatacentersServersNicsFirewallrulesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NicApi
     */
    public datacentersServersNicsFirewallrulesDelete(requestParameters: NicApiDatacentersServersNicsFirewallrulesDeleteRequest, options?: any) {
        return NicApiFp(this.configuration).datacentersServersNicsFirewallrulesDelete(requestParameters.datacenterId, requestParameters.serverId, requestParameters.nicId, requestParameters.firewallruleId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the attributes of a given Firewall Rule.
     * @summary Retrieve a Firewall Rule
     * @param {NicApiDatacentersServersNicsFirewallrulesFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NicApi
     */
    public datacentersServersNicsFirewallrulesFindById(requestParameters: NicApiDatacentersServersNicsFirewallrulesFindByIdRequest, options?: any) {
        return NicApiFp(this.configuration).datacentersServersNicsFirewallrulesFindById(requestParameters.datacenterId, requestParameters.serverId, requestParameters.nicId, requestParameters.firewallruleId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of firewall rules associated with a particular NIC
     * @summary List Firewall Rules 
     * @param {NicApiDatacentersServersNicsFirewallrulesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NicApi
     */
    public datacentersServersNicsFirewallrulesGet(requestParameters: NicApiDatacentersServersNicsFirewallrulesGetRequest, options?: any) {
        return NicApiFp(this.configuration).datacentersServersNicsFirewallrulesGet(requestParameters.datacenterId, requestParameters.serverId, requestParameters.nicId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use update attributes of a resource
     * @summary Partially modify a Firewall Rule
     * @param {NicApiDatacentersServersNicsFirewallrulesPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NicApi
     */
    public datacentersServersNicsFirewallrulesPatch(requestParameters: NicApiDatacentersServersNicsFirewallrulesPatchRequest, options?: any) {
        return NicApiFp(this.configuration).datacentersServersNicsFirewallrulesPatch(requestParameters.datacenterId, requestParameters.serverId, requestParameters.nicId, requestParameters.firewallruleId, requestParameters.firewallrule, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will add a Firewall Rule to the NIC
     * @summary Create a Firewall Rule
     * @param {NicApiDatacentersServersNicsFirewallrulesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NicApi
     */
    public datacentersServersNicsFirewallrulesPost(requestParameters: NicApiDatacentersServersNicsFirewallrulesPostRequest, options?: any) {
        return NicApiFp(this.configuration).datacentersServersNicsFirewallrulesPost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.nicId, requestParameters.firewallrule, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use update attributes of a resource
     * @summary Modify a Firewall Rule
     * @param {NicApiDatacentersServersNicsFirewallrulesPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NicApi
     */
    public datacentersServersNicsFirewallrulesPut(requestParameters: NicApiDatacentersServersNicsFirewallrulesPutRequest, options?: any) {
        return NicApiFp(this.configuration).datacentersServersNicsFirewallrulesPut(requestParameters.datacenterId, requestParameters.serverId, requestParameters.nicId, requestParameters.firewallruleId, requestParameters.firewallrule, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of NICs.
     * @summary List Nics 
     * @param {NicApiDatacentersServersNicsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NicApi
     */
    public datacentersServersNicsGet(requestParameters: NicApiDatacentersServersNicsGetRequest, options?: any) {
        return NicApiFp(this.configuration).datacentersServersNicsGet(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use update attributes of a Nic
     * @summary Partially modify a Nic
     * @param {NicApiDatacentersServersNicsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NicApi
     */
    public datacentersServersNicsPatch(requestParameters: NicApiDatacentersServersNicsPatchRequest, options?: any) {
        return NicApiFp(this.configuration).datacentersServersNicsPatch(requestParameters.datacenterId, requestParameters.serverId, requestParameters.nicId, requestParameters.nic, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a NIC to the target server. Combine count of Nics and volumes attached to the server should not exceed size 24.
     * @summary Create a Nic
     * @param {NicApiDatacentersServersNicsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NicApi
     */
    public datacentersServersNicsPost(requestParameters: NicApiDatacentersServersNicsPostRequest, options?: any) {
        return NicApiFp(this.configuration).datacentersServersNicsPost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.nic, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use update attributes of a Nic
     * @summary Modify a Nic
     * @param {NicApiDatacentersServersNicsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NicApi
     */
    public datacentersServersNicsPut(requestParameters: NicApiDatacentersServersNicsPutRequest, options?: any) {
        return NicApiFp(this.configuration).datacentersServersNicsPut(requestParameters.datacenterId, requestParameters.serverId, requestParameters.nicId, requestParameters.nic, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }
}
