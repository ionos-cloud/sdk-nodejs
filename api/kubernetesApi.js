"use strict";
/**
 * CLOUD API
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * The version of the OpenAPI document: 5.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KubernetesApi = exports.KubernetesApiApiKeys = void 0;
var request_1 = __importDefault(require("request"));
var models_1 = require("../model/models");
var models_2 = require("../model/models");
var apis_1 = require("./apis");
var defaultBasePath = 'https://api.ionos.com/cloudapi/v5';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var KubernetesApiApiKeys;
(function (KubernetesApiApiKeys) {
    KubernetesApiApiKeys[KubernetesApiApiKeys["Token Authentication"] = 0] = "Token Authentication";
})(KubernetesApiApiKeys = exports.KubernetesApiApiKeys || (exports.KubernetesApiApiKeys = {}));
var KubernetesApi = /** @class */ (function () {
    function KubernetesApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new models_1.VoidAuth(),
            'Basic Authentication': new models_2.HttpBasicAuth(),
            'Token Authentication': new models_2.ApiKeyAuth('header', 'Authorization'),
        };
        this.interceptors = [];
        if (password) {
            this.username = basePathOrUsername;
            this.password = password;
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(KubernetesApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(KubernetesApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(KubernetesApi.prototype, "defaultHeaders", {
        get: function () {
            return this._defaultHeaders;
        },
        set: function (defaultHeaders) {
            this._defaultHeaders = defaultHeaders;
        },
        enumerable: false,
        configurable: true
    });
    KubernetesApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    KubernetesApi.prototype.setApiKey = function (key, value) {
        this.authentications[KubernetesApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(KubernetesApi.prototype, "username", {
        set: function (username) {
            this.authentications['Basic Authentication'].username = username;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(KubernetesApi.prototype, "password", {
        set: function (password) {
            this.authentications['Basic Authentication'].password = password;
        },
        enumerable: false,
        configurable: true
    });
    KubernetesApi.prototype.addInterceptor = function (interceptor) {
        this.interceptors.push(interceptor);
    };
    /**
     * This will remove a Kubernetes Cluster.
     * @summary Delete Kubernetes Cluster
     * @param k8sClusterId The unique ID of the Kubernetes Cluster
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sDelete = function (k8sClusterId, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_1, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/{k8sClusterId}'
                    .replace('{' + 'k8sClusterId' + '}', encodeURIComponent(String(k8sClusterId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'k8sClusterId' is not null or undefined
                if (k8sClusterId === null || k8sClusterId === undefined) {
                    throw new Error('Required parameter k8sClusterId was null or undefined when calling k8sDelete.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'DELETE',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_1 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_1(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "object");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will retrieve a single Kubernetes Cluster.
     * @summary Retrieve Kubernetes Cluster
     * @param k8sClusterId The unique ID of the Kubernetes Cluster
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sFindByClusterId = function (k8sClusterId, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_2, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/{k8sClusterId}'
                    .replace('{' + 'k8sClusterId' + '}', encodeURIComponent(String(k8sClusterId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'k8sClusterId' is not null or undefined
                if (k8sClusterId === null || k8sClusterId === undefined) {
                    throw new Error('Required parameter k8sClusterId was null or undefined when calling k8sFindByClusterId.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_2 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_2(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "KubernetesCluster");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve a list of all kubernetes clusters associated with a contract
     * @summary List Kubernetes Clusters
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sGet = function (pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_3, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s';
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_3 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_3(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "KubernetesClusters");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve kubernetes configuration file for the kubernetes cluster.
     * @summary Retrieve Kubernetes Configuration File
     * @param k8sClusterId The unique ID of the Kubernetes Cluster
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sKubeconfigGet = function (k8sClusterId, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_4, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/{k8sClusterId}/kubeconfig'
                    .replace('{' + 'k8sClusterId' + '}', encodeURIComponent(String(k8sClusterId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'k8sClusterId' is not null or undefined
                if (k8sClusterId === null || k8sClusterId === undefined) {
                    throw new Error('Required parameter k8sClusterId was null or undefined when calling k8sKubeconfigGet.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_4 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_4(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "KubernetesConfig");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will remove a Kubernetes Node Pool.
     * @summary Delete Kubernetes Node Pool
     * @param k8sClusterId The unique ID of the Kubernetes Cluster
     * @param nodepoolId The unique ID of the Kubernetes Node Pool
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sNodepoolsDelete = function (k8sClusterId, nodepoolId, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_5, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/{k8sClusterId}/nodepools/{nodepoolId}'
                    .replace('{' + 'k8sClusterId' + '}', encodeURIComponent(String(k8sClusterId)))
                    .replace('{' + 'nodepoolId' + '}', encodeURIComponent(String(nodepoolId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'k8sClusterId' is not null or undefined
                if (k8sClusterId === null || k8sClusterId === undefined) {
                    throw new Error('Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsDelete.');
                }
                // verify required parameter 'nodepoolId' is not null or undefined
                if (nodepoolId === null || nodepoolId === undefined) {
                    throw new Error('Required parameter nodepoolId was null or undefined when calling k8sNodepoolsDelete.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'DELETE',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_5 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_5(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "object");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve a single Kubernetes Node Pool.
     * @summary Retrieve Kubernetes Node Pool
     * @param k8sClusterId The unique ID of the Kubernetes Cluster
     * @param nodepoolId The unique ID of the Kubernetes Node Pool
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sNodepoolsFindById = function (k8sClusterId, nodepoolId, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_6, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/{k8sClusterId}/nodepools/{nodepoolId}'
                    .replace('{' + 'k8sClusterId' + '}', encodeURIComponent(String(k8sClusterId)))
                    .replace('{' + 'nodepoolId' + '}', encodeURIComponent(String(nodepoolId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'k8sClusterId' is not null or undefined
                if (k8sClusterId === null || k8sClusterId === undefined) {
                    throw new Error('Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsFindById.');
                }
                // verify required parameter 'nodepoolId' is not null or undefined
                if (nodepoolId === null || nodepoolId === undefined) {
                    throw new Error('Required parameter nodepoolId was null or undefined when calling k8sNodepoolsFindById.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_6 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_6(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "KubernetesNodePool");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve a list of all kubernetes node pools part of kubernetes cluster
     * @summary List Kubernetes Node Pools
     * @param k8sClusterId The unique ID of the Kubernetes Cluster
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sNodepoolsGet = function (k8sClusterId, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_7, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/{k8sClusterId}/nodepools'
                    .replace('{' + 'k8sClusterId' + '}', encodeURIComponent(String(k8sClusterId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'k8sClusterId' is not null or undefined
                if (k8sClusterId === null || k8sClusterId === undefined) {
                    throw new Error('Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsGet.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_7 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_7(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "KubernetesNodePools");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will remove a Kubernetes node.
     * @summary Delete Kubernetes node
     * @param k8sClusterId The unique ID of the Kubernetes Cluster
     * @param nodepoolId The unique ID of the Kubernetes Node Pool
     * @param nodeId The unique ID of the Kubernetes node
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sNodepoolsNodesDelete = function (k8sClusterId, nodepoolId, nodeId, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_8, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/{k8sClusterId}/nodepools/{nodepoolId}/nodes/{nodeId}'
                    .replace('{' + 'k8sClusterId' + '}', encodeURIComponent(String(k8sClusterId)))
                    .replace('{' + 'nodepoolId' + '}', encodeURIComponent(String(nodepoolId)))
                    .replace('{' + 'nodeId' + '}', encodeURIComponent(String(nodeId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'k8sClusterId' is not null or undefined
                if (k8sClusterId === null || k8sClusterId === undefined) {
                    throw new Error('Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsNodesDelete.');
                }
                // verify required parameter 'nodepoolId' is not null or undefined
                if (nodepoolId === null || nodepoolId === undefined) {
                    throw new Error('Required parameter nodepoolId was null or undefined when calling k8sNodepoolsNodesDelete.');
                }
                // verify required parameter 'nodeId' is not null or undefined
                if (nodeId === null || nodeId === undefined) {
                    throw new Error('Required parameter nodeId was null or undefined when calling k8sNodepoolsNodesDelete.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'DELETE',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_8 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_8(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "object");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve a single Kubernetes Node.
     * @summary Retrieve Kubernetes node
     * @param k8sClusterId The unique ID of the Kubernetes Cluster
     * @param nodepoolId The unique ID of the Kubernetes Node Pool
     * @param nodeId The unique ID of the Kubernetes Node.
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sNodepoolsNodesFindById = function (k8sClusterId, nodepoolId, nodeId, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_9, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/{k8sClusterId}/nodepools/{nodepoolId}/nodes/{nodeId}'
                    .replace('{' + 'k8sClusterId' + '}', encodeURIComponent(String(k8sClusterId)))
                    .replace('{' + 'nodepoolId' + '}', encodeURIComponent(String(nodepoolId)))
                    .replace('{' + 'nodeId' + '}', encodeURIComponent(String(nodeId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'k8sClusterId' is not null or undefined
                if (k8sClusterId === null || k8sClusterId === undefined) {
                    throw new Error('Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsNodesFindById.');
                }
                // verify required parameter 'nodepoolId' is not null or undefined
                if (nodepoolId === null || nodepoolId === undefined) {
                    throw new Error('Required parameter nodepoolId was null or undefined when calling k8sNodepoolsNodesFindById.');
                }
                // verify required parameter 'nodeId' is not null or undefined
                if (nodeId === null || nodeId === undefined) {
                    throw new Error('Required parameter nodeId was null or undefined when calling k8sNodepoolsNodesFindById.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_9 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_9(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "KubernetesNode");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve all nodes of Kubernetes Node Pool.
     * @summary Retrieve Kubernetes nodes.
     * @param k8sClusterId The unique ID of the Kubernetes Cluster
     * @param nodepoolId The unique ID of the Kubernetes Node Pool
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sNodepoolsNodesGet = function (k8sClusterId, nodepoolId, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_10, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/{k8sClusterId}/nodepools/{nodepoolId}/nodes'
                    .replace('{' + 'k8sClusterId' + '}', encodeURIComponent(String(k8sClusterId)))
                    .replace('{' + 'nodepoolId' + '}', encodeURIComponent(String(nodepoolId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'k8sClusterId' is not null or undefined
                if (k8sClusterId === null || k8sClusterId === undefined) {
                    throw new Error('Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsNodesGet.');
                }
                // verify required parameter 'nodepoolId' is not null or undefined
                if (nodepoolId === null || nodepoolId === undefined) {
                    throw new Error('Required parameter nodepoolId was null or undefined when calling k8sNodepoolsNodesGet.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_10 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_10(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "KubernetesNodes");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can recreate a single Kubernetes Node.  Managed Kubernetes starts a process which based on the nodepool\'s template creates & configures a new node, waits for status \"ACTIVE\", and migrates all the pods from the faulty node, deleting it once empty. While this operation occurs, the nodepool will have an extra billable \"ACTIVE\" node.
     * @summary Recreate the Kubernetes node
     * @param k8sClusterId The unique ID of the Kubernetes Cluster
     * @param nodepoolId The unique ID of the Kubernetes Node Pool
     * @param nodeId The unique ID of the Kubernetes Node.
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sNodepoolsNodesReplacePost = function (k8sClusterId, nodepoolId, nodeId, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_11, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/{k8sClusterId}/nodepools/{nodepoolId}/nodes/{nodeId}/replace'
                    .replace('{' + 'k8sClusterId' + '}', encodeURIComponent(String(k8sClusterId)))
                    .replace('{' + 'nodepoolId' + '}', encodeURIComponent(String(nodepoolId)))
                    .replace('{' + 'nodeId' + '}', encodeURIComponent(String(nodeId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'k8sClusterId' is not null or undefined
                if (k8sClusterId === null || k8sClusterId === undefined) {
                    throw new Error('Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsNodesReplacePost.');
                }
                // verify required parameter 'nodepoolId' is not null or undefined
                if (nodepoolId === null || nodepoolId === undefined) {
                    throw new Error('Required parameter nodepoolId was null or undefined when calling k8sNodepoolsNodesReplacePost.');
                }
                // verify required parameter 'nodeId' is not null or undefined
                if (nodeId === null || nodeId === undefined) {
                    throw new Error('Required parameter nodeId was null or undefined when calling k8sNodepoolsNodesReplacePost.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_11 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_11(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "object");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will create a new Kubernetes Node Pool inside a Kubernetes Cluster.
     * @summary Create a Kubernetes Node Pool
     * @param k8sClusterId The unique ID of the Kubernetes Cluster
     * @param kubernetesNodePool Details of Kubernetes Node Pool
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sNodepoolsPost = function (k8sClusterId, kubernetesNodePool, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_12, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/{k8sClusterId}/nodepools'
                    .replace('{' + 'k8sClusterId' + '}', encodeURIComponent(String(k8sClusterId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'k8sClusterId' is not null or undefined
                if (k8sClusterId === null || k8sClusterId === undefined) {
                    throw new Error('Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsPost.');
                }
                // verify required parameter 'kubernetesNodePool' is not null or undefined
                if (kubernetesNodePool === null || kubernetesNodePool === undefined) {
                    throw new Error('Required parameter kubernetesNodePool was null or undefined when calling k8sNodepoolsPost.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(kubernetesNodePool, "KubernetesNodePool")
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_12 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_12(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "KubernetesNodePool");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will modify the Kubernetes Node Pool.
     * @summary Modify Kubernetes Node Pool
     * @param k8sClusterId The unique ID of the Kubernetes Cluster
     * @param nodepoolId The unique ID of the Kubernetes Node Pool
     * @param kubernetesNodePool Details of the Kubernetes Node Pool
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sNodepoolsPut = function (k8sClusterId, nodepoolId, kubernetesNodePool, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_13, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/{k8sClusterId}/nodepools/{nodepoolId}'
                    .replace('{' + 'k8sClusterId' + '}', encodeURIComponent(String(k8sClusterId)))
                    .replace('{' + 'nodepoolId' + '}', encodeURIComponent(String(nodepoolId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'k8sClusterId' is not null or undefined
                if (k8sClusterId === null || k8sClusterId === undefined) {
                    throw new Error('Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsPut.');
                }
                // verify required parameter 'nodepoolId' is not null or undefined
                if (nodepoolId === null || nodepoolId === undefined) {
                    throw new Error('Required parameter nodepoolId was null or undefined when calling k8sNodepoolsPut.');
                }
                // verify required parameter 'kubernetesNodePool' is not null or undefined
                if (kubernetesNodePool === null || kubernetesNodePool === undefined) {
                    throw new Error('Required parameter kubernetesNodePool was null or undefined when calling k8sNodepoolsPut.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'PUT',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(kubernetesNodePool, "KubernetesNodePool")
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_13 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_13(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "KubernetesNodePoolForPut");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will create a new Kubernetes Cluster.
     * @summary Create Kubernetes Cluster
     * @param kubernetesCluster Properties of the Kubernetes Cluster
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sPost = function (kubernetesCluster, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_14, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s';
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'kubernetesCluster' is not null or undefined
                if (kubernetesCluster === null || kubernetesCluster === undefined) {
                    throw new Error('Required parameter kubernetesCluster was null or undefined when calling k8sPost.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'POST',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(kubernetesCluster, "KubernetesCluster")
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_14 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_14(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "KubernetesCluster");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * This will modify the Kubernetes Cluster.
     * @summary Modify Kubernetes Cluster
     * @param k8sClusterId The unique ID of the Kubernetes Cluster
     * @param kubernetesCluster Properties of the Kubernetes Cluster
     * @param pretty Controls whether response is pretty-printed (with indentation and new lines)
     * @param depth Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @param xContractNumber Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     */
    KubernetesApi.prototype.k8sPut = function (k8sClusterId, kubernetesCluster, pretty, depth, xContractNumber, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_15, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/{k8sClusterId}'
                    .replace('{' + 'k8sClusterId' + '}', encodeURIComponent(String(k8sClusterId)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'k8sClusterId' is not null or undefined
                if (k8sClusterId === null || k8sClusterId === undefined) {
                    throw new Error('Required parameter k8sClusterId was null or undefined when calling k8sPut.');
                }
                // verify required parameter 'kubernetesCluster' is not null or undefined
                if (kubernetesCluster === null || kubernetesCluster === undefined) {
                    throw new Error('Required parameter kubernetesCluster was null or undefined when calling k8sPut.');
                }
                if (pretty !== undefined) {
                    localVarQueryParameters['pretty'] = models_1.ObjectSerializer.serialize(pretty, "boolean");
                }
                if (depth !== undefined) {
                    localVarQueryParameters['depth'] = models_1.ObjectSerializer.serialize(depth, "number");
                }
                localVarHeaderParams['X-Contract-Number'] = models_1.ObjectSerializer.serialize(xContractNumber, "number");
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'PUT',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                    body: models_1.ObjectSerializer.serialize(kubernetesCluster, "KubernetesCluster")
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_15 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_15(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "KubernetesCluster");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve a list of available kubernetes versions for nodepools depending on the given kubernetes version running in the cluster.
     * @summary Retrieves a list of available kubernetes versions for nodepools depending on the given kubernetes version running in the cluster.
     * @param clusterVersion
     */
    KubernetesApi.prototype.k8sVersionsCompatibilitiesGet = function (clusterVersion, options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_16, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/versions/{clusterVersion}/compatibilities'
                    .replace('{' + 'clusterVersion' + '}', encodeURIComponent(String(clusterVersion)));
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                // verify required parameter 'clusterVersion' is not null or undefined
                if (clusterVersion === null || clusterVersion === undefined) {
                    throw new Error('Required parameter clusterVersion was null or undefined when calling k8sVersionsCompatibilitiesGet.');
                }
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_16 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_16(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "Array<string>");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve the current default kubernetes version for clusters and nodepools.
     * @summary Retrieve the current default kubernetes version for clusters and nodepools.
     */
    KubernetesApi.prototype.k8sVersionsDefaultGet = function (options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_17, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/versions/default';
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_17 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_17(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "string");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    /**
     * You can retrieve a list of available kubernetes versions
     * @summary Retrieve available Kubernetes versions
     */
    KubernetesApi.prototype.k8sVersionsGet = function (options) {
        if (options === void 0) { options = { headers: {} }; }
        return __awaiter(this, void 0, void 0, function () {
            var localVarPath, localVarQueryParameters, localVarHeaderParams, produces, localVarFormParams, localVarUseFormData, localVarRequestOptions, authenticationPromise, interceptorPromise, _loop_18, _i, _a, interceptor, apiCallFunction;
            var _this = this;
            return __generator(this, function (_b) {
                localVarPath = this.basePath + '/k8s/versions';
                localVarQueryParameters = {};
                localVarHeaderParams = Object.assign({}, this._defaultHeaders);
                produces = ['application/json'];
                // give precedence to 'application/json'
                if (produces.indexOf('application/json') >= 0) {
                    localVarHeaderParams.Accept = 'application/json';
                }
                else {
                    localVarHeaderParams.Accept = produces.join(',');
                }
                localVarFormParams = {};
                Object.assign(localVarHeaderParams, options.headers);
                localVarUseFormData = false;
                localVarRequestOptions = {
                    method: 'GET',
                    qs: localVarQueryParameters,
                    headers: localVarHeaderParams,
                    uri: localVarPath,
                    useQuerystring: this._useQuerystring,
                    json: true,
                };
                authenticationPromise = Promise.resolve();
                if (this.authentications['Basic Authentication'].username && this.authentications['Basic Authentication'].password) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Basic Authentication'].applyToRequest(localVarRequestOptions); });
                }
                if (this.authentications['Token Authentication'].apiKey) {
                    authenticationPromise = authenticationPromise.then(function () { return _this.authentications['Token Authentication'].applyToRequest(localVarRequestOptions); });
                }
                authenticationPromise = authenticationPromise.then(function () { return _this.authentications.default.applyToRequest(localVarRequestOptions); });
                interceptorPromise = authenticationPromise;
                _loop_18 = function (interceptor) {
                    interceptorPromise = interceptorPromise.then(function () { return interceptor(localVarRequestOptions); });
                };
                for (_i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                    interceptor = _a[_i];
                    _loop_18(interceptor);
                }
                apiCallFunction = function (resolve, reject) {
                    request_1.default(localVarRequestOptions, function (error, response, body) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            body = models_1.ObjectSerializer.deserialize(body, "Array<string>");
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                resolve({ response: response, body: body });
                            }
                            else {
                                var backoffTime = 0;
                                if (response.headers['retry-after'] != null) {
                                    backoffTime = response.headers['retry-after'];
                                }
                                switch (response.statusCode) {
                                    case KubernetesApi.BAD_GATEWAY:
                                    case KubernetesApi.SERVICE_UNAVAILABLE:
                                    case KubernetesApi.GATEWAY_TIMEOUT:
                                        backoffTime = KubernetesApi.waitTime;
                                        break;
                                    case KubernetesApi.TOO_MANY_REQUESTS:
                                        if (response.headers['retry-after'] != null) {
                                            backoffTime = response.headers['retry-after'];
                                        }
                                        else {
                                            backoffTime = KubernetesApi.waitTime;
                                        }
                                        break;
                                    default:
                                        reject(new apis_1.HttpError(response, body, response.statusCode));
                                }
                                setTimeout(function () { return apiCallFunction(resolve, reject); }, backoffTime * 1000);
                            }
                        }
                    });
                };
                return [2 /*return*/, interceptorPromise.then(function () {
                        if (Object.keys(localVarFormParams).length) {
                            if (localVarUseFormData) {
                                localVarRequestOptions.formData = localVarFormParams;
                            }
                            else {
                                localVarRequestOptions.form = localVarFormParams;
                            }
                        }
                        return new Promise(apiCallFunction);
                    })];
            });
        });
    };
    KubernetesApi.prototype.sleep = function (seconds) {
        var e = new Date().getTime() + (seconds * 1000);
        while (new Date().getTime() <= e) { }
    };
    KubernetesApi.prototype.waitForCompletion = function (requestId, timeout, initialWait, scaleup, maxRetries) {
        if (timeout === void 0) { timeout = 3600; }
        if (initialWait === void 0) { initialWait = 5; }
        if (scaleup === void 0) { scaleup = 10; }
        if (maxRetries === void 0) { maxRetries = 10; }
        return __awaiter(this, void 0, void 0, function () {
            var waitPeriod, nextIncrease, requestCall, breakLoop, currentTime;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        /**
                         Poll resource request status until resource is provisioned.
                
                         :param      requestId: Request id of the action.
                         :type       requestId: ``str``
                
                         :param      timeout: Maximum waiting time in seconds. None means infinite waiting time.
                         :type       timeout: ``int``
                
                         :param      initialWait: Initial polling interval in seconds.
                         :type       initialWait: ``int``
                
                         :param      scaleup: Double polling interval every scaleup steps, which will be doubled.
                         :type       scaleup: ``int``
                
                         */
                        if (!requestId) {
                            throw new Error("Request ID is missing.");
                        }
                        waitPeriod = initialWait;
                        nextIncrease = Date.now() / 1000 + waitPeriod * scaleup;
                        timeout = Date.now() / 1000 + timeout;
                        requestCall = (new apis_1.RequestApi(this.username, this.password)).requestsStatusGet(requestId);
                        breakLoop = false;
                        _a.label = 1;
                    case 1:
                        if (!true) return [3 /*break*/, 3];
                        return [4 /*yield*/, requestCall.then(function (request) {
                                var _a, _b;
                                if (((_a = request.body.metadata) === null || _a === void 0 ? void 0 : _a.status) == models_1.RequestStatusMetadata.StatusEnum.Done) {
                                    breakLoop = true;
                                }
                                else if (((_b = request.body.metadata) === null || _b === void 0 ? void 0 : _b.status) == models_1.RequestStatusMetadata.StatusEnum.Failed) {
                                    throw new Error("Request " + requestId + " failed to complete: " + request['metadata']['message']);
                                }
                            })];
                    case 2:
                        _a.sent();
                        if (breakLoop) {
                            return [3 /*break*/, 3];
                        }
                        currentTime = Date.now() / 1000;
                        if (timeout && currentTime > timeout) {
                            throw new Error("Timed out waiting for request " + requestId + ".");
                        }
                        if (currentTime > nextIncrease) {
                            waitPeriod *= 2;
                            nextIncrease = Date.now() / 1000 + waitPeriod * scaleup;
                            scaleup *= 2;
                        }
                        this.sleep(waitPeriod);
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    KubernetesApi.BAD_GATEWAY = 502;
    KubernetesApi.SERVICE_UNAVAILABLE = 503;
    KubernetesApi.GATEWAY_TIMEOUT = 504;
    KubernetesApi.TOO_MANY_REQUESTS = 429;
    KubernetesApi.maxRetries = 3;
    KubernetesApi.waitTime = 10;
    KubernetesApi.maxWaitTime = 2000;
    return KubernetesApi;
}());
exports.KubernetesApi = KubernetesApi;
