/* tslint:disable */
/* eslint-disable */
/**
 * CLOUD API
 * IONOS Enterprise-grade Infrastructure as a Service (IaaS) solutions can be managed through the Cloud API, in addition or as an alternative to the \"Data Center Designer\" (DCD) browser-based tool.    Both methods employ consistent concepts and features, deliver similar power and flexibility, and can be used to perform a multitude of management tasks, including adding servers, volumes, configuring networks, and so on.
 *
 * The version of the OpenAPI document: 6.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration, DEFAULT_MAX_RETRIES, DEFAULT_MAX_WAIT_TIME } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, backOff, runRequest } from '../base';
// @ts-ignore
import { AttachedVolumes } from '../model';
// @ts-ignore
import { Cdroms } from '../model';
// @ts-ignore
import { Image } from '../model';
// @ts-ignore
import { RemoteConsoleUrl } from '../model';
// @ts-ignore
import { Server } from '../model';
// @ts-ignore
import { ServerProperties } from '../model';
// @ts-ignore
import { Servers } from '../model';
// @ts-ignore
import { Token } from '../model';
// @ts-ignore
import { Volume } from '../model';
/**
 * ServersApi - axios parameter creator
 * @export
 */
export const ServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Detach the specified CD-ROM from the server.
         * @summary Detach CD-ROMs
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {string} cdromId The unique ID of the CD-ROM.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsDelete: async (datacenterId: string, serverId: string, cdromId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersCdromsDelete.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersCdromsDelete.');
            }
            // verify required parameter 'cdromId' is not null or undefined
            if (cdromId === null || cdromId === undefined) {
                throw new RequiredError('cdromId','Required parameter cdromId was null or undefined when calling datacentersServersCdromsDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/cdroms/{cdromId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"cdromId"}}`, encodeURIComponent(String(cdromId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the properties of the CD-ROM, attached to the specified server.
         * @summary Retrieve attached CD-ROMs
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {string} cdromId The unique ID of the CD-ROM.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsFindById: async (datacenterId: string, serverId: string, cdromId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersCdromsFindById.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersCdromsFindById.');
            }
            // verify required parameter 'cdromId' is not null or undefined
            if (cdromId === null || cdromId === undefined) {
                throw new RequiredError('cdromId','Required parameter cdromId was null or undefined when calling datacentersServersCdromsFindById.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/cdroms/{cdromId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"cdromId"}}`, encodeURIComponent(String(cdromId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List all CD-ROMs, attached to the specified server.
         * @summary List attached CD-ROMs 
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {number} [offset] The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
         * @param {number} [limit] The maximum number of elements to return (use together with offset for pagination).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsGet: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersCdromsGet.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersCdromsGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/cdroms`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach a CD-ROM to an existing server. Up to two CD-ROMs can be attached to the same server. 
         * @summary Attach CD-ROMs
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {Image} cdrom The CD-ROM to be attached.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsPost: async (datacenterId: string, serverId: string, cdrom: Image, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersCdromsPost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersCdromsPost.');
            }
            // verify required parameter 'cdrom' is not null or undefined
            if (cdrom === null || cdrom === undefined) {
                throw new RequiredError('cdrom','Required parameter cdrom was null or undefined when calling datacentersServersCdromsPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/cdroms`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof cdrom !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(cdrom !== undefined ? cdrom : {})
                : (cdrom || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified server in your data center. The attached storage volumes will not be removed — a separate API call must be made for these actions.
         * @summary Delete servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersDelete: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersDelete.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about the specified server within the data center, such as its configuration, provisioning status, and so on.
         * @summary Retrieve servers by ID
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersFindById: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersFindById.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersFindById.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List all servers within the data center.
         * @summary List servers 
         * @param {string} datacenterId The unique ID of the data center.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {boolean} [upgradeNeeded] Filter servers that can or that cannot be upgraded.
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {number} [offset] The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
         * @param {number} [limit] The maximum number of elements to return (use together with offset for pagination).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersGet: async (datacenterId: string, pretty?: boolean, depth?: number, upgradeNeeded?: boolean, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((upgradeNeeded === undefined) && (configuration !== undefined)) {
                upgradeNeeded = configuration.getDefaultParamValue('upgradeNeeded');
            }
            if (upgradeNeeded !== undefined) {
                localVarQueryParameter['upgradeNeeded'] = upgradeNeeded;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the properties of the specified server within the data center.
         * @summary Partially modify servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {ServerProperties} server The properties of the server to be updated.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersPatch: async (datacenterId: string, serverId: string, server: ServerProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersPatch.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersPatch.');
            }
            // verify required parameter 'server' is not null or undefined
            if (server === null || server === undefined) {
                throw new RequiredError('server','Required parameter server was null or undefined when calling datacentersServersPatch.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof server !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(server !== undefined ? server : {})
                : (server || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a server within the specified data center. You can also use this request to configure the boot volumes and connect to existing LANs at the same time.
         * @summary Create servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {Server} server The server to create.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersPost: async (datacenterId: string, server: Server, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersPost.');
            }
            // verify required parameter 'server' is not null or undefined
            if (server === null || server === undefined) {
                throw new RequiredError('server','Required parameter server was null or undefined when calling datacentersServersPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof server !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(server !== undefined ? server : {})
                : (server || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify the properties of the specified server within the data center.  Starting with v5, the \'allowReboot\' attribute is retired; while previously required for changing certain server properties, this behavior is now implicit, and the backend will perform this automatically. For example, in earlier versions, when the CPU family is changed, \'allowReboot\' had to be set to \'true\'; this is no longer required, the reboot will be performed automatically.
         * @summary Modify servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {Server} server The modified server
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersPut: async (datacenterId: string, serverId: string, server: Server, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersPut.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersPut.');
            }
            // verify required parameter 'server' is not null or undefined
            if (server === null || server === undefined) {
                throw new RequiredError('server','Required parameter server was null or undefined when calling datacentersServersPut.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof server !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(server !== undefined ? server : {})
                : (server || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Force a hard reboot of the specified server within the data center. Don\'t use this method if you wish to reboot gracefully. This is an equivalent of powering down a computer and turning it back on.
         * @summary Reboot servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersRebootPost: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersRebootPost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersRebootPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/reboot`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a link with a JSON Web Token for accessing the server\'s Remote Console.
         * @summary Get Remote Console link
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersRemoteConsoleGet: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersRemoteConsoleGet.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersRemoteConsoleGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/remoteconsole`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Resume a suspended Cube instance; no billing event will be generated.  This operation is only supported for the Cubes.
         * @summary Resume Cubes instances
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersResumePost: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersResumePost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersResumePost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/resume`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Start the specified server within the data center; if the server\'s public IP address has been deallocated, a new IP address will be assigned.
         * @summary Start servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersStartPost: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersStartPost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersStartPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/start`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop the specified server within the data center: the VM will be forcefully shut down, the billing will cease, and any allocated public IPs will be deallocated.  This operation is not supported for the Cubes.
         * @summary Stop VMs
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersStopPost: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersStopPost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersStopPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/stop`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Suspend the specified Cubes instance within the data center. The instance will not be deleted, and allocated resources will continue to be billed.  This operation is only supported for the Cubes.
         * @summary Suspend Cubes instances
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersSuspendPost: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersSuspendPost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersSuspendPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/suspend`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a JSON Web Token from the server for use in login operations (such as accessing the server\'s console).
         * @summary Get JASON Web Token
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersTokenGet: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersTokenGet.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersTokenGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/token`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Upgrade the server version, if needed. To determine if an upgrade is available, execute  the following call:  \'/datacenters/{datacenterId}/servers?upgradeNeeded=true\'
         * @summary Upgrade servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersUpgradePost: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersUpgradePost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersUpgradePost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/upgrade`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Detach the specified volume from the server without deleting it from the data center. A separate request must be made to perform the deletion.
         * @summary Detach volumes
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {string} volumeId The unique ID of the volume.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesDelete: async (datacenterId: string, serverId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersVolumesDelete.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersVolumesDelete.');
            }
            // verify required parameter 'volumeId' is not null or undefined
            if (volumeId === null || volumeId === undefined) {
                throw new RequiredError('volumeId','Required parameter volumeId was null or undefined when calling datacentersServersVolumesDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/volumes/{volumeId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"volumeId"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the properties of the volume, attached to the specified server.
         * @summary Retrieve attached volumes
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {string} volumeId The unique ID of the volume.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesFindById: async (datacenterId: string, serverId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersVolumesFindById.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersVolumesFindById.');
            }
            // verify required parameter 'volumeId' is not null or undefined
            if (volumeId === null || volumeId === undefined) {
                throw new RequiredError('volumeId','Required parameter volumeId was null or undefined when calling datacentersServersVolumesFindById.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/volumes/{volumeId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"volumeId"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List all volumes, attached to the specified server.
         * @summary List attached volumes
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {number} [offset] The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
         * @param {number} [limit] The maximum number of elements to return (use together with offset for pagination).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesGet: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersVolumesGet.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersVolumesGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/volumes`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach an existing storage volume to the specified server.  A volume scan also be created and attached in one step by providing the new volume description as payload.  The combined total of attached volumes and NICs cannot exceed 24 per server.
         * @summary Attach volumes
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {Volume} volume The volume to be attached (or created and attached).
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesPost: async (datacenterId: string, serverId: string, volume: Volume, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersVolumesPost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersVolumesPost.');
            }
            // verify required parameter 'volume' is not null or undefined
            if (volume === null || volume === undefined) {
                throw new RequiredError('volume','Required parameter volume was null or undefined when calling datacentersServersVolumesPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/volumes`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof volume !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(volume !== undefined ? volume : {})
                : (volume || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServersApi - functional programming interface
 * @export
 */
export const ServersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Detach the specified CD-ROM from the server.
         * @summary Detach CD-ROMs
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {string} cdromId The unique ID of the CD-ROM.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersCdromsDelete(datacenterId: string, serverId: string, cdromId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersCdromsDelete(datacenterId, serverId, cdromId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieve the properties of the CD-ROM, attached to the specified server.
         * @summary Retrieve attached CD-ROMs
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {string} cdromId The unique ID of the CD-ROM.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersCdromsFindById(datacenterId: string, serverId: string, cdromId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersCdromsFindById(datacenterId, serverId, cdromId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * List all CD-ROMs, attached to the specified server.
         * @summary List attached CD-ROMs 
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {number} [offset] The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
         * @param {number} [limit] The maximum number of elements to return (use together with offset for pagination).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersCdromsGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cdroms>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersCdromsGet(datacenterId, serverId, pretty, depth, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Attach a CD-ROM to an existing server. Up to two CD-ROMs can be attached to the same server. 
         * @summary Attach CD-ROMs
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {Image} cdrom The CD-ROM to be attached.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersCdromsPost(datacenterId: string, serverId: string, cdrom: Image, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersCdromsPost(datacenterId, serverId, cdrom, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Delete the specified server in your data center. The attached storage volumes will not be removed — a separate API call must be made for these actions.
         * @summary Delete servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersDelete(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersDelete(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieve information about the specified server within the data center, such as its configuration, provisioning status, and so on.
         * @summary Retrieve servers by ID
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersFindById(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Server>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersFindById(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * List all servers within the data center.
         * @summary List servers 
         * @param {string} datacenterId The unique ID of the data center.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {boolean} [upgradeNeeded] Filter servers that can or that cannot be upgraded.
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {number} [offset] The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
         * @param {number} [limit] The maximum number of elements to return (use together with offset for pagination).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersGet(datacenterId: string, pretty?: boolean, depth?: number, upgradeNeeded?: boolean, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Servers>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersGet(datacenterId, pretty, depth, upgradeNeeded, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Update the properties of the specified server within the data center.
         * @summary Partially modify servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {ServerProperties} server The properties of the server to be updated.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersPatch(datacenterId: string, serverId: string, server: ServerProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Server>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersPatch(datacenterId, serverId, server, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Create a server within the specified data center. You can also use this request to configure the boot volumes and connect to existing LANs at the same time.
         * @summary Create servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {Server} server The server to create.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersPost(datacenterId: string, server: Server, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Server>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersPost(datacenterId, server, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Modify the properties of the specified server within the data center.  Starting with v5, the \'allowReboot\' attribute is retired; while previously required for changing certain server properties, this behavior is now implicit, and the backend will perform this automatically. For example, in earlier versions, when the CPU family is changed, \'allowReboot\' had to be set to \'true\'; this is no longer required, the reboot will be performed automatically.
         * @summary Modify servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {Server} server The modified server
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersPut(datacenterId: string, serverId: string, server: Server, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Server>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersPut(datacenterId, serverId, server, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Force a hard reboot of the specified server within the data center. Don\'t use this method if you wish to reboot gracefully. This is an equivalent of powering down a computer and turning it back on.
         * @summary Reboot servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersRebootPost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersRebootPost(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieve a link with a JSON Web Token for accessing the server\'s Remote Console.
         * @summary Get Remote Console link
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersRemoteConsoleGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteConsoleUrl>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersRemoteConsoleGet(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Resume a suspended Cube instance; no billing event will be generated.  This operation is only supported for the Cubes.
         * @summary Resume Cubes instances
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersResumePost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersResumePost(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Start the specified server within the data center; if the server\'s public IP address has been deallocated, a new IP address will be assigned.
         * @summary Start servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersStartPost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersStartPost(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Stop the specified server within the data center: the VM will be forcefully shut down, the billing will cease, and any allocated public IPs will be deallocated.  This operation is not supported for the Cubes.
         * @summary Stop VMs
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersStopPost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersStopPost(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Suspend the specified Cubes instance within the data center. The instance will not be deleted, and allocated resources will continue to be billed.  This operation is only supported for the Cubes.
         * @summary Suspend Cubes instances
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersSuspendPost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersSuspendPost(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieve a JSON Web Token from the server for use in login operations (such as accessing the server\'s console).
         * @summary Get JASON Web Token
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersTokenGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersTokenGet(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Upgrade the server version, if needed. To determine if an upgrade is available, execute  the following call:  \'/datacenters/{datacenterId}/servers?upgradeNeeded=true\'
         * @summary Upgrade servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersUpgradePost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersUpgradePost(datacenterId, serverId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Detach the specified volume from the server without deleting it from the data center. A separate request must be made to perform the deletion.
         * @summary Detach volumes
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {string} volumeId The unique ID of the volume.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersVolumesDelete(datacenterId: string, serverId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersVolumesDelete(datacenterId, serverId, volumeId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieve the properties of the volume, attached to the specified server.
         * @summary Retrieve attached volumes
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {string} volumeId The unique ID of the volume.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersVolumesFindById(datacenterId: string, serverId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersVolumesFindById(datacenterId, serverId, volumeId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * List all volumes, attached to the specified server.
         * @summary List attached volumes
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {number} [offset] The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
         * @param {number} [limit] The maximum number of elements to return (use together with offset for pagination).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersVolumesGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachedVolumes>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersVolumesGet(datacenterId, serverId, pretty, depth, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Attach an existing storage volume to the specified server.  A volume scan also be created and attached in one step by providing the new volume description as payload.  The combined total of attached volumes and NICs cannot exceed 24 per server.
         * @summary Attach volumes
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {Volume} volume The volume to be attached (or created and attached).
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersVolumesPost(datacenterId: string, serverId: string, volume: Volume, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
            const axiosArgs = await ServersApiAxiosParamCreator(configuration).datacentersServersVolumesPost(datacenterId, serverId, volume, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
    }
};

/**
 * ServersApi - factory interface
 * @export
 */
export const ServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Detach the specified CD-ROM from the server.
         * @summary Detach CD-ROMs
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {string} cdromId The unique ID of the CD-ROM.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsDelete(datacenterId: string, serverId: string, cdromId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<void> {
            return ServersApiFp(configuration).datacentersServersCdromsDelete(datacenterId, serverId, cdromId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the properties of the CD-ROM, attached to the specified server.
         * @summary Retrieve attached CD-ROMs
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {string} cdromId The unique ID of the CD-ROM.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsFindById(datacenterId: string, serverId: string, cdromId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Image> {
            return ServersApiFp(configuration).datacentersServersCdromsFindById(datacenterId, serverId, cdromId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * List all CD-ROMs, attached to the specified server.
         * @summary List attached CD-ROMs 
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {number} [offset] The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
         * @param {number} [limit] The maximum number of elements to return (use together with offset for pagination).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<Cdroms> {
            return ServersApiFp(configuration).datacentersServersCdromsGet(datacenterId, serverId, pretty, depth, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Attach a CD-ROM to an existing server. Up to two CD-ROMs can be attached to the same server. 
         * @summary Attach CD-ROMs
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {Image} cdrom The CD-ROM to be attached.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersCdromsPost(datacenterId: string, serverId: string, cdrom: Image, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Image> {
            return ServersApiFp(configuration).datacentersServersCdromsPost(datacenterId, serverId, cdrom, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the specified server in your data center. The attached storage volumes will not be removed — a separate API call must be made for these actions.
         * @summary Delete servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersDelete(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<void> {
            return ServersApiFp(configuration).datacentersServersDelete(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve information about the specified server within the data center, such as its configuration, provisioning status, and so on.
         * @summary Retrieve servers by ID
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersFindById(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Server> {
            return ServersApiFp(configuration).datacentersServersFindById(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * List all servers within the data center.
         * @summary List servers 
         * @param {string} datacenterId The unique ID of the data center.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {boolean} [upgradeNeeded] Filter servers that can or that cannot be upgraded.
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {number} [offset] The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
         * @param {number} [limit] The maximum number of elements to return (use together with offset for pagination).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersGet(datacenterId: string, pretty?: boolean, depth?: number, upgradeNeeded?: boolean, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<Servers> {
            return ServersApiFp(configuration).datacentersServersGet(datacenterId, pretty, depth, upgradeNeeded, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the properties of the specified server within the data center.
         * @summary Partially modify servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {ServerProperties} server The properties of the server to be updated.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersPatch(datacenterId: string, serverId: string, server: ServerProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Server> {
            return ServersApiFp(configuration).datacentersServersPatch(datacenterId, serverId, server, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a server within the specified data center. You can also use this request to configure the boot volumes and connect to existing LANs at the same time.
         * @summary Create servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {Server} server The server to create.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersPost(datacenterId: string, server: Server, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Server> {
            return ServersApiFp(configuration).datacentersServersPost(datacenterId, server, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify the properties of the specified server within the data center.  Starting with v5, the \'allowReboot\' attribute is retired; while previously required for changing certain server properties, this behavior is now implicit, and the backend will perform this automatically. For example, in earlier versions, when the CPU family is changed, \'allowReboot\' had to be set to \'true\'; this is no longer required, the reboot will be performed automatically.
         * @summary Modify servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {Server} server The modified server
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersPut(datacenterId: string, serverId: string, server: Server, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Server> {
            return ServersApiFp(configuration).datacentersServersPut(datacenterId, serverId, server, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Force a hard reboot of the specified server within the data center. Don\'t use this method if you wish to reboot gracefully. This is an equivalent of powering down a computer and turning it back on.
         * @summary Reboot servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersRebootPost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<void> {
            return ServersApiFp(configuration).datacentersServersRebootPost(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a link with a JSON Web Token for accessing the server\'s Remote Console.
         * @summary Get Remote Console link
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersRemoteConsoleGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<RemoteConsoleUrl> {
            return ServersApiFp(configuration).datacentersServersRemoteConsoleGet(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Resume a suspended Cube instance; no billing event will be generated.  This operation is only supported for the Cubes.
         * @summary Resume Cubes instances
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersResumePost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<void> {
            return ServersApiFp(configuration).datacentersServersResumePost(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Start the specified server within the data center; if the server\'s public IP address has been deallocated, a new IP address will be assigned.
         * @summary Start servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersStartPost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<void> {
            return ServersApiFp(configuration).datacentersServersStartPost(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop the specified server within the data center: the VM will be forcefully shut down, the billing will cease, and any allocated public IPs will be deallocated.  This operation is not supported for the Cubes.
         * @summary Stop VMs
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersStopPost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<void> {
            return ServersApiFp(configuration).datacentersServersStopPost(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Suspend the specified Cubes instance within the data center. The instance will not be deleted, and allocated resources will continue to be billed.  This operation is only supported for the Cubes.
         * @summary Suspend Cubes instances
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersSuspendPost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<void> {
            return ServersApiFp(configuration).datacentersServersSuspendPost(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a JSON Web Token from the server for use in login operations (such as accessing the server\'s console).
         * @summary Get JASON Web Token
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersTokenGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Token> {
            return ServersApiFp(configuration).datacentersServersTokenGet(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Upgrade the server version, if needed. To determine if an upgrade is available, execute  the following call:  \'/datacenters/{datacenterId}/servers?upgradeNeeded=true\'
         * @summary Upgrade servers
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersUpgradePost(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<void> {
            return ServersApiFp(configuration).datacentersServersUpgradePost(datacenterId, serverId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Detach the specified volume from the server without deleting it from the data center. A separate request must be made to perform the deletion.
         * @summary Detach volumes
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {string} volumeId The unique ID of the volume.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesDelete(datacenterId: string, serverId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<void> {
            return ServersApiFp(configuration).datacentersServersVolumesDelete(datacenterId, serverId, volumeId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the properties of the volume, attached to the specified server.
         * @summary Retrieve attached volumes
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {string} volumeId The unique ID of the volume.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesFindById(datacenterId: string, serverId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Volume> {
            return ServersApiFp(configuration).datacentersServersVolumesFindById(datacenterId, serverId, volumeId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * List all volumes, attached to the specified server.
         * @summary List attached volumes
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {number} [offset] The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
         * @param {number} [limit] The maximum number of elements to return (use together with offset for pagination).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<AttachedVolumes> {
            return ServersApiFp(configuration).datacentersServersVolumesGet(datacenterId, serverId, pretty, depth, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Attach an existing storage volume to the specified server.  A volume scan also be created and attached in one step by providing the new volume description as payload.  The combined total of attached volumes and NICs cannot exceed 24 per server.
         * @summary Attach volumes
         * @param {string} datacenterId The unique ID of the data center.
         * @param {string} serverId The unique ID of the server.
         * @param {Volume} volume The volume to be attached (or created and attached).
         * @param {boolean} [pretty] Controls whether the response is pretty-printed (with indentations and new lines).
         * @param {number} [depth] Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersVolumesPost(datacenterId: string, serverId: string, volume: Volume, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Volume> {
            return ServersApiFp(configuration).datacentersServersVolumesPost(datacenterId, serverId, volume, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for datacentersServersCdromsDelete operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersCdromsDeleteRequest
 */
export interface ServersApiDatacentersServersCdromsDeleteRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersCdromsDelete
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersCdromsDelete
     */
    readonly serverId: string

    /**
     * The unique ID of the CD-ROM.
     * @type {string}
     * @memberof ServersApiDatacentersServersCdromsDelete
     */
    readonly cdromId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersCdromsDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersCdromsDelete
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersCdromsDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersCdromsFindById operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersCdromsFindByIdRequest
 */
export interface ServersApiDatacentersServersCdromsFindByIdRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersCdromsFindById
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersCdromsFindById
     */
    readonly serverId: string

    /**
     * The unique ID of the CD-ROM.
     * @type {string}
     * @memberof ServersApiDatacentersServersCdromsFindById
     */
    readonly cdromId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersCdromsFindById
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersCdromsFindById
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersCdromsFindById
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersCdromsGet operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersCdromsGetRequest
 */
export interface ServersApiDatacentersServersCdromsGetRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersCdromsGet
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersCdromsGet
     */
    readonly serverId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersCdromsGet
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersCdromsGet
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersCdromsGet
     */
    readonly xContractNumber?: number

    /**
     * The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
     * @type {number}
     * @memberof ServersApiDatacentersServersCdromsGet
     */
    readonly offset?: number

    /**
     * The maximum number of elements to return (use together with offset for pagination).
     * @type {number}
     * @memberof ServersApiDatacentersServersCdromsGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersServersCdromsPost operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersCdromsPostRequest
 */
export interface ServersApiDatacentersServersCdromsPostRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersCdromsPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersCdromsPost
     */
    readonly serverId: string

    /**
     * The CD-ROM to be attached.
     * @type {Image}
     * @memberof ServersApiDatacentersServersCdromsPost
     */
    readonly cdrom: Image

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersCdromsPost
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersCdromsPost
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersCdromsPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersDelete operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersDeleteRequest
 */
export interface ServersApiDatacentersServersDeleteRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersDelete
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersDelete
     */
    readonly serverId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersDelete
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersFindById operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersFindByIdRequest
 */
export interface ServersApiDatacentersServersFindByIdRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersFindById
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersFindById
     */
    readonly serverId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersFindById
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersFindById
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersFindById
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersGet operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersGetRequest
 */
export interface ServersApiDatacentersServersGetRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersGet
     */
    readonly datacenterId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersGet
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersGet
     */
    readonly depth?: number

    /**
     * Filter servers that can or that cannot be upgraded.
     * @type {boolean}
     * @memberof ServersApiDatacentersServersGet
     */
    readonly upgradeNeeded?: boolean

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersGet
     */
    readonly xContractNumber?: number

    /**
     * The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
     * @type {number}
     * @memberof ServersApiDatacentersServersGet
     */
    readonly offset?: number

    /**
     * The maximum number of elements to return (use together with offset for pagination).
     * @type {number}
     * @memberof ServersApiDatacentersServersGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersServersPatch operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersPatchRequest
 */
export interface ServersApiDatacentersServersPatchRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersPatch
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersPatch
     */
    readonly serverId: string

    /**
     * The properties of the server to be updated.
     * @type {ServerProperties}
     * @memberof ServersApiDatacentersServersPatch
     */
    readonly server: ServerProperties

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersPatch
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersPatch
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersPatch
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersPost operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersPostRequest
 */
export interface ServersApiDatacentersServersPostRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersPost
     */
    readonly datacenterId: string

    /**
     * The server to create.
     * @type {Server}
     * @memberof ServersApiDatacentersServersPost
     */
    readonly server: Server

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersPost
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersPost
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersPut operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersPutRequest
 */
export interface ServersApiDatacentersServersPutRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersPut
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersPut
     */
    readonly serverId: string

    /**
     * The modified server
     * @type {Server}
     * @memberof ServersApiDatacentersServersPut
     */
    readonly server: Server

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersPut
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersPut
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersPut
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersRebootPost operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersRebootPostRequest
 */
export interface ServersApiDatacentersServersRebootPostRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersRebootPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersRebootPost
     */
    readonly serverId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersRebootPost
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersRebootPost
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersRebootPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersRemoteConsoleGet operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersRemoteConsoleGetRequest
 */
export interface ServersApiDatacentersServersRemoteConsoleGetRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersRemoteConsoleGet
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersRemoteConsoleGet
     */
    readonly serverId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersRemoteConsoleGet
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersRemoteConsoleGet
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersRemoteConsoleGet
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersResumePost operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersResumePostRequest
 */
export interface ServersApiDatacentersServersResumePostRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersResumePost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersResumePost
     */
    readonly serverId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersResumePost
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersResumePost
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersResumePost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersStartPost operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersStartPostRequest
 */
export interface ServersApiDatacentersServersStartPostRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersStartPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersStartPost
     */
    readonly serverId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersStartPost
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersStartPost
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersStartPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersStopPost operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersStopPostRequest
 */
export interface ServersApiDatacentersServersStopPostRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersStopPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersStopPost
     */
    readonly serverId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersStopPost
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersStopPost
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersStopPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersSuspendPost operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersSuspendPostRequest
 */
export interface ServersApiDatacentersServersSuspendPostRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersSuspendPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersSuspendPost
     */
    readonly serverId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersSuspendPost
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersSuspendPost
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersSuspendPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersTokenGet operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersTokenGetRequest
 */
export interface ServersApiDatacentersServersTokenGetRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersTokenGet
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersTokenGet
     */
    readonly serverId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersTokenGet
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersTokenGet
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersTokenGet
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersUpgradePost operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersUpgradePostRequest
 */
export interface ServersApiDatacentersServersUpgradePostRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersUpgradePost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersUpgradePost
     */
    readonly serverId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersUpgradePost
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersUpgradePost
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersUpgradePost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersVolumesDelete operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersVolumesDeleteRequest
 */
export interface ServersApiDatacentersServersVolumesDeleteRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersVolumesDelete
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersVolumesDelete
     */
    readonly serverId: string

    /**
     * The unique ID of the volume.
     * @type {string}
     * @memberof ServersApiDatacentersServersVolumesDelete
     */
    readonly volumeId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersVolumesDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersVolumesDelete
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersVolumesDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersVolumesFindById operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersVolumesFindByIdRequest
 */
export interface ServersApiDatacentersServersVolumesFindByIdRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersVolumesFindById
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersVolumesFindById
     */
    readonly serverId: string

    /**
     * The unique ID of the volume.
     * @type {string}
     * @memberof ServersApiDatacentersServersVolumesFindById
     */
    readonly volumeId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersVolumesFindById
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersVolumesFindById
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersVolumesFindById
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersVolumesGet operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersVolumesGetRequest
 */
export interface ServersApiDatacentersServersVolumesGetRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersVolumesGet
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersVolumesGet
     */
    readonly serverId: string

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersVolumesGet
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersVolumesGet
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersVolumesGet
     */
    readonly xContractNumber?: number

    /**
     * The first element (from the complete list of the elements) to include in the response (use together with limit for pagination).
     * @type {number}
     * @memberof ServersApiDatacentersServersVolumesGet
     */
    readonly offset?: number

    /**
     * The maximum number of elements to return (use together with offset for pagination).
     * @type {number}
     * @memberof ServersApiDatacentersServersVolumesGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersServersVolumesPost operation in ServersApi.
 * @export
 * @interface ServersApiDatacentersServersVolumesPostRequest
 */
export interface ServersApiDatacentersServersVolumesPostRequest {
    /**
     * The unique ID of the data center.
     * @type {string}
     * @memberof ServersApiDatacentersServersVolumesPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the server.
     * @type {string}
     * @memberof ServersApiDatacentersServersVolumesPost
     */
    readonly serverId: string

    /**
     * The volume to be attached (or created and attached).
     * @type {Volume}
     * @memberof ServersApiDatacentersServersVolumesPost
     */
    readonly volume: Volume

    /**
     * Controls whether the response is pretty-printed (with indentations and new lines).
     * @type {boolean}
     * @memberof ServersApiDatacentersServersVolumesPost
     */
    readonly pretty?: boolean

    /**
     * Controls the detail depth of the response objects.  GET /datacenters/[ID]  - depth&#x3D;0: Only direct properties are included; children (servers and other elements) are not included.  - depth&#x3D;1: Direct properties and children references are included.  - depth&#x3D;2: Direct properties and children properties are included.  - depth&#x3D;3: Direct properties and children properties and children\&#39;s children are included.  - depth&#x3D;... and so on
     * @type {number}
     * @memberof ServersApiDatacentersServersVolumesPost
     */
    readonly depth?: number

    /**
     * Users with multiple contracts must provide the contract number, against which all API requests are to be executed.
     * @type {number}
     * @memberof ServersApiDatacentersServersVolumesPost
     */
    readonly xContractNumber?: number
}

/**
 * ServersApi - object-oriented interface
 * @export
 * @class ServersApi
 * @extends {BaseAPI}
 */
export class ServersApi extends BaseAPI {
    /**
     * Detach the specified CD-ROM from the server.
     * @summary Detach CD-ROMs
     * @param {ServersApiDatacentersServersCdromsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersCdromsDelete(requestParameters: ServersApiDatacentersServersCdromsDeleteRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersCdromsDelete(requestParameters.datacenterId, requestParameters.serverId, requestParameters.cdromId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the properties of the CD-ROM, attached to the specified server.
     * @summary Retrieve attached CD-ROMs
     * @param {ServersApiDatacentersServersCdromsFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersCdromsFindById(requestParameters: ServersApiDatacentersServersCdromsFindByIdRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersCdromsFindById(requestParameters.datacenterId, requestParameters.serverId, requestParameters.cdromId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all CD-ROMs, attached to the specified server.
     * @summary List attached CD-ROMs 
     * @param {ServersApiDatacentersServersCdromsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersCdromsGet(requestParameters: ServersApiDatacentersServersCdromsGetRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersCdromsGet(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attach a CD-ROM to an existing server. Up to two CD-ROMs can be attached to the same server. 
     * @summary Attach CD-ROMs
     * @param {ServersApiDatacentersServersCdromsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersCdromsPost(requestParameters: ServersApiDatacentersServersCdromsPostRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersCdromsPost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.cdrom, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the specified server in your data center. The attached storage volumes will not be removed — a separate API call must be made for these actions.
     * @summary Delete servers
     * @param {ServersApiDatacentersServersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersDelete(requestParameters: ServersApiDatacentersServersDeleteRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersDelete(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve information about the specified server within the data center, such as its configuration, provisioning status, and so on.
     * @summary Retrieve servers by ID
     * @param {ServersApiDatacentersServersFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersFindById(requestParameters: ServersApiDatacentersServersFindByIdRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersFindById(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all servers within the data center.
     * @summary List servers 
     * @param {ServersApiDatacentersServersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersGet(requestParameters: ServersApiDatacentersServersGetRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersGet(requestParameters.datacenterId, requestParameters.pretty, requestParameters.depth, requestParameters.upgradeNeeded, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the properties of the specified server within the data center.
     * @summary Partially modify servers
     * @param {ServersApiDatacentersServersPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersPatch(requestParameters: ServersApiDatacentersServersPatchRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersPatch(requestParameters.datacenterId, requestParameters.serverId, requestParameters.server, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a server within the specified data center. You can also use this request to configure the boot volumes and connect to existing LANs at the same time.
     * @summary Create servers
     * @param {ServersApiDatacentersServersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersPost(requestParameters: ServersApiDatacentersServersPostRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersPost(requestParameters.datacenterId, requestParameters.server, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify the properties of the specified server within the data center.  Starting with v5, the \'allowReboot\' attribute is retired; while previously required for changing certain server properties, this behavior is now implicit, and the backend will perform this automatically. For example, in earlier versions, when the CPU family is changed, \'allowReboot\' had to be set to \'true\'; this is no longer required, the reboot will be performed automatically.
     * @summary Modify servers
     * @param {ServersApiDatacentersServersPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersPut(requestParameters: ServersApiDatacentersServersPutRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersPut(requestParameters.datacenterId, requestParameters.serverId, requestParameters.server, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Force a hard reboot of the specified server within the data center. Don\'t use this method if you wish to reboot gracefully. This is an equivalent of powering down a computer and turning it back on.
     * @summary Reboot servers
     * @param {ServersApiDatacentersServersRebootPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersRebootPost(requestParameters: ServersApiDatacentersServersRebootPostRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersRebootPost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a link with a JSON Web Token for accessing the server\'s Remote Console.
     * @summary Get Remote Console link
     * @param {ServersApiDatacentersServersRemoteConsoleGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersRemoteConsoleGet(requestParameters: ServersApiDatacentersServersRemoteConsoleGetRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersRemoteConsoleGet(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resume a suspended Cube instance; no billing event will be generated.  This operation is only supported for the Cubes.
     * @summary Resume Cubes instances
     * @param {ServersApiDatacentersServersResumePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersResumePost(requestParameters: ServersApiDatacentersServersResumePostRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersResumePost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start the specified server within the data center; if the server\'s public IP address has been deallocated, a new IP address will be assigned.
     * @summary Start servers
     * @param {ServersApiDatacentersServersStartPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersStartPost(requestParameters: ServersApiDatacentersServersStartPostRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersStartPost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop the specified server within the data center: the VM will be forcefully shut down, the billing will cease, and any allocated public IPs will be deallocated.  This operation is not supported for the Cubes.
     * @summary Stop VMs
     * @param {ServersApiDatacentersServersStopPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersStopPost(requestParameters: ServersApiDatacentersServersStopPostRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersStopPost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Suspend the specified Cubes instance within the data center. The instance will not be deleted, and allocated resources will continue to be billed.  This operation is only supported for the Cubes.
     * @summary Suspend Cubes instances
     * @param {ServersApiDatacentersServersSuspendPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersSuspendPost(requestParameters: ServersApiDatacentersServersSuspendPostRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersSuspendPost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a JSON Web Token from the server for use in login operations (such as accessing the server\'s console).
     * @summary Get JASON Web Token
     * @param {ServersApiDatacentersServersTokenGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersTokenGet(requestParameters: ServersApiDatacentersServersTokenGetRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersTokenGet(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upgrade the server version, if needed. To determine if an upgrade is available, execute  the following call:  \'/datacenters/{datacenterId}/servers?upgradeNeeded=true\'
     * @summary Upgrade servers
     * @param {ServersApiDatacentersServersUpgradePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersUpgradePost(requestParameters: ServersApiDatacentersServersUpgradePostRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersUpgradePost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detach the specified volume from the server without deleting it from the data center. A separate request must be made to perform the deletion.
     * @summary Detach volumes
     * @param {ServersApiDatacentersServersVolumesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersVolumesDelete(requestParameters: ServersApiDatacentersServersVolumesDeleteRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersVolumesDelete(requestParameters.datacenterId, requestParameters.serverId, requestParameters.volumeId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the properties of the volume, attached to the specified server.
     * @summary Retrieve attached volumes
     * @param {ServersApiDatacentersServersVolumesFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersVolumesFindById(requestParameters: ServersApiDatacentersServersVolumesFindByIdRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersVolumesFindById(requestParameters.datacenterId, requestParameters.serverId, requestParameters.volumeId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all volumes, attached to the specified server.
     * @summary List attached volumes
     * @param {ServersApiDatacentersServersVolumesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersVolumesGet(requestParameters: ServersApiDatacentersServersVolumesGetRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersVolumesGet(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attach an existing storage volume to the specified server.  A volume scan also be created and attached in one step by providing the new volume description as payload.  The combined total of attached volumes and NICs cannot exceed 24 per server.
     * @summary Attach volumes
     * @param {ServersApiDatacentersServersVolumesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public datacentersServersVolumesPost(requestParameters: ServersApiDatacentersServersVolumesPostRequest, options?: any) {
        return ServersApiFp(this.configuration).datacentersServersVolumesPost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.volume, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }
}
