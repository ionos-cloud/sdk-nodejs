/* tslint:disable */
/* eslint-disable */
/**
 * CLOUD API
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * The version of the OpenAPI document: 5.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration, DEFAULT_MAX_RETRIES, DEFAULT_MAX_WAIT_TIME } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, backOff, runRequest } from '../base';
// @ts-ignore
import { KubernetesCluster } from '../model';
// @ts-ignore
import { KubernetesClusterForPost } from '../model';
// @ts-ignore
import { KubernetesClusterForPut } from '../model';
// @ts-ignore
import { KubernetesClusters } from '../model';
// @ts-ignore
import { KubernetesConfig } from '../model';
// @ts-ignore
import { KubernetesNode } from '../model';
// @ts-ignore
import { KubernetesNodePool } from '../model';
// @ts-ignore
import { KubernetesNodePoolForPost } from '../model';
// @ts-ignore
import { KubernetesNodePoolForPut } from '../model';
// @ts-ignore
import { KubernetesNodePools } from '../model';
// @ts-ignore
import { KubernetesNodes } from '../model';
/**
 * KubernetesApi - axios parameter creator
 * @export
 */
export const KubernetesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will remove a Kubernetes Cluster.
         * @summary Delete Kubernetes Cluster
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sDelete: async (k8sClusterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8sClusterId' is not null or undefined
            if (k8sClusterId === null || k8sClusterId === undefined) {
                throw new RequiredError('k8sClusterId','Required parameter k8sClusterId was null or undefined when calling k8sDelete.');
            }
            const localVarPath = `/k8s/{k8sClusterId}`
                .replace(`{${"k8sClusterId"}}`, encodeURIComponent(String(k8sClusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will retrieve a single Kubernetes Cluster.
         * @summary Retrieve Kubernetes Cluster
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sFindByClusterId: async (k8sClusterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8sClusterId' is not null or undefined
            if (k8sClusterId === null || k8sClusterId === undefined) {
                throw new RequiredError('k8sClusterId','Required parameter k8sClusterId was null or undefined when calling k8sFindByClusterId.');
            }
            const localVarPath = `/k8s/{k8sClusterId}`
                .replace(`{${"k8sClusterId"}}`, encodeURIComponent(String(k8sClusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a list of all kubernetes clusters associated with a contract
         * @summary List Kubernetes Clusters
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sGet: async (pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/k8s`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve kubernetes configuration file for the kubernetes cluster.
         * @summary Retrieve Kubernetes Configuration File
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sKubeconfigGet: async (k8sClusterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8sClusterId' is not null or undefined
            if (k8sClusterId === null || k8sClusterId === undefined) {
                throw new RequiredError('k8sClusterId','Required parameter k8sClusterId was null or undefined when calling k8sKubeconfigGet.');
            }
            const localVarPath = `/k8s/{k8sClusterId}/kubeconfig`
                .replace(`{${"k8sClusterId"}}`, encodeURIComponent(String(k8sClusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will remove a Kubernetes Node Pool.
         * @summary Delete Kubernetes Node Pool
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsDelete: async (k8sClusterId: string, nodepoolId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8sClusterId' is not null or undefined
            if (k8sClusterId === null || k8sClusterId === undefined) {
                throw new RequiredError('k8sClusterId','Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsDelete.');
            }
            // verify required parameter 'nodepoolId' is not null or undefined
            if (nodepoolId === null || nodepoolId === undefined) {
                throw new RequiredError('nodepoolId','Required parameter nodepoolId was null or undefined when calling k8sNodepoolsDelete.');
            }
            const localVarPath = `/k8s/{k8sClusterId}/nodepools/{nodepoolId}`
                .replace(`{${"k8sClusterId"}}`, encodeURIComponent(String(k8sClusterId)))
                .replace(`{${"nodepoolId"}}`, encodeURIComponent(String(nodepoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a single Kubernetes Node Pool.
         * @summary Retrieve Kubernetes Node Pool
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsFindById: async (k8sClusterId: string, nodepoolId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8sClusterId' is not null or undefined
            if (k8sClusterId === null || k8sClusterId === undefined) {
                throw new RequiredError('k8sClusterId','Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsFindById.');
            }
            // verify required parameter 'nodepoolId' is not null or undefined
            if (nodepoolId === null || nodepoolId === undefined) {
                throw new RequiredError('nodepoolId','Required parameter nodepoolId was null or undefined when calling k8sNodepoolsFindById.');
            }
            const localVarPath = `/k8s/{k8sClusterId}/nodepools/{nodepoolId}`
                .replace(`{${"k8sClusterId"}}`, encodeURIComponent(String(k8sClusterId)))
                .replace(`{${"nodepoolId"}}`, encodeURIComponent(String(nodepoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a list of all kubernetes node pools part of kubernetes cluster
         * @summary List Kubernetes Node Pools
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsGet: async (k8sClusterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8sClusterId' is not null or undefined
            if (k8sClusterId === null || k8sClusterId === undefined) {
                throw new RequiredError('k8sClusterId','Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsGet.');
            }
            const localVarPath = `/k8s/{k8sClusterId}/nodepools`
                .replace(`{${"k8sClusterId"}}`, encodeURIComponent(String(k8sClusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will remove a Kubernetes node.
         * @summary Delete Kubernetes node
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {string} nodeId The unique ID of the Kubernetes node
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsNodesDelete: async (k8sClusterId: string, nodepoolId: string, nodeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8sClusterId' is not null or undefined
            if (k8sClusterId === null || k8sClusterId === undefined) {
                throw new RequiredError('k8sClusterId','Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsNodesDelete.');
            }
            // verify required parameter 'nodepoolId' is not null or undefined
            if (nodepoolId === null || nodepoolId === undefined) {
                throw new RequiredError('nodepoolId','Required parameter nodepoolId was null or undefined when calling k8sNodepoolsNodesDelete.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling k8sNodepoolsNodesDelete.');
            }
            const localVarPath = `/k8s/{k8sClusterId}/nodepools/{nodepoolId}/nodes/{nodeId}`
                .replace(`{${"k8sClusterId"}}`, encodeURIComponent(String(k8sClusterId)))
                .replace(`{${"nodepoolId"}}`, encodeURIComponent(String(nodepoolId)))
                .replace(`{${"nodeId"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a single Kubernetes Node.
         * @summary Retrieve Kubernetes node
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {string} nodeId The unique ID of the Kubernetes Node.
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsNodesFindById: async (k8sClusterId: string, nodepoolId: string, nodeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8sClusterId' is not null or undefined
            if (k8sClusterId === null || k8sClusterId === undefined) {
                throw new RequiredError('k8sClusterId','Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsNodesFindById.');
            }
            // verify required parameter 'nodepoolId' is not null or undefined
            if (nodepoolId === null || nodepoolId === undefined) {
                throw new RequiredError('nodepoolId','Required parameter nodepoolId was null or undefined when calling k8sNodepoolsNodesFindById.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling k8sNodepoolsNodesFindById.');
            }
            const localVarPath = `/k8s/{k8sClusterId}/nodepools/{nodepoolId}/nodes/{nodeId}`
                .replace(`{${"k8sClusterId"}}`, encodeURIComponent(String(k8sClusterId)))
                .replace(`{${"nodepoolId"}}`, encodeURIComponent(String(nodepoolId)))
                .replace(`{${"nodeId"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve all nodes of Kubernetes Node Pool.
         * @summary Retrieve Kubernetes nodes.
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsNodesGet: async (k8sClusterId: string, nodepoolId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8sClusterId' is not null or undefined
            if (k8sClusterId === null || k8sClusterId === undefined) {
                throw new RequiredError('k8sClusterId','Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsNodesGet.');
            }
            // verify required parameter 'nodepoolId' is not null or undefined
            if (nodepoolId === null || nodepoolId === undefined) {
                throw new RequiredError('nodepoolId','Required parameter nodepoolId was null or undefined when calling k8sNodepoolsNodesGet.');
            }
            const localVarPath = `/k8s/{k8sClusterId}/nodepools/{nodepoolId}/nodes`
                .replace(`{${"k8sClusterId"}}`, encodeURIComponent(String(k8sClusterId)))
                .replace(`{${"nodepoolId"}}`, encodeURIComponent(String(nodepoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can recreate a single Kubernetes Node.  Managed Kubernetes starts a process which based on the nodepool\'s template creates & configures a new node, waits for status \"ACTIVE\", and migrates all the pods from the faulty node, deleting it once empty. While this operation occurs, the nodepool will have an extra billable \"ACTIVE\" node.
         * @summary Recreate the Kubernetes node
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {string} nodeId The unique ID of the Kubernetes Node.
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsNodesReplacePost: async (k8sClusterId: string, nodepoolId: string, nodeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8sClusterId' is not null or undefined
            if (k8sClusterId === null || k8sClusterId === undefined) {
                throw new RequiredError('k8sClusterId','Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsNodesReplacePost.');
            }
            // verify required parameter 'nodepoolId' is not null or undefined
            if (nodepoolId === null || nodepoolId === undefined) {
                throw new RequiredError('nodepoolId','Required parameter nodepoolId was null or undefined when calling k8sNodepoolsNodesReplacePost.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling k8sNodepoolsNodesReplacePost.');
            }
            const localVarPath = `/k8s/{k8sClusterId}/nodepools/{nodepoolId}/nodes/{nodeId}/replace`
                .replace(`{${"k8sClusterId"}}`, encodeURIComponent(String(k8sClusterId)))
                .replace(`{${"nodepoolId"}}`, encodeURIComponent(String(nodepoolId)))
                .replace(`{${"nodeId"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will create a new Kubernetes Node Pool inside a Kubernetes Cluster.
         * @summary Create a Kubernetes Node Pool
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {KubernetesNodePoolForPost} kubernetesNodePool Details of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsPost: async (k8sClusterId: string, kubernetesNodePool: KubernetesNodePoolForPost, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8sClusterId' is not null or undefined
            if (k8sClusterId === null || k8sClusterId === undefined) {
                throw new RequiredError('k8sClusterId','Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsPost.');
            }
            // verify required parameter 'kubernetesNodePool' is not null or undefined
            if (kubernetesNodePool === null || kubernetesNodePool === undefined) {
                throw new RequiredError('kubernetesNodePool','Required parameter kubernetesNodePool was null or undefined when calling k8sNodepoolsPost.');
            }
            const localVarPath = `/k8s/{k8sClusterId}/nodepools`
                .replace(`{${"k8sClusterId"}}`, encodeURIComponent(String(k8sClusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof kubernetesNodePool !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(kubernetesNodePool !== undefined ? kubernetesNodePool : {})
                : (kubernetesNodePool || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will modify the Kubernetes Node Pool.
         * @summary Modify Kubernetes Node Pool
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {KubernetesNodePoolForPut} kubernetesNodePool Details of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsPut: async (k8sClusterId: string, nodepoolId: string, kubernetesNodePool: KubernetesNodePoolForPut, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8sClusterId' is not null or undefined
            if (k8sClusterId === null || k8sClusterId === undefined) {
                throw new RequiredError('k8sClusterId','Required parameter k8sClusterId was null or undefined when calling k8sNodepoolsPut.');
            }
            // verify required parameter 'nodepoolId' is not null or undefined
            if (nodepoolId === null || nodepoolId === undefined) {
                throw new RequiredError('nodepoolId','Required parameter nodepoolId was null or undefined when calling k8sNodepoolsPut.');
            }
            // verify required parameter 'kubernetesNodePool' is not null or undefined
            if (kubernetesNodePool === null || kubernetesNodePool === undefined) {
                throw new RequiredError('kubernetesNodePool','Required parameter kubernetesNodePool was null or undefined when calling k8sNodepoolsPut.');
            }
            const localVarPath = `/k8s/{k8sClusterId}/nodepools/{nodepoolId}`
                .replace(`{${"k8sClusterId"}}`, encodeURIComponent(String(k8sClusterId)))
                .replace(`{${"nodepoolId"}}`, encodeURIComponent(String(nodepoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof kubernetesNodePool !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(kubernetesNodePool !== undefined ? kubernetesNodePool : {})
                : (kubernetesNodePool || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will create a new Kubernetes Cluster.
         * @summary Create Kubernetes Cluster
         * @param {KubernetesClusterForPost} kubernetesCluster Details of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sPost: async (kubernetesCluster: KubernetesClusterForPost, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'kubernetesCluster' is not null or undefined
            if (kubernetesCluster === null || kubernetesCluster === undefined) {
                throw new RequiredError('kubernetesCluster','Required parameter kubernetesCluster was null or undefined when calling k8sPost.');
            }
            const localVarPath = `/k8s`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof kubernetesCluster !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(kubernetesCluster !== undefined ? kubernetesCluster : {})
                : (kubernetesCluster || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will modify the Kubernetes Cluster.
         * @summary Modify Kubernetes Cluster
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {KubernetesClusterForPut} kubernetesCluster Details of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sPut: async (k8sClusterId: string, kubernetesCluster: KubernetesClusterForPut, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'k8sClusterId' is not null or undefined
            if (k8sClusterId === null || k8sClusterId === undefined) {
                throw new RequiredError('k8sClusterId','Required parameter k8sClusterId was null or undefined when calling k8sPut.');
            }
            // verify required parameter 'kubernetesCluster' is not null or undefined
            if (kubernetesCluster === null || kubernetesCluster === undefined) {
                throw new RequiredError('kubernetesCluster','Required parameter kubernetesCluster was null or undefined when calling k8sPut.');
            }
            const localVarPath = `/k8s/{k8sClusterId}`
                .replace(`{${"k8sClusterId"}}`, encodeURIComponent(String(k8sClusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof kubernetesCluster !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(kubernetesCluster !== undefined ? kubernetesCluster : {})
                : (kubernetesCluster || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a list of available kubernetes versions for nodepools depending on the given kubernetes version running in the cluster.
         * @summary Retrieves a list of available kubernetes versions for nodepools depending on the given kubernetes version running in the cluster.
         * @param {string} clusterVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sVersionsCompatibilitiesGet: async (clusterVersion: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterVersion' is not null or undefined
            if (clusterVersion === null || clusterVersion === undefined) {
                throw new RequiredError('clusterVersion','Required parameter clusterVersion was null or undefined when calling k8sVersionsCompatibilitiesGet.');
            }
            const localVarPath = `/k8s/versions/{clusterVersion}/compatibilities`
                .replace(`{${"clusterVersion"}}`, encodeURIComponent(String(clusterVersion)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve the current default kubernetes version for clusters and nodepools.
         * @summary Retrieve the current default kubernetes version for clusters and nodepools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sVersionsDefaultGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/k8s/versions/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a list of available kubernetes versions
         * @summary Retrieve available Kubernetes versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sVersionsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/k8s/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KubernetesApi - functional programming interface
 * @export
 */
export const KubernetesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This will remove a Kubernetes Cluster.
         * @summary Delete Kubernetes Cluster
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sDelete(k8sClusterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sDelete(k8sClusterId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will retrieve a single Kubernetes Cluster.
         * @summary Retrieve Kubernetes Cluster
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sFindByClusterId(k8sClusterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KubernetesCluster>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sFindByClusterId(k8sClusterId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a list of all kubernetes clusters associated with a contract
         * @summary List Kubernetes Clusters
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sGet(pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KubernetesClusters>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sGet(pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve kubernetes configuration file for the kubernetes cluster.
         * @summary Retrieve Kubernetes Configuration File
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sKubeconfigGet(k8sClusterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KubernetesConfig>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sKubeconfigGet(k8sClusterId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will remove a Kubernetes Node Pool.
         * @summary Delete Kubernetes Node Pool
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sNodepoolsDelete(k8sClusterId: string, nodepoolId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sNodepoolsDelete(k8sClusterId, nodepoolId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a single Kubernetes Node Pool.
         * @summary Retrieve Kubernetes Node Pool
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sNodepoolsFindById(k8sClusterId: string, nodepoolId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KubernetesNodePool>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sNodepoolsFindById(k8sClusterId, nodepoolId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a list of all kubernetes node pools part of kubernetes cluster
         * @summary List Kubernetes Node Pools
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sNodepoolsGet(k8sClusterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KubernetesNodePools>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sNodepoolsGet(k8sClusterId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will remove a Kubernetes node.
         * @summary Delete Kubernetes node
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {string} nodeId The unique ID of the Kubernetes node
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sNodepoolsNodesDelete(k8sClusterId: string, nodepoolId: string, nodeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sNodepoolsNodesDelete(k8sClusterId, nodepoolId, nodeId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a single Kubernetes Node.
         * @summary Retrieve Kubernetes node
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {string} nodeId The unique ID of the Kubernetes Node.
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sNodepoolsNodesFindById(k8sClusterId: string, nodepoolId: string, nodeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KubernetesNode>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sNodepoolsNodesFindById(k8sClusterId, nodepoolId, nodeId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve all nodes of Kubernetes Node Pool.
         * @summary Retrieve Kubernetes nodes.
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sNodepoolsNodesGet(k8sClusterId: string, nodepoolId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KubernetesNodes>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sNodepoolsNodesGet(k8sClusterId, nodepoolId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can recreate a single Kubernetes Node.  Managed Kubernetes starts a process which based on the nodepool\'s template creates & configures a new node, waits for status \"ACTIVE\", and migrates all the pods from the faulty node, deleting it once empty. While this operation occurs, the nodepool will have an extra billable \"ACTIVE\" node.
         * @summary Recreate the Kubernetes node
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {string} nodeId The unique ID of the Kubernetes Node.
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sNodepoolsNodesReplacePost(k8sClusterId: string, nodepoolId: string, nodeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sNodepoolsNodesReplacePost(k8sClusterId, nodepoolId, nodeId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will create a new Kubernetes Node Pool inside a Kubernetes Cluster.
         * @summary Create a Kubernetes Node Pool
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {KubernetesNodePoolForPost} kubernetesNodePool Details of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sNodepoolsPost(k8sClusterId: string, kubernetesNodePool: KubernetesNodePoolForPost, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KubernetesNodePool>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sNodepoolsPost(k8sClusterId, kubernetesNodePool, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will modify the Kubernetes Node Pool.
         * @summary Modify Kubernetes Node Pool
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {KubernetesNodePoolForPut} kubernetesNodePool Details of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sNodepoolsPut(k8sClusterId: string, nodepoolId: string, kubernetesNodePool: KubernetesNodePoolForPut, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KubernetesNodePool>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sNodepoolsPut(k8sClusterId, nodepoolId, kubernetesNodePool, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will create a new Kubernetes Cluster.
         * @summary Create Kubernetes Cluster
         * @param {KubernetesClusterForPost} kubernetesCluster Details of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sPost(kubernetesCluster: KubernetesClusterForPost, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KubernetesCluster>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sPost(kubernetesCluster, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will modify the Kubernetes Cluster.
         * @summary Modify Kubernetes Cluster
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {KubernetesClusterForPut} kubernetesCluster Details of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sPut(k8sClusterId: string, kubernetesCluster: KubernetesClusterForPut, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KubernetesCluster>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sPut(k8sClusterId, kubernetesCluster, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a list of available kubernetes versions for nodepools depending on the given kubernetes version running in the cluster.
         * @summary Retrieves a list of available kubernetes versions for nodepools depending on the given kubernetes version running in the cluster.
         * @param {string} clusterVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sVersionsCompatibilitiesGet(clusterVersion: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sVersionsCompatibilitiesGet(clusterVersion, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve the current default kubernetes version for clusters and nodepools.
         * @summary Retrieve the current default kubernetes version for clusters and nodepools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sVersionsDefaultGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sVersionsDefaultGet(options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a list of available kubernetes versions
         * @summary Retrieve available Kubernetes versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async k8sVersionsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const axiosArgs = await KubernetesApiAxiosParamCreator(configuration).k8sVersionsGet(options);
            return runRequest(axiosArgs, configuration);
        },
    }
};

/**
 * KubernetesApi - factory interface
 * @export
 */
export const KubernetesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This will remove a Kubernetes Cluster.
         * @summary Delete Kubernetes Cluster
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sDelete(k8sClusterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return KubernetesApiFp(configuration).k8sDelete(k8sClusterId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will retrieve a single Kubernetes Cluster.
         * @summary Retrieve Kubernetes Cluster
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sFindByClusterId(k8sClusterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<KubernetesCluster> {
            return KubernetesApiFp(configuration).k8sFindByClusterId(k8sClusterId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a list of all kubernetes clusters associated with a contract
         * @summary List Kubernetes Clusters
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sGet(pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<KubernetesClusters> {
            return KubernetesApiFp(configuration).k8sGet(pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve kubernetes configuration file for the kubernetes cluster.
         * @summary Retrieve Kubernetes Configuration File
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sKubeconfigGet(k8sClusterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<KubernetesConfig> {
            return KubernetesApiFp(configuration).k8sKubeconfigGet(k8sClusterId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will remove a Kubernetes Node Pool.
         * @summary Delete Kubernetes Node Pool
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsDelete(k8sClusterId: string, nodepoolId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return KubernetesApiFp(configuration).k8sNodepoolsDelete(k8sClusterId, nodepoolId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a single Kubernetes Node Pool.
         * @summary Retrieve Kubernetes Node Pool
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsFindById(k8sClusterId: string, nodepoolId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<KubernetesNodePool> {
            return KubernetesApiFp(configuration).k8sNodepoolsFindById(k8sClusterId, nodepoolId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a list of all kubernetes node pools part of kubernetes cluster
         * @summary List Kubernetes Node Pools
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsGet(k8sClusterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<KubernetesNodePools> {
            return KubernetesApiFp(configuration).k8sNodepoolsGet(k8sClusterId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will remove a Kubernetes node.
         * @summary Delete Kubernetes node
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {string} nodeId The unique ID of the Kubernetes node
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsNodesDelete(k8sClusterId: string, nodepoolId: string, nodeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return KubernetesApiFp(configuration).k8sNodepoolsNodesDelete(k8sClusterId, nodepoolId, nodeId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a single Kubernetes Node.
         * @summary Retrieve Kubernetes node
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {string} nodeId The unique ID of the Kubernetes Node.
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsNodesFindById(k8sClusterId: string, nodepoolId: string, nodeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<KubernetesNode> {
            return KubernetesApiFp(configuration).k8sNodepoolsNodesFindById(k8sClusterId, nodepoolId, nodeId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve all nodes of Kubernetes Node Pool.
         * @summary Retrieve Kubernetes nodes.
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsNodesGet(k8sClusterId: string, nodepoolId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<KubernetesNodes> {
            return KubernetesApiFp(configuration).k8sNodepoolsNodesGet(k8sClusterId, nodepoolId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can recreate a single Kubernetes Node.  Managed Kubernetes starts a process which based on the nodepool\'s template creates & configures a new node, waits for status \"ACTIVE\", and migrates all the pods from the faulty node, deleting it once empty. While this operation occurs, the nodepool will have an extra billable \"ACTIVE\" node.
         * @summary Recreate the Kubernetes node
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {string} nodeId The unique ID of the Kubernetes Node.
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsNodesReplacePost(k8sClusterId: string, nodepoolId: string, nodeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return KubernetesApiFp(configuration).k8sNodepoolsNodesReplacePost(k8sClusterId, nodepoolId, nodeId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will create a new Kubernetes Node Pool inside a Kubernetes Cluster.
         * @summary Create a Kubernetes Node Pool
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {KubernetesNodePoolForPost} kubernetesNodePool Details of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsPost(k8sClusterId: string, kubernetesNodePool: KubernetesNodePoolForPost, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<KubernetesNodePool> {
            return KubernetesApiFp(configuration).k8sNodepoolsPost(k8sClusterId, kubernetesNodePool, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will modify the Kubernetes Node Pool.
         * @summary Modify Kubernetes Node Pool
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {string} nodepoolId The unique ID of the Kubernetes Node Pool
         * @param {KubernetesNodePoolForPut} kubernetesNodePool Details of the Kubernetes Node Pool
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sNodepoolsPut(k8sClusterId: string, nodepoolId: string, kubernetesNodePool: KubernetesNodePoolForPut, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<KubernetesNodePool> {
            return KubernetesApiFp(configuration).k8sNodepoolsPut(k8sClusterId, nodepoolId, kubernetesNodePool, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will create a new Kubernetes Cluster.
         * @summary Create Kubernetes Cluster
         * @param {KubernetesClusterForPost} kubernetesCluster Details of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sPost(kubernetesCluster: KubernetesClusterForPost, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<KubernetesCluster> {
            return KubernetesApiFp(configuration).k8sPost(kubernetesCluster, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will modify the Kubernetes Cluster.
         * @summary Modify Kubernetes Cluster
         * @param {string} k8sClusterId The unique ID of the Kubernetes Cluster
         * @param {KubernetesClusterForPut} kubernetesCluster Details of the Kubernetes Cluster
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sPut(k8sClusterId: string, kubernetesCluster: KubernetesClusterForPut, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<KubernetesCluster> {
            return KubernetesApiFp(configuration).k8sPut(k8sClusterId, kubernetesCluster, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a list of available kubernetes versions for nodepools depending on the given kubernetes version running in the cluster.
         * @summary Retrieves a list of available kubernetes versions for nodepools depending on the given kubernetes version running in the cluster.
         * @param {string} clusterVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sVersionsCompatibilitiesGet(clusterVersion: string, options?: any): AxiosPromise<Array<string>> {
            return KubernetesApiFp(configuration).k8sVersionsCompatibilitiesGet(clusterVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve the current default kubernetes version for clusters and nodepools.
         * @summary Retrieve the current default kubernetes version for clusters and nodepools.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sVersionsDefaultGet(options?: any): AxiosPromise<string> {
            return KubernetesApiFp(configuration).k8sVersionsDefaultGet(options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a list of available kubernetes versions
         * @summary Retrieve available Kubernetes versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        k8sVersionsGet(options?: any): AxiosPromise<Array<string>> {
            return KubernetesApiFp(configuration).k8sVersionsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for k8sDelete operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sDeleteRequest
 */
export interface KubernetesApiK8sDeleteRequest {
    /**
     * The unique ID of the Kubernetes Cluster
     * @type {string}
     * @memberof KubernetesApiK8sDelete
     */
    readonly k8sClusterId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sFindByClusterId operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sFindByClusterIdRequest
 */
export interface KubernetesApiK8sFindByClusterIdRequest {
    /**
     * The unique ID of the Kubernetes Cluster
     * @type {string}
     * @memberof KubernetesApiK8sFindByClusterId
     */
    readonly k8sClusterId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sFindByClusterId
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sFindByClusterId
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sFindByClusterId
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sGet operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sGetRequest
 */
export interface KubernetesApiK8sGetRequest {
    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sGet
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sKubeconfigGet operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sKubeconfigGetRequest
 */
export interface KubernetesApiK8sKubeconfigGetRequest {
    /**
     * The unique ID of the Kubernetes Cluster
     * @type {string}
     * @memberof KubernetesApiK8sKubeconfigGet
     */
    readonly k8sClusterId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sKubeconfigGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sKubeconfigGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sKubeconfigGet
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sNodepoolsDelete operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sNodepoolsDeleteRequest
 */
export interface KubernetesApiK8sNodepoolsDeleteRequest {
    /**
     * The unique ID of the Kubernetes Cluster
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsDelete
     */
    readonly k8sClusterId: string

    /**
     * The unique ID of the Kubernetes Node Pool
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsDelete
     */
    readonly nodepoolId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sNodepoolsDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sNodepoolsFindById operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sNodepoolsFindByIdRequest
 */
export interface KubernetesApiK8sNodepoolsFindByIdRequest {
    /**
     * The unique ID of the Kubernetes Cluster
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsFindById
     */
    readonly k8sClusterId: string

    /**
     * The unique ID of the Kubernetes Node Pool
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsFindById
     */
    readonly nodepoolId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sNodepoolsFindById
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsFindById
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsFindById
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sNodepoolsGet operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sNodepoolsGetRequest
 */
export interface KubernetesApiK8sNodepoolsGetRequest {
    /**
     * The unique ID of the Kubernetes Cluster
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsGet
     */
    readonly k8sClusterId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sNodepoolsGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsGet
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sNodepoolsNodesDelete operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sNodepoolsNodesDeleteRequest
 */
export interface KubernetesApiK8sNodepoolsNodesDeleteRequest {
    /**
     * The unique ID of the Kubernetes Cluster
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsNodesDelete
     */
    readonly k8sClusterId: string

    /**
     * The unique ID of the Kubernetes Node Pool
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsNodesDelete
     */
    readonly nodepoolId: string

    /**
     * The unique ID of the Kubernetes node
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsNodesDelete
     */
    readonly nodeId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sNodepoolsNodesDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsNodesDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsNodesDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sNodepoolsNodesFindById operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sNodepoolsNodesFindByIdRequest
 */
export interface KubernetesApiK8sNodepoolsNodesFindByIdRequest {
    /**
     * The unique ID of the Kubernetes Cluster
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsNodesFindById
     */
    readonly k8sClusterId: string

    /**
     * The unique ID of the Kubernetes Node Pool
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsNodesFindById
     */
    readonly nodepoolId: string

    /**
     * The unique ID of the Kubernetes Node.
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsNodesFindById
     */
    readonly nodeId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sNodepoolsNodesFindById
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsNodesFindById
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsNodesFindById
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sNodepoolsNodesGet operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sNodepoolsNodesGetRequest
 */
export interface KubernetesApiK8sNodepoolsNodesGetRequest {
    /**
     * The unique ID of the Kubernetes Cluster
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsNodesGet
     */
    readonly k8sClusterId: string

    /**
     * The unique ID of the Kubernetes Node Pool
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsNodesGet
     */
    readonly nodepoolId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sNodepoolsNodesGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsNodesGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsNodesGet
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sNodepoolsNodesReplacePost operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sNodepoolsNodesReplacePostRequest
 */
export interface KubernetesApiK8sNodepoolsNodesReplacePostRequest {
    /**
     * The unique ID of the Kubernetes Cluster
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsNodesReplacePost
     */
    readonly k8sClusterId: string

    /**
     * The unique ID of the Kubernetes Node Pool
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsNodesReplacePost
     */
    readonly nodepoolId: string

    /**
     * The unique ID of the Kubernetes Node.
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsNodesReplacePost
     */
    readonly nodeId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sNodepoolsNodesReplacePost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsNodesReplacePost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsNodesReplacePost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sNodepoolsPost operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sNodepoolsPostRequest
 */
export interface KubernetesApiK8sNodepoolsPostRequest {
    /**
     * The unique ID of the Kubernetes Cluster
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsPost
     */
    readonly k8sClusterId: string

    /**
     * Details of the Kubernetes Node Pool
     * @type {KubernetesNodePoolForPost}
     * @memberof KubernetesApiK8sNodepoolsPost
     */
    readonly kubernetesNodePool: KubernetesNodePoolForPost

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sNodepoolsPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sNodepoolsPut operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sNodepoolsPutRequest
 */
export interface KubernetesApiK8sNodepoolsPutRequest {
    /**
     * The unique ID of the Kubernetes Cluster
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsPut
     */
    readonly k8sClusterId: string

    /**
     * The unique ID of the Kubernetes Node Pool
     * @type {string}
     * @memberof KubernetesApiK8sNodepoolsPut
     */
    readonly nodepoolId: string

    /**
     * Details of the Kubernetes Node Pool
     * @type {KubernetesNodePoolForPut}
     * @memberof KubernetesApiK8sNodepoolsPut
     */
    readonly kubernetesNodePool: KubernetesNodePoolForPut

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sNodepoolsPut
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsPut
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sNodepoolsPut
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sPost operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sPostRequest
 */
export interface KubernetesApiK8sPostRequest {
    /**
     * Details of the Kubernetes Cluster
     * @type {KubernetesClusterForPost}
     * @memberof KubernetesApiK8sPost
     */
    readonly kubernetesCluster: KubernetesClusterForPost

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sPut operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sPutRequest
 */
export interface KubernetesApiK8sPutRequest {
    /**
     * The unique ID of the Kubernetes Cluster
     * @type {string}
     * @memberof KubernetesApiK8sPut
     */
    readonly k8sClusterId: string

    /**
     * Details of the Kubernetes Cluster
     * @type {KubernetesClusterForPut}
     * @memberof KubernetesApiK8sPut
     */
    readonly kubernetesCluster: KubernetesClusterForPut

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof KubernetesApiK8sPut
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof KubernetesApiK8sPut
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof KubernetesApiK8sPut
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for k8sVersionsCompatibilitiesGet operation in KubernetesApi.
 * @export
 * @interface KubernetesApiK8sVersionsCompatibilitiesGetRequest
 */
export interface KubernetesApiK8sVersionsCompatibilitiesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof KubernetesApiK8sVersionsCompatibilitiesGet
     */
    readonly clusterVersion: string
}

/**
 * KubernetesApi - object-oriented interface
 * @export
 * @class KubernetesApi
 * @extends {BaseAPI}
 */
export class KubernetesApi extends BaseAPI {
    /**
     * This will remove a Kubernetes Cluster.
     * @summary Delete Kubernetes Cluster
     * @param {KubernetesApiK8sDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sDelete(requestParameters: KubernetesApiK8sDeleteRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sDelete(requestParameters.k8sClusterId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will retrieve a single Kubernetes Cluster.
     * @summary Retrieve Kubernetes Cluster
     * @param {KubernetesApiK8sFindByClusterIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sFindByClusterId(requestParameters: KubernetesApiK8sFindByClusterIdRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sFindByClusterId(requestParameters.k8sClusterId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a list of all kubernetes clusters associated with a contract
     * @summary List Kubernetes Clusters
     * @param {KubernetesApiK8sGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sGet(requestParameters: KubernetesApiK8sGetRequest = {}, options?: any) {
        return KubernetesApiFp(this.configuration).k8sGet(requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve kubernetes configuration file for the kubernetes cluster.
     * @summary Retrieve Kubernetes Configuration File
     * @param {KubernetesApiK8sKubeconfigGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sKubeconfigGet(requestParameters: KubernetesApiK8sKubeconfigGetRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sKubeconfigGet(requestParameters.k8sClusterId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will remove a Kubernetes Node Pool.
     * @summary Delete Kubernetes Node Pool
     * @param {KubernetesApiK8sNodepoolsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sNodepoolsDelete(requestParameters: KubernetesApiK8sNodepoolsDeleteRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sNodepoolsDelete(requestParameters.k8sClusterId, requestParameters.nodepoolId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a single Kubernetes Node Pool.
     * @summary Retrieve Kubernetes Node Pool
     * @param {KubernetesApiK8sNodepoolsFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sNodepoolsFindById(requestParameters: KubernetesApiK8sNodepoolsFindByIdRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sNodepoolsFindById(requestParameters.k8sClusterId, requestParameters.nodepoolId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a list of all kubernetes node pools part of kubernetes cluster
     * @summary List Kubernetes Node Pools
     * @param {KubernetesApiK8sNodepoolsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sNodepoolsGet(requestParameters: KubernetesApiK8sNodepoolsGetRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sNodepoolsGet(requestParameters.k8sClusterId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will remove a Kubernetes node.
     * @summary Delete Kubernetes node
     * @param {KubernetesApiK8sNodepoolsNodesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sNodepoolsNodesDelete(requestParameters: KubernetesApiK8sNodepoolsNodesDeleteRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sNodepoolsNodesDelete(requestParameters.k8sClusterId, requestParameters.nodepoolId, requestParameters.nodeId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a single Kubernetes Node.
     * @summary Retrieve Kubernetes node
     * @param {KubernetesApiK8sNodepoolsNodesFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sNodepoolsNodesFindById(requestParameters: KubernetesApiK8sNodepoolsNodesFindByIdRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sNodepoolsNodesFindById(requestParameters.k8sClusterId, requestParameters.nodepoolId, requestParameters.nodeId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve all nodes of Kubernetes Node Pool.
     * @summary Retrieve Kubernetes nodes.
     * @param {KubernetesApiK8sNodepoolsNodesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sNodepoolsNodesGet(requestParameters: KubernetesApiK8sNodepoolsNodesGetRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sNodepoolsNodesGet(requestParameters.k8sClusterId, requestParameters.nodepoolId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can recreate a single Kubernetes Node.  Managed Kubernetes starts a process which based on the nodepool\'s template creates & configures a new node, waits for status \"ACTIVE\", and migrates all the pods from the faulty node, deleting it once empty. While this operation occurs, the nodepool will have an extra billable \"ACTIVE\" node.
     * @summary Recreate the Kubernetes node
     * @param {KubernetesApiK8sNodepoolsNodesReplacePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sNodepoolsNodesReplacePost(requestParameters: KubernetesApiK8sNodepoolsNodesReplacePostRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sNodepoolsNodesReplacePost(requestParameters.k8sClusterId, requestParameters.nodepoolId, requestParameters.nodeId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will create a new Kubernetes Node Pool inside a Kubernetes Cluster.
     * @summary Create a Kubernetes Node Pool
     * @param {KubernetesApiK8sNodepoolsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sNodepoolsPost(requestParameters: KubernetesApiK8sNodepoolsPostRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sNodepoolsPost(requestParameters.k8sClusterId, requestParameters.kubernetesNodePool, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will modify the Kubernetes Node Pool.
     * @summary Modify Kubernetes Node Pool
     * @param {KubernetesApiK8sNodepoolsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sNodepoolsPut(requestParameters: KubernetesApiK8sNodepoolsPutRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sNodepoolsPut(requestParameters.k8sClusterId, requestParameters.nodepoolId, requestParameters.kubernetesNodePool, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will create a new Kubernetes Cluster.
     * @summary Create Kubernetes Cluster
     * @param {KubernetesApiK8sPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sPost(requestParameters: KubernetesApiK8sPostRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sPost(requestParameters.kubernetesCluster, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will modify the Kubernetes Cluster.
     * @summary Modify Kubernetes Cluster
     * @param {KubernetesApiK8sPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sPut(requestParameters: KubernetesApiK8sPutRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sPut(requestParameters.k8sClusterId, requestParameters.kubernetesCluster, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a list of available kubernetes versions for nodepools depending on the given kubernetes version running in the cluster.
     * @summary Retrieves a list of available kubernetes versions for nodepools depending on the given kubernetes version running in the cluster.
     * @param {KubernetesApiK8sVersionsCompatibilitiesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sVersionsCompatibilitiesGet(requestParameters: KubernetesApiK8sVersionsCompatibilitiesGetRequest, options?: any) {
        return KubernetesApiFp(this.configuration).k8sVersionsCompatibilitiesGet(requestParameters.clusterVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve the current default kubernetes version for clusters and nodepools.
     * @summary Retrieve the current default kubernetes version for clusters and nodepools.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sVersionsDefaultGet(options?: any) {
        return KubernetesApiFp(this.configuration).k8sVersionsDefaultGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a list of available kubernetes versions
     * @summary Retrieve available Kubernetes versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public k8sVersionsGet(options?: any) {
        return KubernetesApiFp(this.configuration).k8sVersionsGet(options).then((request) => request(this.axios, this.basePath));
    }
}
