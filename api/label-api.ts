/* tslint:disable */
/* eslint-disable */
/**
 * CLOUD API
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * The version of the OpenAPI document: 5.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration, DEFAULT_MAX_RETRIES, DEFAULT_MAX_WAIT_TIME } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, backOff, runRequest } from '../base';
// @ts-ignore
import { Label } from '../model';
// @ts-ignore
import { LabelResource } from '../model';
// @ts-ignore
import { LabelResources } from '../model';
// @ts-ignore
import { Labels } from '../model';
/**
 * LabelApi - axios parameter creator
 * @export
 */
export const LabelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will remove a label from the data center.
         * @summary Delete a Label from Data Center
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLabelsDelete: async (datacenterId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLabelsDelete.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling datacentersLabelsDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}/labels/{key}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will retrieve the properties of a associated label to a data center.
         * @summary Retrieve a Label of Data Center
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLabelsFindByKey: async (datacenterId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLabelsFindByKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling datacentersLabelsFindByKey.');
            }
            const localVarPath = `/datacenters/{datacenterId}/labels/{key}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a list of all labels associated with a data center
         * @summary List all Data Center Labels
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLabelsGet: async (datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLabelsGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/labels`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will add a label to the data center.
         * @summary Add a Label to Data Center
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLabelsPost: async (datacenterId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLabelsPost.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling datacentersLabelsPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/labels`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof label !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(label !== undefined ? label : {})
                : (label || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will modify the value of the label on a data center.
         * @summary Modify a Label of Data Center
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLabelsPut: async (datacenterId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLabelsPut.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling datacentersLabelsPut.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling datacentersLabelsPut.');
            }
            const localVarPath = `/datacenters/{datacenterId}/labels/{key}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof label !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(label !== undefined ? label : {})
                : (label || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will remove a label from the server.
         * @summary Delete a Label from Server
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersLabelsDelete: async (datacenterId: string, serverId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersLabelsDelete.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersLabelsDelete.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling datacentersServersLabelsDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/labels/{key}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will retrieve the properties of a associated label to a server.
         * @summary Retrieve a Label of Server
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersLabelsFindByKey: async (datacenterId: string, serverId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersLabelsFindByKey.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersLabelsFindByKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling datacentersServersLabelsFindByKey.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/labels/{key}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a list of all labels associated with a server
         * @summary List all Server Labels
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersLabelsGet: async (datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersLabelsGet.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersLabelsGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/labels`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will add a label to the server.
         * @summary Add a Label to Server
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersLabelsPost: async (datacenterId: string, serverId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersLabelsPost.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersLabelsPost.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling datacentersServersLabelsPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/labels`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof label !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(label !== undefined ? label : {})
                : (label || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will modify the value of the label on a server.
         * @summary Modify a Label of Server
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersLabelsPut: async (datacenterId: string, serverId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersServersLabelsPut.');
            }
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling datacentersServersLabelsPut.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling datacentersServersLabelsPut.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling datacentersServersLabelsPut.');
            }
            const localVarPath = `/datacenters/{datacenterId}/servers/{serverId}/labels/{key}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof label !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(label !== undefined ? label : {})
                : (label || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will remove a label from the volume.
         * @summary Delete a Label from Volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersVolumesLabelsDelete: async (datacenterId: string, volumeId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersVolumesLabelsDelete.');
            }
            // verify required parameter 'volumeId' is not null or undefined
            if (volumeId === null || volumeId === undefined) {
                throw new RequiredError('volumeId','Required parameter volumeId was null or undefined when calling datacentersVolumesLabelsDelete.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling datacentersVolumesLabelsDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}/volumes/{volumeId}/labels/{key}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"volumeId"}}`, encodeURIComponent(String(volumeId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will retrieve the properties of a associated label to a volume.
         * @summary Retrieve a Label of Volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersVolumesLabelsFindByKey: async (datacenterId: string, volumeId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersVolumesLabelsFindByKey.');
            }
            // verify required parameter 'volumeId' is not null or undefined
            if (volumeId === null || volumeId === undefined) {
                throw new RequiredError('volumeId','Required parameter volumeId was null or undefined when calling datacentersVolumesLabelsFindByKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling datacentersVolumesLabelsFindByKey.');
            }
            const localVarPath = `/datacenters/{datacenterId}/volumes/{volumeId}/labels/{key}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"volumeId"}}`, encodeURIComponent(String(volumeId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a list of all labels associated with a volume
         * @summary List all Volume Labels
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersVolumesLabelsGet: async (datacenterId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersVolumesLabelsGet.');
            }
            // verify required parameter 'volumeId' is not null or undefined
            if (volumeId === null || volumeId === undefined) {
                throw new RequiredError('volumeId','Required parameter volumeId was null or undefined when calling datacentersVolumesLabelsGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/volumes/{volumeId}/labels`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"volumeId"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will add a label to the volume.
         * @summary Add a Label to Volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersVolumesLabelsPost: async (datacenterId: string, volumeId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersVolumesLabelsPost.');
            }
            // verify required parameter 'volumeId' is not null or undefined
            if (volumeId === null || volumeId === undefined) {
                throw new RequiredError('volumeId','Required parameter volumeId was null or undefined when calling datacentersVolumesLabelsPost.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling datacentersVolumesLabelsPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/volumes/{volumeId}/labels`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"volumeId"}}`, encodeURIComponent(String(volumeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof label !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(label !== undefined ? label : {})
                : (label || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will modify the value of the label on a volume.
         * @summary Modify a Label of Volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersVolumesLabelsPut: async (datacenterId: string, volumeId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersVolumesLabelsPut.');
            }
            // verify required parameter 'volumeId' is not null or undefined
            if (volumeId === null || volumeId === undefined) {
                throw new RequiredError('volumeId','Required parameter volumeId was null or undefined when calling datacentersVolumesLabelsPut.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling datacentersVolumesLabelsPut.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling datacentersVolumesLabelsPut.');
            }
            const localVarPath = `/datacenters/{datacenterId}/volumes/{volumeId}/labels/{key}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"volumeId"}}`, encodeURIComponent(String(volumeId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof label !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(label !== undefined ? label : {})
                : (label || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will remove a label from the Ip Block.
         * @summary Delete a Label from IP Block
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipblocksLabelsDelete: async (ipblockId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipblockId' is not null or undefined
            if (ipblockId === null || ipblockId === undefined) {
                throw new RequiredError('ipblockId','Required parameter ipblockId was null or undefined when calling ipblocksLabelsDelete.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling ipblocksLabelsDelete.');
            }
            const localVarPath = `/ipblocks/{ipblockId}/labels/{key}`
                .replace(`{${"ipblockId"}}`, encodeURIComponent(String(ipblockId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will retrieve the properties of a associated label to a Ip Block.
         * @summary Retrieve a Label of IP Block
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipblocksLabelsFindByKey: async (ipblockId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipblockId' is not null or undefined
            if (ipblockId === null || ipblockId === undefined) {
                throw new RequiredError('ipblockId','Required parameter ipblockId was null or undefined when calling ipblocksLabelsFindByKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling ipblocksLabelsFindByKey.');
            }
            const localVarPath = `/ipblocks/{ipblockId}/labels/{key}`
                .replace(`{${"ipblockId"}}`, encodeURIComponent(String(ipblockId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a list of all labels associated with a IP Block
         * @summary List all Ip Block Labels
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipblocksLabelsGet: async (ipblockId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipblockId' is not null or undefined
            if (ipblockId === null || ipblockId === undefined) {
                throw new RequiredError('ipblockId','Required parameter ipblockId was null or undefined when calling ipblocksLabelsGet.');
            }
            const localVarPath = `/ipblocks/{ipblockId}/labels`
                .replace(`{${"ipblockId"}}`, encodeURIComponent(String(ipblockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will add a label to the Ip Block.
         * @summary Add a Label to IP Block
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipblocksLabelsPost: async (ipblockId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipblockId' is not null or undefined
            if (ipblockId === null || ipblockId === undefined) {
                throw new RequiredError('ipblockId','Required parameter ipblockId was null or undefined when calling ipblocksLabelsPost.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling ipblocksLabelsPost.');
            }
            const localVarPath = `/ipblocks/{ipblockId}/labels`
                .replace(`{${"ipblockId"}}`, encodeURIComponent(String(ipblockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof label !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(label !== undefined ? label : {})
                : (label || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will modify the value of the label on a Ip Block.
         * @summary Modify a Label of IP Block
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipblocksLabelsPut: async (ipblockId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipblockId' is not null or undefined
            if (ipblockId === null || ipblockId === undefined) {
                throw new RequiredError('ipblockId','Required parameter ipblockId was null or undefined when calling ipblocksLabelsPut.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling ipblocksLabelsPut.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling ipblocksLabelsPut.');
            }
            const localVarPath = `/ipblocks/{ipblockId}/labels/{key}`
                .replace(`{${"ipblockId"}}`, encodeURIComponent(String(ipblockId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof label !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(label !== undefined ? label : {})
                : (label || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve the details of a specific label using its URN. A URN is for uniqueness of a Label and composed using urn:label:<resource_type>:<resource_uuid>:<key>
         * @summary Returns the label by its URN.
         * @param {string} labelurn The URN representing the unique ID of the label. A URN is for uniqueness of a Label and composed using urn:label:&lt;resource_type&gt;:&lt;resource_uuid&gt;:&lt;key&gt;
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsFindByUrn: async (labelurn: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'labelurn' is not null or undefined
            if (labelurn === null || labelurn === undefined) {
                throw new RequiredError('labelurn','Required parameter labelurn was null or undefined when calling labelsFindByUrn.');
            }
            const localVarPath = `/labels/{labelurn}`
                .replace(`{${"labelurn"}}`, encodeURIComponent(String(labelurn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a complete list of labels that you have access to.
         * @summary List Labels 
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsGet: async (pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/labels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will remove a label from the snapshot.
         * @summary Delete a Label from Snapshot
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsLabelsDelete: async (snapshotId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'snapshotId' is not null or undefined
            if (snapshotId === null || snapshotId === undefined) {
                throw new RequiredError('snapshotId','Required parameter snapshotId was null or undefined when calling snapshotsLabelsDelete.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling snapshotsLabelsDelete.');
            }
            const localVarPath = `/snapshots/{snapshotId}/labels/{key}`
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will retrieve the properties of a associated label to a snapshot.
         * @summary Retrieve a Label of Snapshot
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsLabelsFindByKey: async (snapshotId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'snapshotId' is not null or undefined
            if (snapshotId === null || snapshotId === undefined) {
                throw new RequiredError('snapshotId','Required parameter snapshotId was null or undefined when calling snapshotsLabelsFindByKey.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling snapshotsLabelsFindByKey.');
            }
            const localVarPath = `/snapshots/{snapshotId}/labels/{key}`
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a list of all labels associated with a snapshot
         * @summary List all Snapshot Labels
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsLabelsGet: async (snapshotId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'snapshotId' is not null or undefined
            if (snapshotId === null || snapshotId === undefined) {
                throw new RequiredError('snapshotId','Required parameter snapshotId was null or undefined when calling snapshotsLabelsGet.');
            }
            const localVarPath = `/snapshots/{snapshotId}/labels`
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will add a label to the snapshot.
         * @summary Add a Label to Snapshot
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsLabelsPost: async (snapshotId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'snapshotId' is not null or undefined
            if (snapshotId === null || snapshotId === undefined) {
                throw new RequiredError('snapshotId','Required parameter snapshotId was null or undefined when calling snapshotsLabelsPost.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling snapshotsLabelsPost.');
            }
            const localVarPath = `/snapshots/{snapshotId}/labels`
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof label !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(label !== undefined ? label : {})
                : (label || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will modify the value of the label on a snapshot.
         * @summary Modify a Label of Snapshot
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsLabelsPut: async (snapshotId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'snapshotId' is not null or undefined
            if (snapshotId === null || snapshotId === undefined) {
                throw new RequiredError('snapshotId','Required parameter snapshotId was null or undefined when calling snapshotsLabelsPut.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling snapshotsLabelsPut.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling snapshotsLabelsPut.');
            }
            const localVarPath = `/snapshots/{snapshotId}/labels/{key}`
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof label !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(label !== undefined ? label : {})
                : (label || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LabelApi - functional programming interface
 * @export
 */
export const LabelApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This will remove a label from the data center.
         * @summary Delete a Label from Data Center
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLabelsDelete(datacenterId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersLabelsDelete(datacenterId, key, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will retrieve the properties of a associated label to a data center.
         * @summary Retrieve a Label of Data Center
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLabelsFindByKey(datacenterId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersLabelsFindByKey(datacenterId, key, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a list of all labels associated with a data center
         * @summary List all Data Center Labels
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLabelsGet(datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResources>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersLabelsGet(datacenterId, pretty, depth, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will add a label to the data center.
         * @summary Add a Label to Data Center
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLabelsPost(datacenterId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersLabelsPost(datacenterId, label, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will modify the value of the label on a data center.
         * @summary Modify a Label of Data Center
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLabelsPut(datacenterId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersLabelsPut(datacenterId, key, label, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will remove a label from the server.
         * @summary Delete a Label from Server
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersLabelsDelete(datacenterId: string, serverId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersServersLabelsDelete(datacenterId, serverId, key, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will retrieve the properties of a associated label to a server.
         * @summary Retrieve a Label of Server
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersLabelsFindByKey(datacenterId: string, serverId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersServersLabelsFindByKey(datacenterId, serverId, key, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a list of all labels associated with a server
         * @summary List all Server Labels
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersLabelsGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResources>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersServersLabelsGet(datacenterId, serverId, pretty, depth, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will add a label to the server.
         * @summary Add a Label to Server
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersLabelsPost(datacenterId: string, serverId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersServersLabelsPost(datacenterId, serverId, label, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will modify the value of the label on a server.
         * @summary Modify a Label of Server
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersServersLabelsPut(datacenterId: string, serverId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersServersLabelsPut(datacenterId, serverId, key, label, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will remove a label from the volume.
         * @summary Delete a Label from Volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersVolumesLabelsDelete(datacenterId: string, volumeId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersVolumesLabelsDelete(datacenterId, volumeId, key, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will retrieve the properties of a associated label to a volume.
         * @summary Retrieve a Label of Volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersVolumesLabelsFindByKey(datacenterId: string, volumeId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersVolumesLabelsFindByKey(datacenterId, volumeId, key, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a list of all labels associated with a volume
         * @summary List all Volume Labels
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersVolumesLabelsGet(datacenterId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResources>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersVolumesLabelsGet(datacenterId, volumeId, pretty, depth, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will add a label to the volume.
         * @summary Add a Label to Volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersVolumesLabelsPost(datacenterId: string, volumeId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersVolumesLabelsPost(datacenterId, volumeId, label, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will modify the value of the label on a volume.
         * @summary Modify a Label of Volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersVolumesLabelsPut(datacenterId: string, volumeId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).datacentersVolumesLabelsPut(datacenterId, volumeId, key, label, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will remove a label from the Ip Block.
         * @summary Delete a Label from IP Block
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipblocksLabelsDelete(ipblockId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).ipblocksLabelsDelete(ipblockId, key, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will retrieve the properties of a associated label to a Ip Block.
         * @summary Retrieve a Label of IP Block
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipblocksLabelsFindByKey(ipblockId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).ipblocksLabelsFindByKey(ipblockId, key, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a list of all labels associated with a IP Block
         * @summary List all Ip Block Labels
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipblocksLabelsGet(ipblockId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResources>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).ipblocksLabelsGet(ipblockId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will add a label to the Ip Block.
         * @summary Add a Label to IP Block
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipblocksLabelsPost(ipblockId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).ipblocksLabelsPost(ipblockId, label, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will modify the value of the label on a Ip Block.
         * @summary Modify a Label of IP Block
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipblocksLabelsPut(ipblockId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).ipblocksLabelsPut(ipblockId, key, label, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve the details of a specific label using its URN. A URN is for uniqueness of a Label and composed using urn:label:<resource_type>:<resource_uuid>:<key>
         * @summary Returns the label by its URN.
         * @param {string} labelurn The URN representing the unique ID of the label. A URN is for uniqueness of a Label and composed using urn:label:&lt;resource_type&gt;:&lt;resource_uuid&gt;:&lt;key&gt;
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelsFindByUrn(labelurn: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).labelsFindByUrn(labelurn, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a complete list of labels that you have access to.
         * @summary List Labels 
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async labelsGet(pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Labels>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).labelsGet(pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will remove a label from the snapshot.
         * @summary Delete a Label from Snapshot
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapshotsLabelsDelete(snapshotId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).snapshotsLabelsDelete(snapshotId, key, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will retrieve the properties of a associated label to a snapshot.
         * @summary Retrieve a Label of Snapshot
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapshotsLabelsFindByKey(snapshotId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).snapshotsLabelsFindByKey(snapshotId, key, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a list of all labels associated with a snapshot
         * @summary List all Snapshot Labels
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapshotsLabelsGet(snapshotId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResources>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).snapshotsLabelsGet(snapshotId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will add a label to the snapshot.
         * @summary Add a Label to Snapshot
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapshotsLabelsPost(snapshotId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).snapshotsLabelsPost(snapshotId, label, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will modify the value of the label on a snapshot.
         * @summary Modify a Label of Snapshot
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapshotsLabelsPut(snapshotId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelResource>> {
            const axiosArgs = await LabelApiAxiosParamCreator(configuration).snapshotsLabelsPut(snapshotId, key, label, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
    }
};

/**
 * LabelApi - factory interface
 * @export
 */
export const LabelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This will remove a label from the data center.
         * @summary Delete a Label from Data Center
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLabelsDelete(datacenterId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return LabelApiFp(configuration).datacentersLabelsDelete(datacenterId, key, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will retrieve the properties of a associated label to a data center.
         * @summary Retrieve a Label of Data Center
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLabelsFindByKey(datacenterId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).datacentersLabelsFindByKey(datacenterId, key, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a list of all labels associated with a data center
         * @summary List all Data Center Labels
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLabelsGet(datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<LabelResources> {
            return LabelApiFp(configuration).datacentersLabelsGet(datacenterId, pretty, depth, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * This will add a label to the data center.
         * @summary Add a Label to Data Center
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLabelsPost(datacenterId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).datacentersLabelsPost(datacenterId, label, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will modify the value of the label on a data center.
         * @summary Modify a Label of Data Center
         * @param {string} datacenterId The unique ID of the Data Center
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLabelsPut(datacenterId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).datacentersLabelsPut(datacenterId, key, label, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will remove a label from the server.
         * @summary Delete a Label from Server
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersLabelsDelete(datacenterId: string, serverId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return LabelApiFp(configuration).datacentersServersLabelsDelete(datacenterId, serverId, key, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will retrieve the properties of a associated label to a server.
         * @summary Retrieve a Label of Server
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersLabelsFindByKey(datacenterId: string, serverId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).datacentersServersLabelsFindByKey(datacenterId, serverId, key, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a list of all labels associated with a server
         * @summary List all Server Labels
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersLabelsGet(datacenterId: string, serverId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<LabelResources> {
            return LabelApiFp(configuration).datacentersServersLabelsGet(datacenterId, serverId, pretty, depth, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * This will add a label to the server.
         * @summary Add a Label to Server
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersLabelsPost(datacenterId: string, serverId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).datacentersServersLabelsPost(datacenterId, serverId, label, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will modify the value of the label on a server.
         * @summary Modify a Label of Server
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} serverId The unique ID of the Server
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersServersLabelsPut(datacenterId: string, serverId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).datacentersServersLabelsPut(datacenterId, serverId, key, label, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will remove a label from the volume.
         * @summary Delete a Label from Volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersVolumesLabelsDelete(datacenterId: string, volumeId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return LabelApiFp(configuration).datacentersVolumesLabelsDelete(datacenterId, volumeId, key, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will retrieve the properties of a associated label to a volume.
         * @summary Retrieve a Label of Volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersVolumesLabelsFindByKey(datacenterId: string, volumeId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).datacentersVolumesLabelsFindByKey(datacenterId, volumeId, key, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a list of all labels associated with a volume
         * @summary List all Volume Labels
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersVolumesLabelsGet(datacenterId: string, volumeId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<LabelResources> {
            return LabelApiFp(configuration).datacentersVolumesLabelsGet(datacenterId, volumeId, pretty, depth, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * This will add a label to the volume.
         * @summary Add a Label to Volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersVolumesLabelsPost(datacenterId: string, volumeId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).datacentersVolumesLabelsPost(datacenterId, volumeId, label, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will modify the value of the label on a volume.
         * @summary Modify a Label of Volume
         * @param {string} datacenterId The unique ID of the Datacenter
         * @param {string} volumeId The unique ID of the Volume
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersVolumesLabelsPut(datacenterId: string, volumeId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).datacentersVolumesLabelsPut(datacenterId, volumeId, key, label, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will remove a label from the Ip Block.
         * @summary Delete a Label from IP Block
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipblocksLabelsDelete(ipblockId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return LabelApiFp(configuration).ipblocksLabelsDelete(ipblockId, key, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will retrieve the properties of a associated label to a Ip Block.
         * @summary Retrieve a Label of IP Block
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipblocksLabelsFindByKey(ipblockId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).ipblocksLabelsFindByKey(ipblockId, key, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a list of all labels associated with a IP Block
         * @summary List all Ip Block Labels
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipblocksLabelsGet(ipblockId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResources> {
            return LabelApiFp(configuration).ipblocksLabelsGet(ipblockId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will add a label to the Ip Block.
         * @summary Add a Label to IP Block
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipblocksLabelsPost(ipblockId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).ipblocksLabelsPost(ipblockId, label, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will modify the value of the label on a Ip Block.
         * @summary Modify a Label of IP Block
         * @param {string} ipblockId The unique ID of the Ip Block
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipblocksLabelsPut(ipblockId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).ipblocksLabelsPut(ipblockId, key, label, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve the details of a specific label using its URN. A URN is for uniqueness of a Label and composed using urn:label:<resource_type>:<resource_uuid>:<key>
         * @summary Returns the label by its URN.
         * @param {string} labelurn The URN representing the unique ID of the label. A URN is for uniqueness of a Label and composed using urn:label:&lt;resource_type&gt;:&lt;resource_uuid&gt;:&lt;key&gt;
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsFindByUrn(labelurn: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Label> {
            return LabelApiFp(configuration).labelsFindByUrn(labelurn, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a complete list of labels that you have access to.
         * @summary List Labels 
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        labelsGet(pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Labels> {
            return LabelApiFp(configuration).labelsGet(pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will remove a label from the snapshot.
         * @summary Delete a Label from Snapshot
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsLabelsDelete(snapshotId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return LabelApiFp(configuration).snapshotsLabelsDelete(snapshotId, key, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will retrieve the properties of a associated label to a snapshot.
         * @summary Retrieve a Label of Snapshot
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {string} key The key of the Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsLabelsFindByKey(snapshotId: string, key: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).snapshotsLabelsFindByKey(snapshotId, key, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a list of all labels associated with a snapshot
         * @summary List all Snapshot Labels
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsLabelsGet(snapshotId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResources> {
            return LabelApiFp(configuration).snapshotsLabelsGet(snapshotId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will add a label to the snapshot.
         * @summary Add a Label to Snapshot
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {LabelResource} label Label to be added
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsLabelsPost(snapshotId: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).snapshotsLabelsPost(snapshotId, label, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will modify the value of the label on a snapshot.
         * @summary Modify a Label of Snapshot
         * @param {string} snapshotId The unique ID of the Snapshot
         * @param {string} key The key of the Label
         * @param {LabelResource} label Modified Label
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsLabelsPut(snapshotId: string, key: string, label: LabelResource, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LabelResource> {
            return LabelApiFp(configuration).snapshotsLabelsPut(snapshotId, key, label, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for datacentersLabelsDelete operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersLabelsDeleteRequest
 */
export interface LabelApiDatacentersLabelsDeleteRequest {
    /**
     * The unique ID of the Data Center
     * @type {string}
     * @memberof LabelApiDatacentersLabelsDelete
     */
    readonly datacenterId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiDatacentersLabelsDelete
     */
    readonly key: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersLabelsDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersLabelsDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersLabelsDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLabelsFindByKey operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersLabelsFindByKeyRequest
 */
export interface LabelApiDatacentersLabelsFindByKeyRequest {
    /**
     * The unique ID of the Data Center
     * @type {string}
     * @memberof LabelApiDatacentersLabelsFindByKey
     */
    readonly datacenterId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiDatacentersLabelsFindByKey
     */
    readonly key: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersLabelsFindByKey
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersLabelsFindByKey
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersLabelsFindByKey
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLabelsGet operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersLabelsGetRequest
 */
export interface LabelApiDatacentersLabelsGetRequest {
    /**
     * The unique ID of the Data Center
     * @type {string}
     * @memberof LabelApiDatacentersLabelsGet
     */
    readonly datacenterId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersLabelsGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersLabelsGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersLabelsGet
     */
    readonly xContractNumber?: number

    /**
     * the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof LabelApiDatacentersLabelsGet
     */
    readonly offset?: number

    /**
     * the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof LabelApiDatacentersLabelsGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersLabelsPost operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersLabelsPostRequest
 */
export interface LabelApiDatacentersLabelsPostRequest {
    /**
     * The unique ID of the Data Center
     * @type {string}
     * @memberof LabelApiDatacentersLabelsPost
     */
    readonly datacenterId: string

    /**
     * Label to be added
     * @type {LabelResource}
     * @memberof LabelApiDatacentersLabelsPost
     */
    readonly label: LabelResource

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersLabelsPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersLabelsPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersLabelsPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLabelsPut operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersLabelsPutRequest
 */
export interface LabelApiDatacentersLabelsPutRequest {
    /**
     * The unique ID of the Data Center
     * @type {string}
     * @memberof LabelApiDatacentersLabelsPut
     */
    readonly datacenterId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiDatacentersLabelsPut
     */
    readonly key: string

    /**
     * Modified Label
     * @type {LabelResource}
     * @memberof LabelApiDatacentersLabelsPut
     */
    readonly label: LabelResource

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersLabelsPut
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersLabelsPut
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersLabelsPut
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersLabelsDelete operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersServersLabelsDeleteRequest
 */
export interface LabelApiDatacentersServersLabelsDeleteRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof LabelApiDatacentersServersLabelsDelete
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof LabelApiDatacentersServersLabelsDelete
     */
    readonly serverId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiDatacentersServersLabelsDelete
     */
    readonly key: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersServersLabelsDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersServersLabelsDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersServersLabelsDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersLabelsFindByKey operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersServersLabelsFindByKeyRequest
 */
export interface LabelApiDatacentersServersLabelsFindByKeyRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof LabelApiDatacentersServersLabelsFindByKey
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof LabelApiDatacentersServersLabelsFindByKey
     */
    readonly serverId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiDatacentersServersLabelsFindByKey
     */
    readonly key: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersServersLabelsFindByKey
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersServersLabelsFindByKey
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersServersLabelsFindByKey
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersLabelsGet operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersServersLabelsGetRequest
 */
export interface LabelApiDatacentersServersLabelsGetRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof LabelApiDatacentersServersLabelsGet
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof LabelApiDatacentersServersLabelsGet
     */
    readonly serverId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersServersLabelsGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersServersLabelsGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersServersLabelsGet
     */
    readonly xContractNumber?: number

    /**
     * the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof LabelApiDatacentersServersLabelsGet
     */
    readonly offset?: number

    /**
     * the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof LabelApiDatacentersServersLabelsGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersServersLabelsPost operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersServersLabelsPostRequest
 */
export interface LabelApiDatacentersServersLabelsPostRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof LabelApiDatacentersServersLabelsPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof LabelApiDatacentersServersLabelsPost
     */
    readonly serverId: string

    /**
     * Label to be added
     * @type {LabelResource}
     * @memberof LabelApiDatacentersServersLabelsPost
     */
    readonly label: LabelResource

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersServersLabelsPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersServersLabelsPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersServersLabelsPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersServersLabelsPut operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersServersLabelsPutRequest
 */
export interface LabelApiDatacentersServersLabelsPutRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof LabelApiDatacentersServersLabelsPut
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Server
     * @type {string}
     * @memberof LabelApiDatacentersServersLabelsPut
     */
    readonly serverId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiDatacentersServersLabelsPut
     */
    readonly key: string

    /**
     * Modified Label
     * @type {LabelResource}
     * @memberof LabelApiDatacentersServersLabelsPut
     */
    readonly label: LabelResource

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersServersLabelsPut
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersServersLabelsPut
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersServersLabelsPut
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersVolumesLabelsDelete operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersVolumesLabelsDeleteRequest
 */
export interface LabelApiDatacentersVolumesLabelsDeleteRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof LabelApiDatacentersVolumesLabelsDelete
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Volume
     * @type {string}
     * @memberof LabelApiDatacentersVolumesLabelsDelete
     */
    readonly volumeId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiDatacentersVolumesLabelsDelete
     */
    readonly key: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersVolumesLabelsDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersVolumesLabelsDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersVolumesLabelsDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersVolumesLabelsFindByKey operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersVolumesLabelsFindByKeyRequest
 */
export interface LabelApiDatacentersVolumesLabelsFindByKeyRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof LabelApiDatacentersVolumesLabelsFindByKey
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Volume
     * @type {string}
     * @memberof LabelApiDatacentersVolumesLabelsFindByKey
     */
    readonly volumeId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiDatacentersVolumesLabelsFindByKey
     */
    readonly key: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersVolumesLabelsFindByKey
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersVolumesLabelsFindByKey
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersVolumesLabelsFindByKey
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersVolumesLabelsGet operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersVolumesLabelsGetRequest
 */
export interface LabelApiDatacentersVolumesLabelsGetRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof LabelApiDatacentersVolumesLabelsGet
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Volume
     * @type {string}
     * @memberof LabelApiDatacentersVolumesLabelsGet
     */
    readonly volumeId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersVolumesLabelsGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersVolumesLabelsGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersVolumesLabelsGet
     */
    readonly xContractNumber?: number

    /**
     * the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof LabelApiDatacentersVolumesLabelsGet
     */
    readonly offset?: number

    /**
     * the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof LabelApiDatacentersVolumesLabelsGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersVolumesLabelsPost operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersVolumesLabelsPostRequest
 */
export interface LabelApiDatacentersVolumesLabelsPostRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof LabelApiDatacentersVolumesLabelsPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Volume
     * @type {string}
     * @memberof LabelApiDatacentersVolumesLabelsPost
     */
    readonly volumeId: string

    /**
     * Label to be added
     * @type {LabelResource}
     * @memberof LabelApiDatacentersVolumesLabelsPost
     */
    readonly label: LabelResource

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersVolumesLabelsPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersVolumesLabelsPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersVolumesLabelsPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersVolumesLabelsPut operation in LabelApi.
 * @export
 * @interface LabelApiDatacentersVolumesLabelsPutRequest
 */
export interface LabelApiDatacentersVolumesLabelsPutRequest {
    /**
     * The unique ID of the Datacenter
     * @type {string}
     * @memberof LabelApiDatacentersVolumesLabelsPut
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Volume
     * @type {string}
     * @memberof LabelApiDatacentersVolumesLabelsPut
     */
    readonly volumeId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiDatacentersVolumesLabelsPut
     */
    readonly key: string

    /**
     * Modified Label
     * @type {LabelResource}
     * @memberof LabelApiDatacentersVolumesLabelsPut
     */
    readonly label: LabelResource

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiDatacentersVolumesLabelsPut
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiDatacentersVolumesLabelsPut
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiDatacentersVolumesLabelsPut
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for ipblocksLabelsDelete operation in LabelApi.
 * @export
 * @interface LabelApiIpblocksLabelsDeleteRequest
 */
export interface LabelApiIpblocksLabelsDeleteRequest {
    /**
     * The unique ID of the Ip Block
     * @type {string}
     * @memberof LabelApiIpblocksLabelsDelete
     */
    readonly ipblockId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiIpblocksLabelsDelete
     */
    readonly key: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiIpblocksLabelsDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiIpblocksLabelsDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiIpblocksLabelsDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for ipblocksLabelsFindByKey operation in LabelApi.
 * @export
 * @interface LabelApiIpblocksLabelsFindByKeyRequest
 */
export interface LabelApiIpblocksLabelsFindByKeyRequest {
    /**
     * The unique ID of the Ip Block
     * @type {string}
     * @memberof LabelApiIpblocksLabelsFindByKey
     */
    readonly ipblockId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiIpblocksLabelsFindByKey
     */
    readonly key: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiIpblocksLabelsFindByKey
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiIpblocksLabelsFindByKey
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiIpblocksLabelsFindByKey
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for ipblocksLabelsGet operation in LabelApi.
 * @export
 * @interface LabelApiIpblocksLabelsGetRequest
 */
export interface LabelApiIpblocksLabelsGetRequest {
    /**
     * The unique ID of the Ip Block
     * @type {string}
     * @memberof LabelApiIpblocksLabelsGet
     */
    readonly ipblockId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiIpblocksLabelsGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiIpblocksLabelsGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiIpblocksLabelsGet
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for ipblocksLabelsPost operation in LabelApi.
 * @export
 * @interface LabelApiIpblocksLabelsPostRequest
 */
export interface LabelApiIpblocksLabelsPostRequest {
    /**
     * The unique ID of the Ip Block
     * @type {string}
     * @memberof LabelApiIpblocksLabelsPost
     */
    readonly ipblockId: string

    /**
     * Label to be added
     * @type {LabelResource}
     * @memberof LabelApiIpblocksLabelsPost
     */
    readonly label: LabelResource

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiIpblocksLabelsPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiIpblocksLabelsPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiIpblocksLabelsPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for ipblocksLabelsPut operation in LabelApi.
 * @export
 * @interface LabelApiIpblocksLabelsPutRequest
 */
export interface LabelApiIpblocksLabelsPutRequest {
    /**
     * The unique ID of the Ip Block
     * @type {string}
     * @memberof LabelApiIpblocksLabelsPut
     */
    readonly ipblockId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiIpblocksLabelsPut
     */
    readonly key: string

    /**
     * Modified Label
     * @type {LabelResource}
     * @memberof LabelApiIpblocksLabelsPut
     */
    readonly label: LabelResource

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiIpblocksLabelsPut
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiIpblocksLabelsPut
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiIpblocksLabelsPut
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for labelsFindByUrn operation in LabelApi.
 * @export
 * @interface LabelApiLabelsFindByUrnRequest
 */
export interface LabelApiLabelsFindByUrnRequest {
    /**
     * The URN representing the unique ID of the label. A URN is for uniqueness of a Label and composed using urn:label:&lt;resource_type&gt;:&lt;resource_uuid&gt;:&lt;key&gt;
     * @type {string}
     * @memberof LabelApiLabelsFindByUrn
     */
    readonly labelurn: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiLabelsFindByUrn
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiLabelsFindByUrn
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiLabelsFindByUrn
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for labelsGet operation in LabelApi.
 * @export
 * @interface LabelApiLabelsGetRequest
 */
export interface LabelApiLabelsGetRequest {
    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiLabelsGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiLabelsGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiLabelsGet
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for snapshotsLabelsDelete operation in LabelApi.
 * @export
 * @interface LabelApiSnapshotsLabelsDeleteRequest
 */
export interface LabelApiSnapshotsLabelsDeleteRequest {
    /**
     * The unique ID of the Snapshot
     * @type {string}
     * @memberof LabelApiSnapshotsLabelsDelete
     */
    readonly snapshotId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiSnapshotsLabelsDelete
     */
    readonly key: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiSnapshotsLabelsDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiSnapshotsLabelsDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiSnapshotsLabelsDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for snapshotsLabelsFindByKey operation in LabelApi.
 * @export
 * @interface LabelApiSnapshotsLabelsFindByKeyRequest
 */
export interface LabelApiSnapshotsLabelsFindByKeyRequest {
    /**
     * The unique ID of the Snapshot
     * @type {string}
     * @memberof LabelApiSnapshotsLabelsFindByKey
     */
    readonly snapshotId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiSnapshotsLabelsFindByKey
     */
    readonly key: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiSnapshotsLabelsFindByKey
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiSnapshotsLabelsFindByKey
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiSnapshotsLabelsFindByKey
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for snapshotsLabelsGet operation in LabelApi.
 * @export
 * @interface LabelApiSnapshotsLabelsGetRequest
 */
export interface LabelApiSnapshotsLabelsGetRequest {
    /**
     * The unique ID of the Snapshot
     * @type {string}
     * @memberof LabelApiSnapshotsLabelsGet
     */
    readonly snapshotId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiSnapshotsLabelsGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiSnapshotsLabelsGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiSnapshotsLabelsGet
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for snapshotsLabelsPost operation in LabelApi.
 * @export
 * @interface LabelApiSnapshotsLabelsPostRequest
 */
export interface LabelApiSnapshotsLabelsPostRequest {
    /**
     * The unique ID of the Snapshot
     * @type {string}
     * @memberof LabelApiSnapshotsLabelsPost
     */
    readonly snapshotId: string

    /**
     * Label to be added
     * @type {LabelResource}
     * @memberof LabelApiSnapshotsLabelsPost
     */
    readonly label: LabelResource

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiSnapshotsLabelsPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiSnapshotsLabelsPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiSnapshotsLabelsPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for snapshotsLabelsPut operation in LabelApi.
 * @export
 * @interface LabelApiSnapshotsLabelsPutRequest
 */
export interface LabelApiSnapshotsLabelsPutRequest {
    /**
     * The unique ID of the Snapshot
     * @type {string}
     * @memberof LabelApiSnapshotsLabelsPut
     */
    readonly snapshotId: string

    /**
     * The key of the Label
     * @type {string}
     * @memberof LabelApiSnapshotsLabelsPut
     */
    readonly key: string

    /**
     * Modified Label
     * @type {LabelResource}
     * @memberof LabelApiSnapshotsLabelsPut
     */
    readonly label: LabelResource

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LabelApiSnapshotsLabelsPut
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LabelApiSnapshotsLabelsPut
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LabelApiSnapshotsLabelsPut
     */
    readonly xContractNumber?: number
}

/**
 * LabelApi - object-oriented interface
 * @export
 * @class LabelApi
 * @extends {BaseAPI}
 */
export class LabelApi extends BaseAPI {
    /**
     * This will remove a label from the data center.
     * @summary Delete a Label from Data Center
     * @param {LabelApiDatacentersLabelsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersLabelsDelete(requestParameters: LabelApiDatacentersLabelsDeleteRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersLabelsDelete(requestParameters.datacenterId, requestParameters.key, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will retrieve the properties of a associated label to a data center.
     * @summary Retrieve a Label of Data Center
     * @param {LabelApiDatacentersLabelsFindByKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersLabelsFindByKey(requestParameters: LabelApiDatacentersLabelsFindByKeyRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersLabelsFindByKey(requestParameters.datacenterId, requestParameters.key, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a list of all labels associated with a data center
     * @summary List all Data Center Labels
     * @param {LabelApiDatacentersLabelsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersLabelsGet(requestParameters: LabelApiDatacentersLabelsGetRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersLabelsGet(requestParameters.datacenterId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will add a label to the data center.
     * @summary Add a Label to Data Center
     * @param {LabelApiDatacentersLabelsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersLabelsPost(requestParameters: LabelApiDatacentersLabelsPostRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersLabelsPost(requestParameters.datacenterId, requestParameters.label, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will modify the value of the label on a data center.
     * @summary Modify a Label of Data Center
     * @param {LabelApiDatacentersLabelsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersLabelsPut(requestParameters: LabelApiDatacentersLabelsPutRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersLabelsPut(requestParameters.datacenterId, requestParameters.key, requestParameters.label, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will remove a label from the server.
     * @summary Delete a Label from Server
     * @param {LabelApiDatacentersServersLabelsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersServersLabelsDelete(requestParameters: LabelApiDatacentersServersLabelsDeleteRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersServersLabelsDelete(requestParameters.datacenterId, requestParameters.serverId, requestParameters.key, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will retrieve the properties of a associated label to a server.
     * @summary Retrieve a Label of Server
     * @param {LabelApiDatacentersServersLabelsFindByKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersServersLabelsFindByKey(requestParameters: LabelApiDatacentersServersLabelsFindByKeyRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersServersLabelsFindByKey(requestParameters.datacenterId, requestParameters.serverId, requestParameters.key, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a list of all labels associated with a server
     * @summary List all Server Labels
     * @param {LabelApiDatacentersServersLabelsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersServersLabelsGet(requestParameters: LabelApiDatacentersServersLabelsGetRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersServersLabelsGet(requestParameters.datacenterId, requestParameters.serverId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will add a label to the server.
     * @summary Add a Label to Server
     * @param {LabelApiDatacentersServersLabelsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersServersLabelsPost(requestParameters: LabelApiDatacentersServersLabelsPostRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersServersLabelsPost(requestParameters.datacenterId, requestParameters.serverId, requestParameters.label, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will modify the value of the label on a server.
     * @summary Modify a Label of Server
     * @param {LabelApiDatacentersServersLabelsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersServersLabelsPut(requestParameters: LabelApiDatacentersServersLabelsPutRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersServersLabelsPut(requestParameters.datacenterId, requestParameters.serverId, requestParameters.key, requestParameters.label, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will remove a label from the volume.
     * @summary Delete a Label from Volume
     * @param {LabelApiDatacentersVolumesLabelsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersVolumesLabelsDelete(requestParameters: LabelApiDatacentersVolumesLabelsDeleteRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersVolumesLabelsDelete(requestParameters.datacenterId, requestParameters.volumeId, requestParameters.key, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will retrieve the properties of a associated label to a volume.
     * @summary Retrieve a Label of Volume
     * @param {LabelApiDatacentersVolumesLabelsFindByKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersVolumesLabelsFindByKey(requestParameters: LabelApiDatacentersVolumesLabelsFindByKeyRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersVolumesLabelsFindByKey(requestParameters.datacenterId, requestParameters.volumeId, requestParameters.key, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a list of all labels associated with a volume
     * @summary List all Volume Labels
     * @param {LabelApiDatacentersVolumesLabelsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersVolumesLabelsGet(requestParameters: LabelApiDatacentersVolumesLabelsGetRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersVolumesLabelsGet(requestParameters.datacenterId, requestParameters.volumeId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will add a label to the volume.
     * @summary Add a Label to Volume
     * @param {LabelApiDatacentersVolumesLabelsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersVolumesLabelsPost(requestParameters: LabelApiDatacentersVolumesLabelsPostRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersVolumesLabelsPost(requestParameters.datacenterId, requestParameters.volumeId, requestParameters.label, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will modify the value of the label on a volume.
     * @summary Modify a Label of Volume
     * @param {LabelApiDatacentersVolumesLabelsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public datacentersVolumesLabelsPut(requestParameters: LabelApiDatacentersVolumesLabelsPutRequest, options?: any) {
        return LabelApiFp(this.configuration).datacentersVolumesLabelsPut(requestParameters.datacenterId, requestParameters.volumeId, requestParameters.key, requestParameters.label, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will remove a label from the Ip Block.
     * @summary Delete a Label from IP Block
     * @param {LabelApiIpblocksLabelsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public ipblocksLabelsDelete(requestParameters: LabelApiIpblocksLabelsDeleteRequest, options?: any) {
        return LabelApiFp(this.configuration).ipblocksLabelsDelete(requestParameters.ipblockId, requestParameters.key, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will retrieve the properties of a associated label to a Ip Block.
     * @summary Retrieve a Label of IP Block
     * @param {LabelApiIpblocksLabelsFindByKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public ipblocksLabelsFindByKey(requestParameters: LabelApiIpblocksLabelsFindByKeyRequest, options?: any) {
        return LabelApiFp(this.configuration).ipblocksLabelsFindByKey(requestParameters.ipblockId, requestParameters.key, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a list of all labels associated with a IP Block
     * @summary List all Ip Block Labels
     * @param {LabelApiIpblocksLabelsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public ipblocksLabelsGet(requestParameters: LabelApiIpblocksLabelsGetRequest, options?: any) {
        return LabelApiFp(this.configuration).ipblocksLabelsGet(requestParameters.ipblockId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will add a label to the Ip Block.
     * @summary Add a Label to IP Block
     * @param {LabelApiIpblocksLabelsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public ipblocksLabelsPost(requestParameters: LabelApiIpblocksLabelsPostRequest, options?: any) {
        return LabelApiFp(this.configuration).ipblocksLabelsPost(requestParameters.ipblockId, requestParameters.label, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will modify the value of the label on a Ip Block.
     * @summary Modify a Label of IP Block
     * @param {LabelApiIpblocksLabelsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public ipblocksLabelsPut(requestParameters: LabelApiIpblocksLabelsPutRequest, options?: any) {
        return LabelApiFp(this.configuration).ipblocksLabelsPut(requestParameters.ipblockId, requestParameters.key, requestParameters.label, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve the details of a specific label using its URN. A URN is for uniqueness of a Label and composed using urn:label:<resource_type>:<resource_uuid>:<key>
     * @summary Returns the label by its URN.
     * @param {LabelApiLabelsFindByUrnRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public labelsFindByUrn(requestParameters: LabelApiLabelsFindByUrnRequest, options?: any) {
        return LabelApiFp(this.configuration).labelsFindByUrn(requestParameters.labelurn, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a complete list of labels that you have access to.
     * @summary List Labels 
     * @param {LabelApiLabelsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public labelsGet(requestParameters: LabelApiLabelsGetRequest = {}, options?: any) {
        return LabelApiFp(this.configuration).labelsGet(requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will remove a label from the snapshot.
     * @summary Delete a Label from Snapshot
     * @param {LabelApiSnapshotsLabelsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public snapshotsLabelsDelete(requestParameters: LabelApiSnapshotsLabelsDeleteRequest, options?: any) {
        return LabelApiFp(this.configuration).snapshotsLabelsDelete(requestParameters.snapshotId, requestParameters.key, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will retrieve the properties of a associated label to a snapshot.
     * @summary Retrieve a Label of Snapshot
     * @param {LabelApiSnapshotsLabelsFindByKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public snapshotsLabelsFindByKey(requestParameters: LabelApiSnapshotsLabelsFindByKeyRequest, options?: any) {
        return LabelApiFp(this.configuration).snapshotsLabelsFindByKey(requestParameters.snapshotId, requestParameters.key, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a list of all labels associated with a snapshot
     * @summary List all Snapshot Labels
     * @param {LabelApiSnapshotsLabelsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public snapshotsLabelsGet(requestParameters: LabelApiSnapshotsLabelsGetRequest, options?: any) {
        return LabelApiFp(this.configuration).snapshotsLabelsGet(requestParameters.snapshotId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will add a label to the snapshot.
     * @summary Add a Label to Snapshot
     * @param {LabelApiSnapshotsLabelsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public snapshotsLabelsPost(requestParameters: LabelApiSnapshotsLabelsPostRequest, options?: any) {
        return LabelApiFp(this.configuration).snapshotsLabelsPost(requestParameters.snapshotId, requestParameters.label, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will modify the value of the label on a snapshot.
     * @summary Modify a Label of Snapshot
     * @param {LabelApiSnapshotsLabelsPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelApi
     */
    public snapshotsLabelsPut(requestParameters: LabelApiSnapshotsLabelsPutRequest, options?: any) {
        return LabelApiFp(this.configuration).snapshotsLabelsPut(requestParameters.snapshotId, requestParameters.key, requestParameters.label, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }
}
