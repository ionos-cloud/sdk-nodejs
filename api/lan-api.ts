/* tslint:disable */
/* eslint-disable */
/**
 * CLOUD API
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * The version of the OpenAPI document: 5.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration, DEFAULT_MAX_RETRIES, DEFAULT_MAX_WAIT_TIME } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, backOff, runRequest } from '../base';
// @ts-ignore
import { Lan } from '../model';
// @ts-ignore
import { LanNics } from '../model';
// @ts-ignore
import { LanPost } from '../model';
// @ts-ignore
import { LanProperties } from '../model';
// @ts-ignore
import { Lans } from '../model';
// @ts-ignore
import { Nic } from '../model';
/**
 * LanApi - axios parameter creator
 * @export
 */
export const LanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes the specific Lan
         * @summary Delete a Lan.
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansDelete: async (datacenterId: string, lanId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLansDelete.');
            }
            // verify required parameter 'lanId' is not null or undefined
            if (lanId === null || lanId === undefined) {
                throw new RequiredError('lanId','Required parameter lanId was null or undefined when calling datacentersLansDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}/lans/{lanId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"lanId"}}`, encodeURIComponent(String(lanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the attributes of a given LAN
         * @summary Retrieve a Lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansFindById: async (datacenterId: string, lanId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLansFindById.');
            }
            // verify required parameter 'lanId' is not null or undefined
            if (lanId === null || lanId === undefined) {
                throw new RequiredError('lanId','Required parameter lanId was null or undefined when calling datacentersLansFindById.');
            }
            const localVarPath = `/datacenters/{datacenterId}/lans/{lanId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"lanId"}}`, encodeURIComponent(String(lanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of LANs within the datacenter
         * @summary List Lans
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansGet: async (datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLansGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/lans`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will retrieve the properties of an attached nic.
         * @summary Retrieve a nic attached to lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansNicsFindById: async (datacenterId: string, lanId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLansNicsFindById.');
            }
            // verify required parameter 'lanId' is not null or undefined
            if (lanId === null || lanId === undefined) {
                throw new RequiredError('lanId','Required parameter lanId was null or undefined when calling datacentersLansNicsFindById.');
            }
            // verify required parameter 'nicId' is not null or undefined
            if (nicId === null || nicId === undefined) {
                throw new RequiredError('nicId','Required parameter nicId was null or undefined when calling datacentersLansNicsFindById.');
            }
            const localVarPath = `/datacenters/{datacenterId}/lans/{lanId}/nics/{nicId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"lanId"}}`, encodeURIComponent(String(lanId)))
                .replace(`{${"nicId"}}`, encodeURIComponent(String(nicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a list of nics attached to a lan
         * @summary List Lan Members 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansNicsGet: async (datacenterId: string, lanId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLansNicsGet.');
            }
            // verify required parameter 'lanId' is not null or undefined
            if (lanId === null || lanId === undefined) {
                throw new RequiredError('lanId','Required parameter lanId was null or undefined when calling datacentersLansNicsGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/lans/{lanId}/nics`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"lanId"}}`, encodeURIComponent(String(lanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will attach a pre-existing nic to a lan. 
         * @summary Attach a nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {Nic} nic Nic to be attached
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansNicsPost: async (datacenterId: string, lanId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLansNicsPost.');
            }
            // verify required parameter 'lanId' is not null or undefined
            if (lanId === null || lanId === undefined) {
                throw new RequiredError('lanId','Required parameter lanId was null or undefined when calling datacentersLansNicsPost.');
            }
            // verify required parameter 'nic' is not null or undefined
            if (nic === null || nic === undefined) {
                throw new RequiredError('nic','Required parameter nic was null or undefined when calling datacentersLansNicsPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/lans/{lanId}/nics`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"lanId"}}`, encodeURIComponent(String(lanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof nic !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(nic !== undefined ? nic : {})
                : (nic || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use update attributes of a resource
         * @summary Partially modify a Lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {LanProperties} lan Modified Lan
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansPatch: async (datacenterId: string, lanId: string, lan: LanProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLansPatch.');
            }
            // verify required parameter 'lanId' is not null or undefined
            if (lanId === null || lanId === undefined) {
                throw new RequiredError('lanId','Required parameter lanId was null or undefined when calling datacentersLansPatch.');
            }
            // verify required parameter 'lan' is not null or undefined
            if (lan === null || lan === undefined) {
                throw new RequiredError('lan','Required parameter lan was null or undefined when calling datacentersLansPatch.');
            }
            const localVarPath = `/datacenters/{datacenterId}/lans/{lanId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"lanId"}}`, encodeURIComponent(String(lanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof lan !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(lan !== undefined ? lan : {})
                : (lan || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a LAN within the datacenter
         * @summary Create a Lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {LanPost} lan Lan to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansPost: async (datacenterId: string, lan: LanPost, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLansPost.');
            }
            // verify required parameter 'lan' is not null or undefined
            if (lan === null || lan === undefined) {
                throw new RequiredError('lan','Required parameter lan was null or undefined when calling datacentersLansPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/lans`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof lan !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(lan !== undefined ? lan : {})
                : (lan || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use update attributes of a resource
         * @summary Modify a Lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {Lan} lan Modified Lan
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansPut: async (datacenterId: string, lanId: string, lan: Lan, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLansPut.');
            }
            // verify required parameter 'lanId' is not null or undefined
            if (lanId === null || lanId === undefined) {
                throw new RequiredError('lanId','Required parameter lanId was null or undefined when calling datacentersLansPut.');
            }
            // verify required parameter 'lan' is not null or undefined
            if (lan === null || lan === undefined) {
                throw new RequiredError('lan','Required parameter lan was null or undefined when calling datacentersLansPut.');
            }
            const localVarPath = `/datacenters/{datacenterId}/lans/{lanId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"lanId"}}`, encodeURIComponent(String(lanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof lan !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(lan !== undefined ? lan : {})
                : (lan || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanApi - functional programming interface
 * @export
 */
export const LanApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Removes the specific Lan
         * @summary Delete a Lan.
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLansDelete(datacenterId: string, lanId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await LanApiAxiosParamCreator(configuration).datacentersLansDelete(datacenterId, lanId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieves the attributes of a given LAN
         * @summary Retrieve a Lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLansFindById(datacenterId: string, lanId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lan>> {
            const axiosArgs = await LanApiAxiosParamCreator(configuration).datacentersLansFindById(datacenterId, lanId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieve a list of LANs within the datacenter
         * @summary List Lans
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLansGet(datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lans>> {
            const axiosArgs = await LanApiAxiosParamCreator(configuration).datacentersLansGet(datacenterId, pretty, depth, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will retrieve the properties of an attached nic.
         * @summary Retrieve a nic attached to lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLansNicsFindById(datacenterId: string, lanId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Nic>> {
            const axiosArgs = await LanApiAxiosParamCreator(configuration).datacentersLansNicsFindById(datacenterId, lanId, nicId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a list of nics attached to a lan
         * @summary List Lan Members 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLansNicsGet(datacenterId: string, lanId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanNics>> {
            const axiosArgs = await LanApiAxiosParamCreator(configuration).datacentersLansNicsGet(datacenterId, lanId, pretty, depth, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will attach a pre-existing nic to a lan. 
         * @summary Attach a nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {Nic} nic Nic to be attached
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLansNicsPost(datacenterId: string, lanId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Nic>> {
            const axiosArgs = await LanApiAxiosParamCreator(configuration).datacentersLansNicsPost(datacenterId, lanId, nic, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can use update attributes of a resource
         * @summary Partially modify a Lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {LanProperties} lan Modified Lan
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLansPatch(datacenterId: string, lanId: string, lan: LanProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lan>> {
            const axiosArgs = await LanApiAxiosParamCreator(configuration).datacentersLansPatch(datacenterId, lanId, lan, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Creates a LAN within the datacenter
         * @summary Create a Lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {LanPost} lan Lan to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLansPost(datacenterId: string, lan: LanPost, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanPost>> {
            const axiosArgs = await LanApiAxiosParamCreator(configuration).datacentersLansPost(datacenterId, lan, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can use update attributes of a resource
         * @summary Modify a Lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {Lan} lan Modified Lan
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLansPut(datacenterId: string, lanId: string, lan: Lan, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lan>> {
            const axiosArgs = await LanApiAxiosParamCreator(configuration).datacentersLansPut(datacenterId, lanId, lan, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
    }
};

/**
 * LanApi - factory interface
 * @export
 */
export const LanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Removes the specific Lan
         * @summary Delete a Lan.
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansDelete(datacenterId: string, lanId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return LanApiFp(configuration).datacentersLansDelete(datacenterId, lanId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the attributes of a given LAN
         * @summary Retrieve a Lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansFindById(datacenterId: string, lanId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Lan> {
            return LanApiFp(configuration).datacentersLansFindById(datacenterId, lanId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of LANs within the datacenter
         * @summary List Lans
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansGet(datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<Lans> {
            return LanApiFp(configuration).datacentersLansGet(datacenterId, pretty, depth, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * This will retrieve the properties of an attached nic.
         * @summary Retrieve a nic attached to lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansNicsFindById(datacenterId: string, lanId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Nic> {
            return LanApiFp(configuration).datacentersLansNicsFindById(datacenterId, lanId, nicId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a list of nics attached to a lan
         * @summary List Lan Members 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansNicsGet(datacenterId: string, lanId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<LanNics> {
            return LanApiFp(configuration).datacentersLansNicsGet(datacenterId, lanId, pretty, depth, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * This will attach a pre-existing nic to a lan. 
         * @summary Attach a nic
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {Nic} nic Nic to be attached
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansNicsPost(datacenterId: string, lanId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Nic> {
            return LanApiFp(configuration).datacentersLansNicsPost(datacenterId, lanId, nic, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use update attributes of a resource
         * @summary Partially modify a Lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {LanProperties} lan Modified Lan
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansPatch(datacenterId: string, lanId: string, lan: LanProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Lan> {
            return LanApiFp(configuration).datacentersLansPatch(datacenterId, lanId, lan, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a LAN within the datacenter
         * @summary Create a Lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {LanPost} lan Lan to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansPost(datacenterId: string, lan: LanPost, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<LanPost> {
            return LanApiFp(configuration).datacentersLansPost(datacenterId, lan, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use update attributes of a resource
         * @summary Modify a Lan
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} lanId The unique ID of the LAN
         * @param {Lan} lan Modified Lan
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLansPut(datacenterId: string, lanId: string, lan: Lan, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Lan> {
            return LanApiFp(configuration).datacentersLansPut(datacenterId, lanId, lan, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for datacentersLansDelete operation in LanApi.
 * @export
 * @interface LanApiDatacentersLansDeleteRequest
 */
export interface LanApiDatacentersLansDeleteRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LanApiDatacentersLansDelete
     */
    readonly datacenterId: string

    /**
     * The unique ID of the LAN
     * @type {string}
     * @memberof LanApiDatacentersLansDelete
     */
    readonly lanId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LanApiDatacentersLansDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LanApiDatacentersLansDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LanApiDatacentersLansDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLansFindById operation in LanApi.
 * @export
 * @interface LanApiDatacentersLansFindByIdRequest
 */
export interface LanApiDatacentersLansFindByIdRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LanApiDatacentersLansFindById
     */
    readonly datacenterId: string

    /**
     * The unique ID of the LAN
     * @type {string}
     * @memberof LanApiDatacentersLansFindById
     */
    readonly lanId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LanApiDatacentersLansFindById
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LanApiDatacentersLansFindById
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LanApiDatacentersLansFindById
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLansGet operation in LanApi.
 * @export
 * @interface LanApiDatacentersLansGetRequest
 */
export interface LanApiDatacentersLansGetRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LanApiDatacentersLansGet
     */
    readonly datacenterId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LanApiDatacentersLansGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LanApiDatacentersLansGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LanApiDatacentersLansGet
     */
    readonly xContractNumber?: number

    /**
     * the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof LanApiDatacentersLansGet
     */
    readonly offset?: number

    /**
     * the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof LanApiDatacentersLansGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersLansNicsFindById operation in LanApi.
 * @export
 * @interface LanApiDatacentersLansNicsFindByIdRequest
 */
export interface LanApiDatacentersLansNicsFindByIdRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LanApiDatacentersLansNicsFindById
     */
    readonly datacenterId: string

    /**
     * The unique ID of the LAN
     * @type {string}
     * @memberof LanApiDatacentersLansNicsFindById
     */
    readonly lanId: string

    /**
     * The unique ID of the NIC
     * @type {string}
     * @memberof LanApiDatacentersLansNicsFindById
     */
    readonly nicId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LanApiDatacentersLansNicsFindById
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LanApiDatacentersLansNicsFindById
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LanApiDatacentersLansNicsFindById
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLansNicsGet operation in LanApi.
 * @export
 * @interface LanApiDatacentersLansNicsGetRequest
 */
export interface LanApiDatacentersLansNicsGetRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LanApiDatacentersLansNicsGet
     */
    readonly datacenterId: string

    /**
     * The unique ID of the LAN
     * @type {string}
     * @memberof LanApiDatacentersLansNicsGet
     */
    readonly lanId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LanApiDatacentersLansNicsGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LanApiDatacentersLansNicsGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LanApiDatacentersLansNicsGet
     */
    readonly xContractNumber?: number

    /**
     * the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof LanApiDatacentersLansNicsGet
     */
    readonly offset?: number

    /**
     * the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof LanApiDatacentersLansNicsGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersLansNicsPost operation in LanApi.
 * @export
 * @interface LanApiDatacentersLansNicsPostRequest
 */
export interface LanApiDatacentersLansNicsPostRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LanApiDatacentersLansNicsPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the LAN
     * @type {string}
     * @memberof LanApiDatacentersLansNicsPost
     */
    readonly lanId: string

    /**
     * Nic to be attached
     * @type {Nic}
     * @memberof LanApiDatacentersLansNicsPost
     */
    readonly nic: Nic

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LanApiDatacentersLansNicsPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LanApiDatacentersLansNicsPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LanApiDatacentersLansNicsPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLansPatch operation in LanApi.
 * @export
 * @interface LanApiDatacentersLansPatchRequest
 */
export interface LanApiDatacentersLansPatchRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LanApiDatacentersLansPatch
     */
    readonly datacenterId: string

    /**
     * The unique ID of the LAN
     * @type {string}
     * @memberof LanApiDatacentersLansPatch
     */
    readonly lanId: string

    /**
     * Modified Lan
     * @type {LanProperties}
     * @memberof LanApiDatacentersLansPatch
     */
    readonly lan: LanProperties

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LanApiDatacentersLansPatch
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LanApiDatacentersLansPatch
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LanApiDatacentersLansPatch
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLansPost operation in LanApi.
 * @export
 * @interface LanApiDatacentersLansPostRequest
 */
export interface LanApiDatacentersLansPostRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LanApiDatacentersLansPost
     */
    readonly datacenterId: string

    /**
     * Lan to be created
     * @type {LanPost}
     * @memberof LanApiDatacentersLansPost
     */
    readonly lan: LanPost

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LanApiDatacentersLansPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LanApiDatacentersLansPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LanApiDatacentersLansPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLansPut operation in LanApi.
 * @export
 * @interface LanApiDatacentersLansPutRequest
 */
export interface LanApiDatacentersLansPutRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LanApiDatacentersLansPut
     */
    readonly datacenterId: string

    /**
     * The unique ID of the LAN
     * @type {string}
     * @memberof LanApiDatacentersLansPut
     */
    readonly lanId: string

    /**
     * Modified Lan
     * @type {Lan}
     * @memberof LanApiDatacentersLansPut
     */
    readonly lan: Lan

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LanApiDatacentersLansPut
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LanApiDatacentersLansPut
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LanApiDatacentersLansPut
     */
    readonly xContractNumber?: number
}

/**
 * LanApi - object-oriented interface
 * @export
 * @class LanApi
 * @extends {BaseAPI}
 */
export class LanApi extends BaseAPI {
    /**
     * Removes the specific Lan
     * @summary Delete a Lan.
     * @param {LanApiDatacentersLansDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanApi
     */
    public datacentersLansDelete(requestParameters: LanApiDatacentersLansDeleteRequest, options?: any) {
        return LanApiFp(this.configuration).datacentersLansDelete(requestParameters.datacenterId, requestParameters.lanId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the attributes of a given LAN
     * @summary Retrieve a Lan
     * @param {LanApiDatacentersLansFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanApi
     */
    public datacentersLansFindById(requestParameters: LanApiDatacentersLansFindByIdRequest, options?: any) {
        return LanApiFp(this.configuration).datacentersLansFindById(requestParameters.datacenterId, requestParameters.lanId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of LANs within the datacenter
     * @summary List Lans
     * @param {LanApiDatacentersLansGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanApi
     */
    public datacentersLansGet(requestParameters: LanApiDatacentersLansGetRequest, options?: any) {
        return LanApiFp(this.configuration).datacentersLansGet(requestParameters.datacenterId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will retrieve the properties of an attached nic.
     * @summary Retrieve a nic attached to lan
     * @param {LanApiDatacentersLansNicsFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanApi
     */
    public datacentersLansNicsFindById(requestParameters: LanApiDatacentersLansNicsFindByIdRequest, options?: any) {
        return LanApiFp(this.configuration).datacentersLansNicsFindById(requestParameters.datacenterId, requestParameters.lanId, requestParameters.nicId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a list of nics attached to a lan
     * @summary List Lan Members 
     * @param {LanApiDatacentersLansNicsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanApi
     */
    public datacentersLansNicsGet(requestParameters: LanApiDatacentersLansNicsGetRequest, options?: any) {
        return LanApiFp(this.configuration).datacentersLansNicsGet(requestParameters.datacenterId, requestParameters.lanId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will attach a pre-existing nic to a lan. 
     * @summary Attach a nic
     * @param {LanApiDatacentersLansNicsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanApi
     */
    public datacentersLansNicsPost(requestParameters: LanApiDatacentersLansNicsPostRequest, options?: any) {
        return LanApiFp(this.configuration).datacentersLansNicsPost(requestParameters.datacenterId, requestParameters.lanId, requestParameters.nic, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use update attributes of a resource
     * @summary Partially modify a Lan
     * @param {LanApiDatacentersLansPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanApi
     */
    public datacentersLansPatch(requestParameters: LanApiDatacentersLansPatchRequest, options?: any) {
        return LanApiFp(this.configuration).datacentersLansPatch(requestParameters.datacenterId, requestParameters.lanId, requestParameters.lan, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a LAN within the datacenter
     * @summary Create a Lan
     * @param {LanApiDatacentersLansPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanApi
     */
    public datacentersLansPost(requestParameters: LanApiDatacentersLansPostRequest, options?: any) {
        return LanApiFp(this.configuration).datacentersLansPost(requestParameters.datacenterId, requestParameters.lan, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use update attributes of a resource
     * @summary Modify a Lan
     * @param {LanApiDatacentersLansPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanApi
     */
    public datacentersLansPut(requestParameters: LanApiDatacentersLansPutRequest, options?: any) {
        return LanApiFp(this.configuration).datacentersLansPut(requestParameters.datacenterId, requestParameters.lanId, requestParameters.lan, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }
}
