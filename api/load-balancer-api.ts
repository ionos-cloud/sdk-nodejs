/* tslint:disable */
/* eslint-disable */
/**
 * CLOUD API
 * An enterprise-grade Infrastructure is provided as a Service (IaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.   The API allows you to perform a variety of management tasks such as spinning up additional servers, adding volumes, adjusting networking, and so forth. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive.
 *
 * The version of the OpenAPI document: 5.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration, DEFAULT_MAX_RETRIES, DEFAULT_MAX_WAIT_TIME } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, backOff, runRequest } from '../base';
// @ts-ignore
import { BalancedNics } from '../model';
// @ts-ignore
import { Loadbalancer } from '../model';
// @ts-ignore
import { LoadbalancerProperties } from '../model';
// @ts-ignore
import { Loadbalancers } from '../model';
// @ts-ignore
import { Nic } from '../model';
/**
 * LoadBalancerApi - axios parameter creator
 * @export
 */
export const LoadBalancerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will remove a nic from Load Balancer
         * @summary Detach a nic from loadbalancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersBalancednicsDelete: async (datacenterId: string, loadbalancerId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLoadbalancersBalancednicsDelete.');
            }
            // verify required parameter 'loadbalancerId' is not null or undefined
            if (loadbalancerId === null || loadbalancerId === undefined) {
                throw new RequiredError('loadbalancerId','Required parameter loadbalancerId was null or undefined when calling datacentersLoadbalancersBalancednicsDelete.');
            }
            // verify required parameter 'nicId' is not null or undefined
            if (nicId === null || nicId === undefined) {
                throw new RequiredError('nicId','Required parameter nicId was null or undefined when calling datacentersLoadbalancersBalancednicsDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}/balancednics/{nicId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"loadbalancerId"}}`, encodeURIComponent(String(loadbalancerId)))
                .replace(`{${"nicId"}}`, encodeURIComponent(String(nicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will retrieve the properties of an attached nic.
         * @summary Retrieve a nic attached to Load Balancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersBalancednicsFindByNicId: async (datacenterId: string, loadbalancerId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLoadbalancersBalancednicsFindByNicId.');
            }
            // verify required parameter 'loadbalancerId' is not null or undefined
            if (loadbalancerId === null || loadbalancerId === undefined) {
                throw new RequiredError('loadbalancerId','Required parameter loadbalancerId was null or undefined when calling datacentersLoadbalancersBalancednicsFindByNicId.');
            }
            // verify required parameter 'nicId' is not null or undefined
            if (nicId === null || nicId === undefined) {
                throw new RequiredError('nicId','Required parameter nicId was null or undefined when calling datacentersLoadbalancersBalancednicsFindByNicId.');
            }
            const localVarPath = `/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}/balancednics/{nicId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"loadbalancerId"}}`, encodeURIComponent(String(loadbalancerId)))
                .replace(`{${"nicId"}}`, encodeURIComponent(String(nicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can retrieve a list of nics attached to a Load Balancer
         * @summary List Load Balancer Members 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersBalancednicsGet: async (datacenterId: string, loadbalancerId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLoadbalancersBalancednicsGet.');
            }
            // verify required parameter 'loadbalancerId' is not null or undefined
            if (loadbalancerId === null || loadbalancerId === undefined) {
                throw new RequiredError('loadbalancerId','Required parameter loadbalancerId was null or undefined when calling datacentersLoadbalancersBalancednicsGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}/balancednics`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"loadbalancerId"}}`, encodeURIComponent(String(loadbalancerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This will attach a pre-existing nic to a Load Balancer. 
         * @summary Attach a nic to Load Balancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {Nic} nic Nic id to be attached
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersBalancednicsPost: async (datacenterId: string, loadbalancerId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLoadbalancersBalancednicsPost.');
            }
            // verify required parameter 'loadbalancerId' is not null or undefined
            if (loadbalancerId === null || loadbalancerId === undefined) {
                throw new RequiredError('loadbalancerId','Required parameter loadbalancerId was null or undefined when calling datacentersLoadbalancersBalancednicsPost.');
            }
            // verify required parameter 'nic' is not null or undefined
            if (nic === null || nic === undefined) {
                throw new RequiredError('nic','Required parameter nic was null or undefined when calling datacentersLoadbalancersBalancednicsPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}/balancednics`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"loadbalancerId"}}`, encodeURIComponent(String(loadbalancerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof nic !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(nic !== undefined ? nic : {})
                : (nic || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the specific Loadbalancer
         * @summary Delete a Loadbalancer.
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersDelete: async (datacenterId: string, loadbalancerId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLoadbalancersDelete.');
            }
            // verify required parameter 'loadbalancerId' is not null or undefined
            if (loadbalancerId === null || loadbalancerId === undefined) {
                throw new RequiredError('loadbalancerId','Required parameter loadbalancerId was null or undefined when calling datacentersLoadbalancersDelete.');
            }
            const localVarPath = `/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"loadbalancerId"}}`, encodeURIComponent(String(loadbalancerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the attributes of a given Loadbalancer
         * @summary Retrieve a loadbalancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersFindById: async (datacenterId: string, loadbalancerId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLoadbalancersFindById.');
            }
            // verify required parameter 'loadbalancerId' is not null or undefined
            if (loadbalancerId === null || loadbalancerId === undefined) {
                throw new RequiredError('loadbalancerId','Required parameter loadbalancerId was null or undefined when calling datacentersLoadbalancersFindById.');
            }
            const localVarPath = `/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"loadbalancerId"}}`, encodeURIComponent(String(loadbalancerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of Load Balancers within the datacenter
         * @summary List Load Balancers
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersGet: async (datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLoadbalancersGet.');
            }
            const localVarPath = `/datacenters/{datacenterId}/loadbalancers`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use update attributes of a resource
         * @summary Partially modify a Loadbalancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {LoadbalancerProperties} loadbalancer Modified Loadbalancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersPatch: async (datacenterId: string, loadbalancerId: string, loadbalancer: LoadbalancerProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLoadbalancersPatch.');
            }
            // verify required parameter 'loadbalancerId' is not null or undefined
            if (loadbalancerId === null || loadbalancerId === undefined) {
                throw new RequiredError('loadbalancerId','Required parameter loadbalancerId was null or undefined when calling datacentersLoadbalancersPatch.');
            }
            // verify required parameter 'loadbalancer' is not null or undefined
            if (loadbalancer === null || loadbalancer === undefined) {
                throw new RequiredError('loadbalancer','Required parameter loadbalancer was null or undefined when calling datacentersLoadbalancersPatch.');
            }
            const localVarPath = `/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"loadbalancerId"}}`, encodeURIComponent(String(loadbalancerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loadbalancer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loadbalancer !== undefined ? loadbalancer : {})
                : (loadbalancer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Loadbalancer within the datacenter
         * @summary Create a Load Balancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {Loadbalancer} loadbalancer Loadbalancer to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersPost: async (datacenterId: string, loadbalancer: Loadbalancer, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLoadbalancersPost.');
            }
            // verify required parameter 'loadbalancer' is not null or undefined
            if (loadbalancer === null || loadbalancer === undefined) {
                throw new RequiredError('loadbalancer','Required parameter loadbalancer was null or undefined when calling datacentersLoadbalancersPost.');
            }
            const localVarPath = `/datacenters/{datacenterId}/loadbalancers`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loadbalancer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loadbalancer !== undefined ? loadbalancer : {})
                : (loadbalancer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can use update attributes of a resource
         * @summary Modify a Load Balancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {Loadbalancer} loadbalancer Modified Loadbalancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersPut: async (datacenterId: string, loadbalancerId: string, loadbalancer: Loadbalancer, pretty?: boolean, depth?: number, xContractNumber?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datacenterId' is not null or undefined
            if (datacenterId === null || datacenterId === undefined) {
                throw new RequiredError('datacenterId','Required parameter datacenterId was null or undefined when calling datacentersLoadbalancersPut.');
            }
            // verify required parameter 'loadbalancerId' is not null or undefined
            if (loadbalancerId === null || loadbalancerId === undefined) {
                throw new RequiredError('loadbalancerId','Required parameter loadbalancerId was null or undefined when calling datacentersLoadbalancersPut.');
            }
            // verify required parameter 'loadbalancer' is not null or undefined
            if (loadbalancer === null || loadbalancer === undefined) {
                throw new RequiredError('loadbalancer','Required parameter loadbalancer was null or undefined when calling datacentersLoadbalancersPut.');
            }
            const localVarPath = `/datacenters/{datacenterId}/loadbalancers/{loadbalancerId}`
                .replace(`{${"datacenterId"}}`, encodeURIComponent(String(datacenterId)))
                .replace(`{${"loadbalancerId"}}`, encodeURIComponent(String(loadbalancerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic Authentication required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication Token Authentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if ((pretty === undefined) && (configuration !== undefined)) {
                pretty = configuration.getDefaultParamValue('pretty');
            }
            if (pretty !== undefined) {
                localVarQueryParameter['pretty'] = pretty;
            }

            if ((depth === undefined) && (configuration !== undefined)) {
                depth = configuration.getDefaultParamValue('depth');
            }
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if ((xContractNumber === undefined) && (configuration !== undefined)) {
                xContractNumber = configuration.getDefaultParamValue('xContractNumber');
            }
            if (xContractNumber !== undefined && xContractNumber !== null) {
                localVarHeaderParameter['X-Contract-Number'] = String(JSON.stringify(xContractNumber));
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof loadbalancer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(loadbalancer !== undefined ? loadbalancer : {})
                : (loadbalancer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoadBalancerApi - functional programming interface
 * @export
 */
export const LoadBalancerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This will remove a nic from Load Balancer
         * @summary Detach a nic from loadbalancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLoadbalancersBalancednicsDelete(datacenterId: string, loadbalancerId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await LoadBalancerApiAxiosParamCreator(configuration).datacentersLoadbalancersBalancednicsDelete(datacenterId, loadbalancerId, nicId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will retrieve the properties of an attached nic.
         * @summary Retrieve a nic attached to Load Balancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLoadbalancersBalancednicsFindByNicId(datacenterId: string, loadbalancerId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Nic>> {
            const axiosArgs = await LoadBalancerApiAxiosParamCreator(configuration).datacentersLoadbalancersBalancednicsFindByNicId(datacenterId, loadbalancerId, nicId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can retrieve a list of nics attached to a Load Balancer
         * @summary List Load Balancer Members 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLoadbalancersBalancednicsGet(datacenterId: string, loadbalancerId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalancedNics>> {
            const axiosArgs = await LoadBalancerApiAxiosParamCreator(configuration).datacentersLoadbalancersBalancednicsGet(datacenterId, loadbalancerId, pretty, depth, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * This will attach a pre-existing nic to a Load Balancer. 
         * @summary Attach a nic to Load Balancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {Nic} nic Nic id to be attached
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLoadbalancersBalancednicsPost(datacenterId: string, loadbalancerId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Nic>> {
            const axiosArgs = await LoadBalancerApiAxiosParamCreator(configuration).datacentersLoadbalancersBalancednicsPost(datacenterId, loadbalancerId, nic, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Removes the specific Loadbalancer
         * @summary Delete a Loadbalancer.
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLoadbalancersDelete(datacenterId: string, loadbalancerId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const axiosArgs = await LoadBalancerApiAxiosParamCreator(configuration).datacentersLoadbalancersDelete(datacenterId, loadbalancerId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieves the attributes of a given Loadbalancer
         * @summary Retrieve a loadbalancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLoadbalancersFindById(datacenterId: string, loadbalancerId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Loadbalancer>> {
            const axiosArgs = await LoadBalancerApiAxiosParamCreator(configuration).datacentersLoadbalancersFindById(datacenterId, loadbalancerId, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieve a list of Load Balancers within the datacenter
         * @summary List Load Balancers
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLoadbalancersGet(datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Loadbalancers>> {
            const axiosArgs = await LoadBalancerApiAxiosParamCreator(configuration).datacentersLoadbalancersGet(datacenterId, pretty, depth, xContractNumber, offset, limit, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can use update attributes of a resource
         * @summary Partially modify a Loadbalancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {LoadbalancerProperties} loadbalancer Modified Loadbalancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLoadbalancersPatch(datacenterId: string, loadbalancerId: string, loadbalancer: LoadbalancerProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Loadbalancer>> {
            const axiosArgs = await LoadBalancerApiAxiosParamCreator(configuration).datacentersLoadbalancersPatch(datacenterId, loadbalancerId, loadbalancer, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Creates a Loadbalancer within the datacenter
         * @summary Create a Load Balancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {Loadbalancer} loadbalancer Loadbalancer to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLoadbalancersPost(datacenterId: string, loadbalancer: Loadbalancer, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Loadbalancer>> {
            const axiosArgs = await LoadBalancerApiAxiosParamCreator(configuration).datacentersLoadbalancersPost(datacenterId, loadbalancer, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * You can use update attributes of a resource
         * @summary Modify a Load Balancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {Loadbalancer} loadbalancer Modified Loadbalancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datacentersLoadbalancersPut(datacenterId: string, loadbalancerId: string, loadbalancer: Loadbalancer, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Loadbalancer>> {
            const axiosArgs = await LoadBalancerApiAxiosParamCreator(configuration).datacentersLoadbalancersPut(datacenterId, loadbalancerId, loadbalancer, pretty, depth, xContractNumber, options);
            return runRequest(axiosArgs, configuration);
        },
    }
};

/**
 * LoadBalancerApi - factory interface
 * @export
 */
export const LoadBalancerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This will remove a nic from Load Balancer
         * @summary Detach a nic from loadbalancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersBalancednicsDelete(datacenterId: string, loadbalancerId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return LoadBalancerApiFp(configuration).datacentersLoadbalancersBalancednicsDelete(datacenterId, loadbalancerId, nicId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * This will retrieve the properties of an attached nic.
         * @summary Retrieve a nic attached to Load Balancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {string} nicId The unique ID of the NIC
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersBalancednicsFindByNicId(datacenterId: string, loadbalancerId: string, nicId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Nic> {
            return LoadBalancerApiFp(configuration).datacentersLoadbalancersBalancednicsFindByNicId(datacenterId, loadbalancerId, nicId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can retrieve a list of nics attached to a Load Balancer
         * @summary List Load Balancer Members 
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersBalancednicsGet(datacenterId: string, loadbalancerId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<BalancedNics> {
            return LoadBalancerApiFp(configuration).datacentersLoadbalancersBalancednicsGet(datacenterId, loadbalancerId, pretty, depth, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * This will attach a pre-existing nic to a Load Balancer. 
         * @summary Attach a nic to Load Balancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {Nic} nic Nic id to be attached
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersBalancednicsPost(datacenterId: string, loadbalancerId: string, nic: Nic, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Nic> {
            return LoadBalancerApiFp(configuration).datacentersLoadbalancersBalancednicsPost(datacenterId, loadbalancerId, nic, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the specific Loadbalancer
         * @summary Delete a Loadbalancer.
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersDelete(datacenterId: string, loadbalancerId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<object> {
            return LoadBalancerApiFp(configuration).datacentersLoadbalancersDelete(datacenterId, loadbalancerId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the attributes of a given Loadbalancer
         * @summary Retrieve a loadbalancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersFindById(datacenterId: string, loadbalancerId: string, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Loadbalancer> {
            return LoadBalancerApiFp(configuration).datacentersLoadbalancersFindById(datacenterId, loadbalancerId, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of Load Balancers within the datacenter
         * @summary List Load Balancers
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {number} [offset] the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
         * @param {number} [limit] the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersGet(datacenterId: string, pretty?: boolean, depth?: number, xContractNumber?: number, offset?: number, limit?: number, options?: any): AxiosPromise<Loadbalancers> {
            return LoadBalancerApiFp(configuration).datacentersLoadbalancersGet(datacenterId, pretty, depth, xContractNumber, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use update attributes of a resource
         * @summary Partially modify a Loadbalancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {LoadbalancerProperties} loadbalancer Modified Loadbalancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersPatch(datacenterId: string, loadbalancerId: string, loadbalancer: LoadbalancerProperties, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Loadbalancer> {
            return LoadBalancerApiFp(configuration).datacentersLoadbalancersPatch(datacenterId, loadbalancerId, loadbalancer, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Loadbalancer within the datacenter
         * @summary Create a Load Balancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {Loadbalancer} loadbalancer Loadbalancer to be created
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersPost(datacenterId: string, loadbalancer: Loadbalancer, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Loadbalancer> {
            return LoadBalancerApiFp(configuration).datacentersLoadbalancersPost(datacenterId, loadbalancer, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * You can use update attributes of a resource
         * @summary Modify a Load Balancer
         * @param {string} datacenterId The unique ID of the datacenter
         * @param {string} loadbalancerId The unique ID of the Load Balancer
         * @param {Loadbalancer} loadbalancer Modified Loadbalancer
         * @param {boolean} [pretty] Controls whether response is pretty-printed (with indentation and new lines)
         * @param {number} [depth] Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
         * @param {number} [xContractNumber] Users having more than 1 contract need to provide contract number, against which all API requests should be executed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datacentersLoadbalancersPut(datacenterId: string, loadbalancerId: string, loadbalancer: Loadbalancer, pretty?: boolean, depth?: number, xContractNumber?: number, options?: any): AxiosPromise<Loadbalancer> {
            return LoadBalancerApiFp(configuration).datacentersLoadbalancersPut(datacenterId, loadbalancerId, loadbalancer, pretty, depth, xContractNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for datacentersLoadbalancersBalancednicsDelete operation in LoadBalancerApi.
 * @export
 * @interface LoadBalancerApiDatacentersLoadbalancersBalancednicsDeleteRequest
 */
export interface LoadBalancerApiDatacentersLoadbalancersBalancednicsDeleteRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsDelete
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Load Balancer
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsDelete
     */
    readonly loadbalancerId: string

    /**
     * The unique ID of the NIC
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsDelete
     */
    readonly nicId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLoadbalancersBalancednicsFindByNicId operation in LoadBalancerApi.
 * @export
 * @interface LoadBalancerApiDatacentersLoadbalancersBalancednicsFindByNicIdRequest
 */
export interface LoadBalancerApiDatacentersLoadbalancersBalancednicsFindByNicIdRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsFindByNicId
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Load Balancer
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsFindByNicId
     */
    readonly loadbalancerId: string

    /**
     * The unique ID of the NIC
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsFindByNicId
     */
    readonly nicId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsFindByNicId
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsFindByNicId
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsFindByNicId
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLoadbalancersBalancednicsGet operation in LoadBalancerApi.
 * @export
 * @interface LoadBalancerApiDatacentersLoadbalancersBalancednicsGetRequest
 */
export interface LoadBalancerApiDatacentersLoadbalancersBalancednicsGetRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsGet
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Load Balancer
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsGet
     */
    readonly loadbalancerId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsGet
     */
    readonly xContractNumber?: number

    /**
     * the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsGet
     */
    readonly offset?: number

    /**
     * the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersLoadbalancersBalancednicsPost operation in LoadBalancerApi.
 * @export
 * @interface LoadBalancerApiDatacentersLoadbalancersBalancednicsPostRequest
 */
export interface LoadBalancerApiDatacentersLoadbalancersBalancednicsPostRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsPost
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Load Balancer
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsPost
     */
    readonly loadbalancerId: string

    /**
     * Nic id to be attached
     * @type {Nic}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsPost
     */
    readonly nic: Nic

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersBalancednicsPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLoadbalancersDelete operation in LoadBalancerApi.
 * @export
 * @interface LoadBalancerApiDatacentersLoadbalancersDeleteRequest
 */
export interface LoadBalancerApiDatacentersLoadbalancersDeleteRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersDelete
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Load Balancer
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersDelete
     */
    readonly loadbalancerId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LoadBalancerApiDatacentersLoadbalancersDelete
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersDelete
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersDelete
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLoadbalancersFindById operation in LoadBalancerApi.
 * @export
 * @interface LoadBalancerApiDatacentersLoadbalancersFindByIdRequest
 */
export interface LoadBalancerApiDatacentersLoadbalancersFindByIdRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersFindById
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Load Balancer
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersFindById
     */
    readonly loadbalancerId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LoadBalancerApiDatacentersLoadbalancersFindById
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersFindById
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersFindById
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLoadbalancersGet operation in LoadBalancerApi.
 * @export
 * @interface LoadBalancerApiDatacentersLoadbalancersGetRequest
 */
export interface LoadBalancerApiDatacentersLoadbalancersGetRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersGet
     */
    readonly datacenterId: string

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LoadBalancerApiDatacentersLoadbalancersGet
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersGet
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersGet
     */
    readonly xContractNumber?: number

    /**
     * the first element (of the total list of elements) to include in the response (use together with &lt;code&gt;limit&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersGet
     */
    readonly offset?: number

    /**
     * the maximum number of elements to return (use together with &lt;code&gt;offset&lt;/code&gt; for pagination)
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersGet
     */
    readonly limit?: number
}

/**
 * Request parameters for datacentersLoadbalancersPatch operation in LoadBalancerApi.
 * @export
 * @interface LoadBalancerApiDatacentersLoadbalancersPatchRequest
 */
export interface LoadBalancerApiDatacentersLoadbalancersPatchRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPatch
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Load Balancer
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPatch
     */
    readonly loadbalancerId: string

    /**
     * Modified Loadbalancer
     * @type {LoadbalancerProperties}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPatch
     */
    readonly loadbalancer: LoadbalancerProperties

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPatch
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPatch
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPatch
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLoadbalancersPost operation in LoadBalancerApi.
 * @export
 * @interface LoadBalancerApiDatacentersLoadbalancersPostRequest
 */
export interface LoadBalancerApiDatacentersLoadbalancersPostRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPost
     */
    readonly datacenterId: string

    /**
     * Loadbalancer to be created
     * @type {Loadbalancer}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPost
     */
    readonly loadbalancer: Loadbalancer

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPost
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPost
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPost
     */
    readonly xContractNumber?: number
}

/**
 * Request parameters for datacentersLoadbalancersPut operation in LoadBalancerApi.
 * @export
 * @interface LoadBalancerApiDatacentersLoadbalancersPutRequest
 */
export interface LoadBalancerApiDatacentersLoadbalancersPutRequest {
    /**
     * The unique ID of the datacenter
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPut
     */
    readonly datacenterId: string

    /**
     * The unique ID of the Load Balancer
     * @type {string}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPut
     */
    readonly loadbalancerId: string

    /**
     * Modified Loadbalancer
     * @type {Loadbalancer}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPut
     */
    readonly loadbalancer: Loadbalancer

    /**
     * Controls whether response is pretty-printed (with indentation and new lines)
     * @type {boolean}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPut
     */
    readonly pretty?: boolean

    /**
     * Controls the details depth of response objects.  Eg. GET /datacenters/[ID]  - depth&#x3D;0: only direct properties are included. Children (servers etc.) are not included  - depth&#x3D;1: direct properties and children references are included  - depth&#x3D;2: direct properties and children properties are included  - depth&#x3D;3: direct properties and children properties and children\&#39;s children are included  - depth&#x3D;... and so on
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPut
     */
    readonly depth?: number

    /**
     * Users having more than 1 contract need to provide contract number, against which all API requests should be executed
     * @type {number}
     * @memberof LoadBalancerApiDatacentersLoadbalancersPut
     */
    readonly xContractNumber?: number
}

/**
 * LoadBalancerApi - object-oriented interface
 * @export
 * @class LoadBalancerApi
 * @extends {BaseAPI}
 */
export class LoadBalancerApi extends BaseAPI {
    /**
     * This will remove a nic from Load Balancer
     * @summary Detach a nic from loadbalancer
     * @param {LoadBalancerApiDatacentersLoadbalancersBalancednicsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerApi
     */
    public datacentersLoadbalancersBalancednicsDelete(requestParameters: LoadBalancerApiDatacentersLoadbalancersBalancednicsDeleteRequest, options?: any) {
        return LoadBalancerApiFp(this.configuration).datacentersLoadbalancersBalancednicsDelete(requestParameters.datacenterId, requestParameters.loadbalancerId, requestParameters.nicId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will retrieve the properties of an attached nic.
     * @summary Retrieve a nic attached to Load Balancer
     * @param {LoadBalancerApiDatacentersLoadbalancersBalancednicsFindByNicIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerApi
     */
    public datacentersLoadbalancersBalancednicsFindByNicId(requestParameters: LoadBalancerApiDatacentersLoadbalancersBalancednicsFindByNicIdRequest, options?: any) {
        return LoadBalancerApiFp(this.configuration).datacentersLoadbalancersBalancednicsFindByNicId(requestParameters.datacenterId, requestParameters.loadbalancerId, requestParameters.nicId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can retrieve a list of nics attached to a Load Balancer
     * @summary List Load Balancer Members 
     * @param {LoadBalancerApiDatacentersLoadbalancersBalancednicsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerApi
     */
    public datacentersLoadbalancersBalancednicsGet(requestParameters: LoadBalancerApiDatacentersLoadbalancersBalancednicsGetRequest, options?: any) {
        return LoadBalancerApiFp(this.configuration).datacentersLoadbalancersBalancednicsGet(requestParameters.datacenterId, requestParameters.loadbalancerId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will attach a pre-existing nic to a Load Balancer. 
     * @summary Attach a nic to Load Balancer
     * @param {LoadBalancerApiDatacentersLoadbalancersBalancednicsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerApi
     */
    public datacentersLoadbalancersBalancednicsPost(requestParameters: LoadBalancerApiDatacentersLoadbalancersBalancednicsPostRequest, options?: any) {
        return LoadBalancerApiFp(this.configuration).datacentersLoadbalancersBalancednicsPost(requestParameters.datacenterId, requestParameters.loadbalancerId, requestParameters.nic, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the specific Loadbalancer
     * @summary Delete a Loadbalancer.
     * @param {LoadBalancerApiDatacentersLoadbalancersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerApi
     */
    public datacentersLoadbalancersDelete(requestParameters: LoadBalancerApiDatacentersLoadbalancersDeleteRequest, options?: any) {
        return LoadBalancerApiFp(this.configuration).datacentersLoadbalancersDelete(requestParameters.datacenterId, requestParameters.loadbalancerId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the attributes of a given Loadbalancer
     * @summary Retrieve a loadbalancer
     * @param {LoadBalancerApiDatacentersLoadbalancersFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerApi
     */
    public datacentersLoadbalancersFindById(requestParameters: LoadBalancerApiDatacentersLoadbalancersFindByIdRequest, options?: any) {
        return LoadBalancerApiFp(this.configuration).datacentersLoadbalancersFindById(requestParameters.datacenterId, requestParameters.loadbalancerId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of Load Balancers within the datacenter
     * @summary List Load Balancers
     * @param {LoadBalancerApiDatacentersLoadbalancersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerApi
     */
    public datacentersLoadbalancersGet(requestParameters: LoadBalancerApiDatacentersLoadbalancersGetRequest, options?: any) {
        return LoadBalancerApiFp(this.configuration).datacentersLoadbalancersGet(requestParameters.datacenterId, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use update attributes of a resource
     * @summary Partially modify a Loadbalancer
     * @param {LoadBalancerApiDatacentersLoadbalancersPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerApi
     */
    public datacentersLoadbalancersPatch(requestParameters: LoadBalancerApiDatacentersLoadbalancersPatchRequest, options?: any) {
        return LoadBalancerApiFp(this.configuration).datacentersLoadbalancersPatch(requestParameters.datacenterId, requestParameters.loadbalancerId, requestParameters.loadbalancer, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Loadbalancer within the datacenter
     * @summary Create a Load Balancer
     * @param {LoadBalancerApiDatacentersLoadbalancersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerApi
     */
    public datacentersLoadbalancersPost(requestParameters: LoadBalancerApiDatacentersLoadbalancersPostRequest, options?: any) {
        return LoadBalancerApiFp(this.configuration).datacentersLoadbalancersPost(requestParameters.datacenterId, requestParameters.loadbalancer, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can use update attributes of a resource
     * @summary Modify a Load Balancer
     * @param {LoadBalancerApiDatacentersLoadbalancersPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerApi
     */
    public datacentersLoadbalancersPut(requestParameters: LoadBalancerApiDatacentersLoadbalancersPutRequest, options?: any) {
        return LoadBalancerApiFp(this.configuration).datacentersLoadbalancersPut(requestParameters.datacenterId, requestParameters.loadbalancerId, requestParameters.loadbalancer, requestParameters.pretty, requestParameters.depth, requestParameters.xContractNumber, options).then((request) => request(this.axios, this.basePath));
    }
}
